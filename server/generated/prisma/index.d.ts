
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Cycle
 * @namespace "Cycle"
 */
export type Cycle = $Result.DefaultSelection<Prisma.$CyclePayload>
/**
 * Model CycleProfileConfig
 * 
 */
export type CycleProfileConfig = $Result.DefaultSelection<Prisma.$CycleProfileConfigPayload>
/**
 * Model CycleProvider
 * 
 */
export type CycleProvider = $Result.DefaultSelection<Prisma.$CycleProviderPayload>
/**
 * Model Phase
 * 
 */
export type Phase = $Result.DefaultSelection<Prisma.$PhasePayload>
/**
 * Model Exercise
 * 
 */
export type Exercise = $Result.DefaultSelection<Prisma.$ExercisePayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model ExerciseTag
 * 
 */
export type ExerciseTag = $Result.DefaultSelection<Prisma.$ExerciseTagPayload>
/**
 * Model PhaseExercise
 * 
 */
export type PhaseExercise = $Result.DefaultSelection<Prisma.$PhaseExercisePayload>
/**
 * Model Program
 * 
 */
export type Program = $Result.DefaultSelection<Prisma.$ProgramPayload>
/**
 * Model ProgramExercise
 * 
 */
export type ProgramExercise = $Result.DefaultSelection<Prisma.$ProgramExercisePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model ExternalSync
 * 
 */
export type ExternalSync = $Result.DefaultSelection<Prisma.$ExternalSyncPayload>
/**
 * Model JournalEntry
 * 
 */
export type JournalEntry = $Result.DefaultSelection<Prisma.$JournalEntryPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Log
 * 
 */
export type Log = $Result.DefaultSelection<Prisma.$LogPayload>
/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model AuthSession
 * 
 */
export type AuthSession = $Result.DefaultSelection<Prisma.$AuthSessionPayload>
/**
 * Model MoodTrack
 * 
 */
export type MoodTrack = $Result.DefaultSelection<Prisma.$MoodTrackPayload>
/**
 * Model SymptomLog
 * 
 */
export type SymptomLog = $Result.DefaultSelection<Prisma.$SymptomLogPayload>
/**
 * Model UserSettings
 * 
 */
export type UserSettings = $Result.DefaultSelection<Prisma.$UserSettingsPayload>
/**
 * Model ReminderSettings
 * 
 */
export type ReminderSettings = $Result.DefaultSelection<Prisma.$ReminderSettingsPayload>
/**
 * Model UserFeatureFlag
 * 
 */
export type UserFeatureFlag = $Result.DefaultSelection<Prisma.$UserFeatureFlagPayload>
/**
 * Model UserObjective
 * 
 */
export type UserObjective = $Result.DefaultSelection<Prisma.$UserObjectivePayload>
/**
 * Model ProfileChangeLog
 * 
 */
export type ProfileChangeLog = $Result.DefaultSelection<Prisma.$ProfileChangeLogPayload>
/**
 * Model User
 * @namespace "User"
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const CyclePhase: {
  MENSTRUAL: 'MENSTRUAL',
  FOLLICULAR: 'FOLLICULAR',
  OVULATION: 'OVULATION',
  LUTEAL: 'LUTEAL'
};

export type CyclePhase = (typeof CyclePhase)[keyof typeof CyclePhase]


export const Intensity: {
  VERY_LOW: 'VERY_LOW',
  LOW: 'LOW',
  MODERATE: 'MODERATE',
  HIGH: 'HIGH',
  VERY_HIGH: 'VERY_HIGH'
};

export type Intensity = (typeof Intensity)[keyof typeof Intensity]


export const MuscleZone: {
  UPPER_BODY: 'UPPER_BODY',
  LOWER_BODY: 'LOWER_BODY',
  CORE: 'CORE',
  FULL_BODY: 'FULL_BODY',
  CARDIO: 'CARDIO',
  FLEXIBILITY: 'FLEXIBILITY',
  BALANCE: 'BALANCE'
};

export type MuscleZone = (typeof MuscleZone)[keyof typeof MuscleZone]


export const TagType: {
  DIFFICULTY: 'DIFFICULTY',
  EQUIPMENT: 'EQUIPMENT',
  MUSCLE_GROUP: 'MUSCLE_GROUP',
  OBJECTIVE: 'OBJECTIVE',
  DURATION: 'DURATION',
  STYLE: 'STYLE'
};

export type TagType = (typeof TagType)[keyof typeof TagType]


export const NotificationType: {
  CYCLE_REMINDER: 'CYCLE_REMINDER',
  EXERCISE_REMINDER: 'EXERCISE_REMINDER',
  MEDICATION_REMINDER: 'MEDICATION_REMINDER',
  MOOD_TRACKING_REMINDER: 'MOOD_TRACKING_REMINDER',
  PERIOD_PREDICTION: 'PERIOD_PREDICTION',
  OVULATION_PREDICTION: 'OVULATION_PREDICTION',
  PROGRAM_MILESTONE: 'PROGRAM_MILESTONE',
  GENERAL_TIP: 'GENERAL_TIP',
  SYSTEM_UPDATE: 'SYSTEM_UPDATE'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const ReminderType: {
  PERIOD_START: 'PERIOD_START',
  OVULATION: 'OVULATION',
  EXERCISE: 'EXERCISE',
  MEDICATION: 'MEDICATION',
  MOOD_TRACKING: 'MOOD_TRACKING',
  SYMPTOM_LOGGING: 'SYMPTOM_LOGGING',
  WATER_INTAKE: 'WATER_INTAKE',
  SLEEP_REMINDER: 'SLEEP_REMINDER'
};

export type ReminderType = (typeof ReminderType)[keyof typeof ReminderType]


export const ExternalSyncStatus: {
  PENDING: 'PENDING',
  SUCCESS: 'SUCCESS',
  FAILED: 'FAILED',
  PARTIAL: 'PARTIAL',
  SKIPPED: 'SKIPPED'
};

export type ExternalSyncStatus = (typeof ExternalSyncStatus)[keyof typeof ExternalSyncStatus]


export const ExternalProvider: {
  APPLE_HEALTH: 'APPLE_HEALTH',
  GOOGLE_FIT: 'GOOGLE_FIT',
  FITBIT: 'FITBIT',
  GARMIN: 'GARMIN',
  STRAVA: 'STRAVA',
  MYFITNESSPAL: 'MYFITNESSPAL',
  CLUE: 'CLUE',
  FLO: 'FLO',
  PERIOD_TRACKER: 'PERIOD_TRACKER'
};

export type ExternalProvider = (typeof ExternalProvider)[keyof typeof ExternalProvider]


export const JournalCategory: {
  GENERAL: 'GENERAL',
  CYCLE: 'CYCLE',
  EXERCISE: 'EXERCISE',
  MOOD: 'MOOD',
  NUTRITION: 'NUTRITION',
  SLEEP: 'SLEEP',
  STRESS: 'STRESS',
  GOALS: 'GOALS',
  ACHIEVEMENTS: 'ACHIEVEMENTS'
};

export type JournalCategory = (typeof JournalCategory)[keyof typeof JournalCategory]


export const EventType: {
  USER_LOGIN: 'USER_LOGIN',
  USER_LOGOUT: 'USER_LOGOUT',
  PROFILE_UPDATE: 'PROFILE_UPDATE',
  CYCLE_LOG: 'CYCLE_LOG',
  EXERCISE_COMPLETE: 'EXERCISE_COMPLETE',
  MOOD_LOG: 'MOOD_LOG',
  SYMPTOM_LOG: 'SYMPTOM_LOG',
  PROGRAM_START: 'PROGRAM_START',
  PROGRAM_COMPLETE: 'PROGRAM_COMPLETE',
  SYNC_EXTERNAL: 'SYNC_EXTERNAL',
  ERROR_OCCURRED: 'ERROR_OCCURRED'
};

export type EventType = (typeof EventType)[keyof typeof EventType]


export const MoodType: {
  VERY_HAPPY: 'VERY_HAPPY',
  HAPPY: 'HAPPY',
  NEUTRAL: 'NEUTRAL',
  SAD: 'SAD',
  VERY_SAD: 'VERY_SAD',
  ANXIOUS: 'ANXIOUS',
  IRRITATED: 'IRRITATED',
  CALM: 'CALM',
  ENERGETIC: 'ENERGETIC',
  TIRED: 'TIRED',
  STRESSED: 'STRESSED',
  RELAXED: 'RELAXED'
};

export type MoodType = (typeof MoodType)[keyof typeof MoodType]


export const EnergyLevel: {
  VERY_LOW: 'VERY_LOW',
  LOW: 'LOW',
  MODERATE: 'MODERATE',
  HIGH: 'HIGH',
  VERY_HIGH: 'VERY_HIGH'
};

export type EnergyLevel = (typeof EnergyLevel)[keyof typeof EnergyLevel]


export const PainLevel: {
  NONE: 'NONE',
  LIGHT: 'LIGHT',
  MODERATE: 'MODERATE',
  SEVERE: 'SEVERE',
  VERY_SEVERE: 'VERY_SEVERE'
};

export type PainLevel = (typeof PainLevel)[keyof typeof PainLevel]


export const StressLevel: {
  NONE: 'NONE',
  LOW: 'LOW',
  MODERATE: 'MODERATE',
  HIGH: 'HIGH',
  VERY_HIGH: 'VERY_HIGH'
};

export type StressLevel = (typeof StressLevel)[keyof typeof StressLevel]


export const SleepQuality: {
  VERY_POOR: 'VERY_POOR',
  POOR: 'POOR',
  FAIR: 'FAIR',
  GOOD: 'GOOD',
  EXCELLENT: 'EXCELLENT'
};

export type SleepQuality = (typeof SleepQuality)[keyof typeof SleepQuality]


export const SymptomType: {
  CRAMPS: 'CRAMPS',
  BLOATING: 'BLOATING',
  HEADACHE: 'HEADACHE',
  BACK_PAIN: 'BACK_PAIN',
  BREAST_TENDERNESS: 'BREAST_TENDERNESS',
  ACNE: 'ACNE',
  MOOD_SWINGS: 'MOOD_SWINGS',
  FATIGUE: 'FATIGUE',
  NAUSEA: 'NAUSEA',
  FOOD_CRAVINGS: 'FOOD_CRAVINGS',
  CONSTIPATION: 'CONSTIPATION',
  DIARRHEA: 'DIARRHEA',
  HOT_FLASHES: 'HOT_FLASHES',
  COLD_FLASHES: 'COLD_FLASHES',
  JOINT_PAIN: 'JOINT_PAIN',
  INSOMNIA: 'INSOMNIA'
};

export type SymptomType = (typeof SymptomType)[keyof typeof SymptomType]


export const ProfileType: {
  FEMALE: 'FEMALE',
  MALE: 'MALE',
  NON_BINARY: 'NON_BINARY',
  OTHER: 'OTHER'
};

export type ProfileType = (typeof ProfileType)[keyof typeof ProfileType]


export const ContextType: {
  CYCLE: 'CYCLE',
  GENERAL: 'GENERAL',
  MENOPAUSE: 'MENOPAUSE',
  NONE: 'NONE'
};

export type ContextType = (typeof ContextType)[keyof typeof ContextType]


export const ObjectiveType: {
  WEIGHT_LOSS: 'WEIGHT_LOSS',
  MUSCLE_GAIN: 'MUSCLE_GAIN',
  ENDURANCE: 'ENDURANCE',
  STRENGTH: 'STRENGTH',
  FLEXIBILITY: 'FLEXIBILITY',
  GENERAL_FITNESS: 'GENERAL_FITNESS',
  STRESS_REDUCTION: 'STRESS_REDUCTION',
  ENERGY_BOOST: 'ENERGY_BOOST'
};

export type ObjectiveType = (typeof ObjectiveType)[keyof typeof ObjectiveType]


export const SportFrequency: {
  SEDENTARY: 'SEDENTARY',
  LIGHT: 'LIGHT',
  MODERATE: 'MODERATE',
  ACTIVE: 'ACTIVE',
  VERY_ACTIVE: 'VERY_ACTIVE'
};

export type SportFrequency = (typeof SportFrequency)[keyof typeof SportFrequency]


export const UnitPreference: {
  METRIC: 'METRIC',
  IMPERIAL: 'IMPERIAL'
};

export type UnitPreference = (typeof UnitPreference)[keyof typeof UnitPreference]


export const ChangeType: {
  PROFILE_UPDATE: 'PROFILE_UPDATE',
  SETTINGS_UPDATE: 'SETTINGS_UPDATE',
  CYCLE_CONFIG_UPDATE: 'CYCLE_CONFIG_UPDATE',
  OBJECTIVE_UPDATE: 'OBJECTIVE_UPDATE',
  PASSWORD_CHANGE: 'PASSWORD_CHANGE'
};

export type ChangeType = (typeof ChangeType)[keyof typeof ChangeType]

}

export type CyclePhase = $Enums.CyclePhase

export const CyclePhase: typeof $Enums.CyclePhase

export type Intensity = $Enums.Intensity

export const Intensity: typeof $Enums.Intensity

export type MuscleZone = $Enums.MuscleZone

export const MuscleZone: typeof $Enums.MuscleZone

export type TagType = $Enums.TagType

export const TagType: typeof $Enums.TagType

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type ReminderType = $Enums.ReminderType

export const ReminderType: typeof $Enums.ReminderType

export type ExternalSyncStatus = $Enums.ExternalSyncStatus

export const ExternalSyncStatus: typeof $Enums.ExternalSyncStatus

export type ExternalProvider = $Enums.ExternalProvider

export const ExternalProvider: typeof $Enums.ExternalProvider

export type JournalCategory = $Enums.JournalCategory

export const JournalCategory: typeof $Enums.JournalCategory

export type EventType = $Enums.EventType

export const EventType: typeof $Enums.EventType

export type MoodType = $Enums.MoodType

export const MoodType: typeof $Enums.MoodType

export type EnergyLevel = $Enums.EnergyLevel

export const EnergyLevel: typeof $Enums.EnergyLevel

export type PainLevel = $Enums.PainLevel

export const PainLevel: typeof $Enums.PainLevel

export type StressLevel = $Enums.StressLevel

export const StressLevel: typeof $Enums.StressLevel

export type SleepQuality = $Enums.SleepQuality

export const SleepQuality: typeof $Enums.SleepQuality

export type SymptomType = $Enums.SymptomType

export const SymptomType: typeof $Enums.SymptomType

export type ProfileType = $Enums.ProfileType

export const ProfileType: typeof $Enums.ProfileType

export type ContextType = $Enums.ContextType

export const ContextType: typeof $Enums.ContextType

export type ObjectiveType = $Enums.ObjectiveType

export const ObjectiveType: typeof $Enums.ObjectiveType

export type SportFrequency = $Enums.SportFrequency

export const SportFrequency: typeof $Enums.SportFrequency

export type UnitPreference = $Enums.UnitPreference

export const UnitPreference: typeof $Enums.UnitPreference

export type ChangeType = $Enums.ChangeType

export const ChangeType: typeof $Enums.ChangeType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Cycles
 * const cycles = await prisma.cycle.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Cycles
   * const cycles = await prisma.cycle.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.cycle`: Exposes CRUD operations for the **Cycle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cycles
    * const cycles = await prisma.cycle.findMany()
    * ```
    */
  get cycle(): Prisma.CycleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cycleProfileConfig`: Exposes CRUD operations for the **CycleProfileConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CycleProfileConfigs
    * const cycleProfileConfigs = await prisma.cycleProfileConfig.findMany()
    * ```
    */
  get cycleProfileConfig(): Prisma.CycleProfileConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cycleProvider`: Exposes CRUD operations for the **CycleProvider** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CycleProviders
    * const cycleProviders = await prisma.cycleProvider.findMany()
    * ```
    */
  get cycleProvider(): Prisma.CycleProviderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.phase`: Exposes CRUD operations for the **Phase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Phases
    * const phases = await prisma.phase.findMany()
    * ```
    */
  get phase(): Prisma.PhaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exercise`: Exposes CRUD operations for the **Exercise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exercises
    * const exercises = await prisma.exercise.findMany()
    * ```
    */
  get exercise(): Prisma.ExerciseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exerciseTag`: Exposes CRUD operations for the **ExerciseTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExerciseTags
    * const exerciseTags = await prisma.exerciseTag.findMany()
    * ```
    */
  get exerciseTag(): Prisma.ExerciseTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.phaseExercise`: Exposes CRUD operations for the **PhaseExercise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PhaseExercises
    * const phaseExercises = await prisma.phaseExercise.findMany()
    * ```
    */
  get phaseExercise(): Prisma.PhaseExerciseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.program`: Exposes CRUD operations for the **Program** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Programs
    * const programs = await prisma.program.findMany()
    * ```
    */
  get program(): Prisma.ProgramDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.programExercise`: Exposes CRUD operations for the **ProgramExercise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProgramExercises
    * const programExercises = await prisma.programExercise.findMany()
    * ```
    */
  get programExercise(): Prisma.ProgramExerciseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.externalSync`: Exposes CRUD operations for the **ExternalSync** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExternalSyncs
    * const externalSyncs = await prisma.externalSync.findMany()
    * ```
    */
  get externalSync(): Prisma.ExternalSyncDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.journalEntry`: Exposes CRUD operations for the **JournalEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JournalEntries
    * const journalEntries = await prisma.journalEntry.findMany()
    * ```
    */
  get journalEntry(): Prisma.JournalEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.log`: Exposes CRUD operations for the **Log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logs
    * const logs = await prisma.log.findMany()
    * ```
    */
  get log(): Prisma.LogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.authSession`: Exposes CRUD operations for the **AuthSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuthSessions
    * const authSessions = await prisma.authSession.findMany()
    * ```
    */
  get authSession(): Prisma.AuthSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.moodTrack`: Exposes CRUD operations for the **MoodTrack** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MoodTracks
    * const moodTracks = await prisma.moodTrack.findMany()
    * ```
    */
  get moodTrack(): Prisma.MoodTrackDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.symptomLog`: Exposes CRUD operations for the **SymptomLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SymptomLogs
    * const symptomLogs = await prisma.symptomLog.findMany()
    * ```
    */
  get symptomLog(): Prisma.SymptomLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSettings`: Exposes CRUD operations for the **UserSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSettings
    * const userSettings = await prisma.userSettings.findMany()
    * ```
    */
  get userSettings(): Prisma.UserSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reminderSettings`: Exposes CRUD operations for the **ReminderSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReminderSettings
    * const reminderSettings = await prisma.reminderSettings.findMany()
    * ```
    */
  get reminderSettings(): Prisma.ReminderSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userFeatureFlag`: Exposes CRUD operations for the **UserFeatureFlag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserFeatureFlags
    * const userFeatureFlags = await prisma.userFeatureFlag.findMany()
    * ```
    */
  get userFeatureFlag(): Prisma.UserFeatureFlagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userObjective`: Exposes CRUD operations for the **UserObjective** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserObjectives
    * const userObjectives = await prisma.userObjective.findMany()
    * ```
    */
  get userObjective(): Prisma.UserObjectiveDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.profileChangeLog`: Exposes CRUD operations for the **ProfileChangeLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProfileChangeLogs
    * const profileChangeLogs = await prisma.profileChangeLog.findMany()
    * ```
    */
  get profileChangeLog(): Prisma.ProfileChangeLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.11.1
   * Query Engine version: f40f79ec31188888a2e33acda0ecc8fd10a853a9
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Cycle: 'Cycle',
    CycleProfileConfig: 'CycleProfileConfig',
    CycleProvider: 'CycleProvider',
    Phase: 'Phase',
    Exercise: 'Exercise',
    Tag: 'Tag',
    ExerciseTag: 'ExerciseTag',
    PhaseExercise: 'PhaseExercise',
    Program: 'Program',
    ProgramExercise: 'ProgramExercise',
    Notification: 'Notification',
    ExternalSync: 'ExternalSync',
    JournalEntry: 'JournalEntry',
    AuditLog: 'AuditLog',
    Log: 'Log',
    RefreshToken: 'RefreshToken',
    AuthSession: 'AuthSession',
    MoodTrack: 'MoodTrack',
    SymptomLog: 'SymptomLog',
    UserSettings: 'UserSettings',
    ReminderSettings: 'ReminderSettings',
    UserFeatureFlag: 'UserFeatureFlag',
    UserObjective: 'UserObjective',
    ProfileChangeLog: 'ProfileChangeLog',
    User: 'User'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "cycle" | "cycleProfileConfig" | "cycleProvider" | "phase" | "exercise" | "tag" | "exerciseTag" | "phaseExercise" | "program" | "programExercise" | "notification" | "externalSync" | "journalEntry" | "auditLog" | "log" | "refreshToken" | "authSession" | "moodTrack" | "symptomLog" | "userSettings" | "reminderSettings" | "userFeatureFlag" | "userObjective" | "profileChangeLog" | "user"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Cycle: {
        payload: Prisma.$CyclePayload<ExtArgs>
        fields: Prisma.CycleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CycleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CyclePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CycleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CyclePayload>
          }
          findFirst: {
            args: Prisma.CycleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CyclePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CycleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CyclePayload>
          }
          findMany: {
            args: Prisma.CycleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CyclePayload>[]
          }
          create: {
            args: Prisma.CycleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CyclePayload>
          }
          createMany: {
            args: Prisma.CycleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CycleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CyclePayload>[]
          }
          delete: {
            args: Prisma.CycleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CyclePayload>
          }
          update: {
            args: Prisma.CycleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CyclePayload>
          }
          deleteMany: {
            args: Prisma.CycleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CycleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CycleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CyclePayload>[]
          }
          upsert: {
            args: Prisma.CycleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CyclePayload>
          }
          aggregate: {
            args: Prisma.CycleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCycle>
          }
          groupBy: {
            args: Prisma.CycleGroupByArgs<ExtArgs>
            result: $Utils.Optional<CycleGroupByOutputType>[]
          }
          count: {
            args: Prisma.CycleCountArgs<ExtArgs>
            result: $Utils.Optional<CycleCountAggregateOutputType> | number
          }
        }
      }
      CycleProfileConfig: {
        payload: Prisma.$CycleProfileConfigPayload<ExtArgs>
        fields: Prisma.CycleProfileConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CycleProfileConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CycleProfileConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CycleProfileConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CycleProfileConfigPayload>
          }
          findFirst: {
            args: Prisma.CycleProfileConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CycleProfileConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CycleProfileConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CycleProfileConfigPayload>
          }
          findMany: {
            args: Prisma.CycleProfileConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CycleProfileConfigPayload>[]
          }
          create: {
            args: Prisma.CycleProfileConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CycleProfileConfigPayload>
          }
          createMany: {
            args: Prisma.CycleProfileConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CycleProfileConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CycleProfileConfigPayload>[]
          }
          delete: {
            args: Prisma.CycleProfileConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CycleProfileConfigPayload>
          }
          update: {
            args: Prisma.CycleProfileConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CycleProfileConfigPayload>
          }
          deleteMany: {
            args: Prisma.CycleProfileConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CycleProfileConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CycleProfileConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CycleProfileConfigPayload>[]
          }
          upsert: {
            args: Prisma.CycleProfileConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CycleProfileConfigPayload>
          }
          aggregate: {
            args: Prisma.CycleProfileConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCycleProfileConfig>
          }
          groupBy: {
            args: Prisma.CycleProfileConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<CycleProfileConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.CycleProfileConfigCountArgs<ExtArgs>
            result: $Utils.Optional<CycleProfileConfigCountAggregateOutputType> | number
          }
        }
      }
      CycleProvider: {
        payload: Prisma.$CycleProviderPayload<ExtArgs>
        fields: Prisma.CycleProviderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CycleProviderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CycleProviderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CycleProviderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CycleProviderPayload>
          }
          findFirst: {
            args: Prisma.CycleProviderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CycleProviderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CycleProviderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CycleProviderPayload>
          }
          findMany: {
            args: Prisma.CycleProviderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CycleProviderPayload>[]
          }
          create: {
            args: Prisma.CycleProviderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CycleProviderPayload>
          }
          createMany: {
            args: Prisma.CycleProviderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CycleProviderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CycleProviderPayload>[]
          }
          delete: {
            args: Prisma.CycleProviderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CycleProviderPayload>
          }
          update: {
            args: Prisma.CycleProviderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CycleProviderPayload>
          }
          deleteMany: {
            args: Prisma.CycleProviderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CycleProviderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CycleProviderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CycleProviderPayload>[]
          }
          upsert: {
            args: Prisma.CycleProviderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CycleProviderPayload>
          }
          aggregate: {
            args: Prisma.CycleProviderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCycleProvider>
          }
          groupBy: {
            args: Prisma.CycleProviderGroupByArgs<ExtArgs>
            result: $Utils.Optional<CycleProviderGroupByOutputType>[]
          }
          count: {
            args: Prisma.CycleProviderCountArgs<ExtArgs>
            result: $Utils.Optional<CycleProviderCountAggregateOutputType> | number
          }
        }
      }
      Phase: {
        payload: Prisma.$PhasePayload<ExtArgs>
        fields: Prisma.PhaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PhaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PhaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhasePayload>
          }
          findFirst: {
            args: Prisma.PhaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PhaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhasePayload>
          }
          findMany: {
            args: Prisma.PhaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhasePayload>[]
          }
          create: {
            args: Prisma.PhaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhasePayload>
          }
          createMany: {
            args: Prisma.PhaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PhaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhasePayload>[]
          }
          delete: {
            args: Prisma.PhaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhasePayload>
          }
          update: {
            args: Prisma.PhaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhasePayload>
          }
          deleteMany: {
            args: Prisma.PhaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PhaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PhaseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhasePayload>[]
          }
          upsert: {
            args: Prisma.PhaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhasePayload>
          }
          aggregate: {
            args: Prisma.PhaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhase>
          }
          groupBy: {
            args: Prisma.PhaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<PhaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.PhaseCountArgs<ExtArgs>
            result: $Utils.Optional<PhaseCountAggregateOutputType> | number
          }
        }
      }
      Exercise: {
        payload: Prisma.$ExercisePayload<ExtArgs>
        fields: Prisma.ExerciseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExerciseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExerciseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          findFirst: {
            args: Prisma.ExerciseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExerciseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          findMany: {
            args: Prisma.ExerciseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>[]
          }
          create: {
            args: Prisma.ExerciseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          createMany: {
            args: Prisma.ExerciseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExerciseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>[]
          }
          delete: {
            args: Prisma.ExerciseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          update: {
            args: Prisma.ExerciseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          deleteMany: {
            args: Prisma.ExerciseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExerciseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExerciseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>[]
          }
          upsert: {
            args: Prisma.ExerciseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          aggregate: {
            args: Prisma.ExerciseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExercise>
          }
          groupBy: {
            args: Prisma.ExerciseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExerciseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExerciseCountArgs<ExtArgs>
            result: $Utils.Optional<ExerciseCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      ExerciseTag: {
        payload: Prisma.$ExerciseTagPayload<ExtArgs>
        fields: Prisma.ExerciseTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExerciseTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExerciseTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseTagPayload>
          }
          findFirst: {
            args: Prisma.ExerciseTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExerciseTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseTagPayload>
          }
          findMany: {
            args: Prisma.ExerciseTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseTagPayload>[]
          }
          create: {
            args: Prisma.ExerciseTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseTagPayload>
          }
          createMany: {
            args: Prisma.ExerciseTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExerciseTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseTagPayload>[]
          }
          delete: {
            args: Prisma.ExerciseTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseTagPayload>
          }
          update: {
            args: Prisma.ExerciseTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseTagPayload>
          }
          deleteMany: {
            args: Prisma.ExerciseTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExerciseTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExerciseTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseTagPayload>[]
          }
          upsert: {
            args: Prisma.ExerciseTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseTagPayload>
          }
          aggregate: {
            args: Prisma.ExerciseTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExerciseTag>
          }
          groupBy: {
            args: Prisma.ExerciseTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExerciseTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExerciseTagCountArgs<ExtArgs>
            result: $Utils.Optional<ExerciseTagCountAggregateOutputType> | number
          }
        }
      }
      PhaseExercise: {
        payload: Prisma.$PhaseExercisePayload<ExtArgs>
        fields: Prisma.PhaseExerciseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PhaseExerciseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhaseExercisePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PhaseExerciseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhaseExercisePayload>
          }
          findFirst: {
            args: Prisma.PhaseExerciseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhaseExercisePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PhaseExerciseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhaseExercisePayload>
          }
          findMany: {
            args: Prisma.PhaseExerciseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhaseExercisePayload>[]
          }
          create: {
            args: Prisma.PhaseExerciseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhaseExercisePayload>
          }
          createMany: {
            args: Prisma.PhaseExerciseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PhaseExerciseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhaseExercisePayload>[]
          }
          delete: {
            args: Prisma.PhaseExerciseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhaseExercisePayload>
          }
          update: {
            args: Prisma.PhaseExerciseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhaseExercisePayload>
          }
          deleteMany: {
            args: Prisma.PhaseExerciseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PhaseExerciseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PhaseExerciseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhaseExercisePayload>[]
          }
          upsert: {
            args: Prisma.PhaseExerciseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhaseExercisePayload>
          }
          aggregate: {
            args: Prisma.PhaseExerciseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhaseExercise>
          }
          groupBy: {
            args: Prisma.PhaseExerciseGroupByArgs<ExtArgs>
            result: $Utils.Optional<PhaseExerciseGroupByOutputType>[]
          }
          count: {
            args: Prisma.PhaseExerciseCountArgs<ExtArgs>
            result: $Utils.Optional<PhaseExerciseCountAggregateOutputType> | number
          }
        }
      }
      Program: {
        payload: Prisma.$ProgramPayload<ExtArgs>
        fields: Prisma.ProgramFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgramFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgramFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          findFirst: {
            args: Prisma.ProgramFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgramFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          findMany: {
            args: Prisma.ProgramFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>[]
          }
          create: {
            args: Prisma.ProgramCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          createMany: {
            args: Prisma.ProgramCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProgramCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>[]
          }
          delete: {
            args: Prisma.ProgramDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          update: {
            args: Prisma.ProgramUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          deleteMany: {
            args: Prisma.ProgramDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgramUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProgramUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>[]
          }
          upsert: {
            args: Prisma.ProgramUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          aggregate: {
            args: Prisma.ProgramAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProgram>
          }
          groupBy: {
            args: Prisma.ProgramGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgramGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgramCountArgs<ExtArgs>
            result: $Utils.Optional<ProgramCountAggregateOutputType> | number
          }
        }
      }
      ProgramExercise: {
        payload: Prisma.$ProgramExercisePayload<ExtArgs>
        fields: Prisma.ProgramExerciseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgramExerciseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramExercisePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgramExerciseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramExercisePayload>
          }
          findFirst: {
            args: Prisma.ProgramExerciseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramExercisePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgramExerciseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramExercisePayload>
          }
          findMany: {
            args: Prisma.ProgramExerciseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramExercisePayload>[]
          }
          create: {
            args: Prisma.ProgramExerciseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramExercisePayload>
          }
          createMany: {
            args: Prisma.ProgramExerciseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProgramExerciseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramExercisePayload>[]
          }
          delete: {
            args: Prisma.ProgramExerciseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramExercisePayload>
          }
          update: {
            args: Prisma.ProgramExerciseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramExercisePayload>
          }
          deleteMany: {
            args: Prisma.ProgramExerciseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgramExerciseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProgramExerciseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramExercisePayload>[]
          }
          upsert: {
            args: Prisma.ProgramExerciseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramExercisePayload>
          }
          aggregate: {
            args: Prisma.ProgramExerciseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProgramExercise>
          }
          groupBy: {
            args: Prisma.ProgramExerciseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgramExerciseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgramExerciseCountArgs<ExtArgs>
            result: $Utils.Optional<ProgramExerciseCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      ExternalSync: {
        payload: Prisma.$ExternalSyncPayload<ExtArgs>
        fields: Prisma.ExternalSyncFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExternalSyncFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalSyncPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExternalSyncFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalSyncPayload>
          }
          findFirst: {
            args: Prisma.ExternalSyncFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalSyncPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExternalSyncFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalSyncPayload>
          }
          findMany: {
            args: Prisma.ExternalSyncFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalSyncPayload>[]
          }
          create: {
            args: Prisma.ExternalSyncCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalSyncPayload>
          }
          createMany: {
            args: Prisma.ExternalSyncCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExternalSyncCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalSyncPayload>[]
          }
          delete: {
            args: Prisma.ExternalSyncDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalSyncPayload>
          }
          update: {
            args: Prisma.ExternalSyncUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalSyncPayload>
          }
          deleteMany: {
            args: Prisma.ExternalSyncDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExternalSyncUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExternalSyncUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalSyncPayload>[]
          }
          upsert: {
            args: Prisma.ExternalSyncUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalSyncPayload>
          }
          aggregate: {
            args: Prisma.ExternalSyncAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExternalSync>
          }
          groupBy: {
            args: Prisma.ExternalSyncGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExternalSyncGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExternalSyncCountArgs<ExtArgs>
            result: $Utils.Optional<ExternalSyncCountAggregateOutputType> | number
          }
        }
      }
      JournalEntry: {
        payload: Prisma.$JournalEntryPayload<ExtArgs>
        fields: Prisma.JournalEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JournalEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JournalEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          findFirst: {
            args: Prisma.JournalEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JournalEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          findMany: {
            args: Prisma.JournalEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>[]
          }
          create: {
            args: Prisma.JournalEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          createMany: {
            args: Prisma.JournalEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JournalEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>[]
          }
          delete: {
            args: Prisma.JournalEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          update: {
            args: Prisma.JournalEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          deleteMany: {
            args: Prisma.JournalEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JournalEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JournalEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>[]
          }
          upsert: {
            args: Prisma.JournalEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalEntryPayload>
          }
          aggregate: {
            args: Prisma.JournalEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJournalEntry>
          }
          groupBy: {
            args: Prisma.JournalEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<JournalEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.JournalEntryCountArgs<ExtArgs>
            result: $Utils.Optional<JournalEntryCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Log: {
        payload: Prisma.$LogPayload<ExtArgs>
        fields: Prisma.LogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          findFirst: {
            args: Prisma.LogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          findMany: {
            args: Prisma.LogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>[]
          }
          create: {
            args: Prisma.LogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          createMany: {
            args: Prisma.LogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>[]
          }
          delete: {
            args: Prisma.LogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          update: {
            args: Prisma.LogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          deleteMany: {
            args: Prisma.LogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>[]
          }
          upsert: {
            args: Prisma.LogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          aggregate: {
            args: Prisma.LogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLog>
          }
          groupBy: {
            args: Prisma.LogGroupByArgs<ExtArgs>
            result: $Utils.Optional<LogGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogCountArgs<ExtArgs>
            result: $Utils.Optional<LogCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RefreshTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      AuthSession: {
        payload: Prisma.$AuthSessionPayload<ExtArgs>
        fields: Prisma.AuthSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuthSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuthSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload>
          }
          findFirst: {
            args: Prisma.AuthSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuthSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload>
          }
          findMany: {
            args: Prisma.AuthSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload>[]
          }
          create: {
            args: Prisma.AuthSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload>
          }
          createMany: {
            args: Prisma.AuthSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuthSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload>[]
          }
          delete: {
            args: Prisma.AuthSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload>
          }
          update: {
            args: Prisma.AuthSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload>
          }
          deleteMany: {
            args: Prisma.AuthSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuthSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuthSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload>[]
          }
          upsert: {
            args: Prisma.AuthSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthSessionPayload>
          }
          aggregate: {
            args: Prisma.AuthSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuthSession>
          }
          groupBy: {
            args: Prisma.AuthSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuthSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuthSessionCountArgs<ExtArgs>
            result: $Utils.Optional<AuthSessionCountAggregateOutputType> | number
          }
        }
      }
      MoodTrack: {
        payload: Prisma.$MoodTrackPayload<ExtArgs>
        fields: Prisma.MoodTrackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MoodTrackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodTrackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MoodTrackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodTrackPayload>
          }
          findFirst: {
            args: Prisma.MoodTrackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodTrackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MoodTrackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodTrackPayload>
          }
          findMany: {
            args: Prisma.MoodTrackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodTrackPayload>[]
          }
          create: {
            args: Prisma.MoodTrackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodTrackPayload>
          }
          createMany: {
            args: Prisma.MoodTrackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MoodTrackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodTrackPayload>[]
          }
          delete: {
            args: Prisma.MoodTrackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodTrackPayload>
          }
          update: {
            args: Prisma.MoodTrackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodTrackPayload>
          }
          deleteMany: {
            args: Prisma.MoodTrackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MoodTrackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MoodTrackUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodTrackPayload>[]
          }
          upsert: {
            args: Prisma.MoodTrackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoodTrackPayload>
          }
          aggregate: {
            args: Prisma.MoodTrackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMoodTrack>
          }
          groupBy: {
            args: Prisma.MoodTrackGroupByArgs<ExtArgs>
            result: $Utils.Optional<MoodTrackGroupByOutputType>[]
          }
          count: {
            args: Prisma.MoodTrackCountArgs<ExtArgs>
            result: $Utils.Optional<MoodTrackCountAggregateOutputType> | number
          }
        }
      }
      SymptomLog: {
        payload: Prisma.$SymptomLogPayload<ExtArgs>
        fields: Prisma.SymptomLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SymptomLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymptomLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SymptomLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymptomLogPayload>
          }
          findFirst: {
            args: Prisma.SymptomLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymptomLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SymptomLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymptomLogPayload>
          }
          findMany: {
            args: Prisma.SymptomLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymptomLogPayload>[]
          }
          create: {
            args: Prisma.SymptomLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymptomLogPayload>
          }
          createMany: {
            args: Prisma.SymptomLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SymptomLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymptomLogPayload>[]
          }
          delete: {
            args: Prisma.SymptomLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymptomLogPayload>
          }
          update: {
            args: Prisma.SymptomLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymptomLogPayload>
          }
          deleteMany: {
            args: Prisma.SymptomLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SymptomLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SymptomLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymptomLogPayload>[]
          }
          upsert: {
            args: Prisma.SymptomLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymptomLogPayload>
          }
          aggregate: {
            args: Prisma.SymptomLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSymptomLog>
          }
          groupBy: {
            args: Prisma.SymptomLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<SymptomLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.SymptomLogCountArgs<ExtArgs>
            result: $Utils.Optional<SymptomLogCountAggregateOutputType> | number
          }
        }
      }
      UserSettings: {
        payload: Prisma.$UserSettingsPayload<ExtArgs>
        fields: Prisma.UserSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          findFirst: {
            args: Prisma.UserSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          findMany: {
            args: Prisma.UserSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          create: {
            args: Prisma.UserSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          createMany: {
            args: Prisma.UserSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          delete: {
            args: Prisma.UserSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          update: {
            args: Prisma.UserSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          deleteMany: {
            args: Prisma.UserSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          upsert: {
            args: Prisma.UserSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          aggregate: {
            args: Prisma.UserSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSettings>
          }
          groupBy: {
            args: Prisma.UserSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<UserSettingsCountAggregateOutputType> | number
          }
        }
      }
      ReminderSettings: {
        payload: Prisma.$ReminderSettingsPayload<ExtArgs>
        fields: Prisma.ReminderSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReminderSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReminderSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderSettingsPayload>
          }
          findFirst: {
            args: Prisma.ReminderSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReminderSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderSettingsPayload>
          }
          findMany: {
            args: Prisma.ReminderSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderSettingsPayload>[]
          }
          create: {
            args: Prisma.ReminderSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderSettingsPayload>
          }
          createMany: {
            args: Prisma.ReminderSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReminderSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderSettingsPayload>[]
          }
          delete: {
            args: Prisma.ReminderSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderSettingsPayload>
          }
          update: {
            args: Prisma.ReminderSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderSettingsPayload>
          }
          deleteMany: {
            args: Prisma.ReminderSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReminderSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReminderSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderSettingsPayload>[]
          }
          upsert: {
            args: Prisma.ReminderSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderSettingsPayload>
          }
          aggregate: {
            args: Prisma.ReminderSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReminderSettings>
          }
          groupBy: {
            args: Prisma.ReminderSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReminderSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReminderSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<ReminderSettingsCountAggregateOutputType> | number
          }
        }
      }
      UserFeatureFlag: {
        payload: Prisma.$UserFeatureFlagPayload<ExtArgs>
        fields: Prisma.UserFeatureFlagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFeatureFlagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeatureFlagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFeatureFlagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeatureFlagPayload>
          }
          findFirst: {
            args: Prisma.UserFeatureFlagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeatureFlagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFeatureFlagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeatureFlagPayload>
          }
          findMany: {
            args: Prisma.UserFeatureFlagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeatureFlagPayload>[]
          }
          create: {
            args: Prisma.UserFeatureFlagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeatureFlagPayload>
          }
          createMany: {
            args: Prisma.UserFeatureFlagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserFeatureFlagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeatureFlagPayload>[]
          }
          delete: {
            args: Prisma.UserFeatureFlagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeatureFlagPayload>
          }
          update: {
            args: Prisma.UserFeatureFlagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeatureFlagPayload>
          }
          deleteMany: {
            args: Prisma.UserFeatureFlagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserFeatureFlagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserFeatureFlagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeatureFlagPayload>[]
          }
          upsert: {
            args: Prisma.UserFeatureFlagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFeatureFlagPayload>
          }
          aggregate: {
            args: Prisma.UserFeatureFlagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserFeatureFlag>
          }
          groupBy: {
            args: Prisma.UserFeatureFlagGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserFeatureFlagGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserFeatureFlagCountArgs<ExtArgs>
            result: $Utils.Optional<UserFeatureFlagCountAggregateOutputType> | number
          }
        }
      }
      UserObjective: {
        payload: Prisma.$UserObjectivePayload<ExtArgs>
        fields: Prisma.UserObjectiveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserObjectiveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserObjectivePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserObjectiveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserObjectivePayload>
          }
          findFirst: {
            args: Prisma.UserObjectiveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserObjectivePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserObjectiveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserObjectivePayload>
          }
          findMany: {
            args: Prisma.UserObjectiveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserObjectivePayload>[]
          }
          create: {
            args: Prisma.UserObjectiveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserObjectivePayload>
          }
          createMany: {
            args: Prisma.UserObjectiveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserObjectiveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserObjectivePayload>[]
          }
          delete: {
            args: Prisma.UserObjectiveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserObjectivePayload>
          }
          update: {
            args: Prisma.UserObjectiveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserObjectivePayload>
          }
          deleteMany: {
            args: Prisma.UserObjectiveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserObjectiveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserObjectiveUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserObjectivePayload>[]
          }
          upsert: {
            args: Prisma.UserObjectiveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserObjectivePayload>
          }
          aggregate: {
            args: Prisma.UserObjectiveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserObjective>
          }
          groupBy: {
            args: Prisma.UserObjectiveGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserObjectiveGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserObjectiveCountArgs<ExtArgs>
            result: $Utils.Optional<UserObjectiveCountAggregateOutputType> | number
          }
        }
      }
      ProfileChangeLog: {
        payload: Prisma.$ProfileChangeLogPayload<ExtArgs>
        fields: Prisma.ProfileChangeLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileChangeLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileChangeLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileChangeLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileChangeLogPayload>
          }
          findFirst: {
            args: Prisma.ProfileChangeLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileChangeLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileChangeLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileChangeLogPayload>
          }
          findMany: {
            args: Prisma.ProfileChangeLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileChangeLogPayload>[]
          }
          create: {
            args: Prisma.ProfileChangeLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileChangeLogPayload>
          }
          createMany: {
            args: Prisma.ProfileChangeLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileChangeLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileChangeLogPayload>[]
          }
          delete: {
            args: Prisma.ProfileChangeLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileChangeLogPayload>
          }
          update: {
            args: Prisma.ProfileChangeLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileChangeLogPayload>
          }
          deleteMany: {
            args: Prisma.ProfileChangeLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileChangeLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProfileChangeLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileChangeLogPayload>[]
          }
          upsert: {
            args: Prisma.ProfileChangeLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileChangeLogPayload>
          }
          aggregate: {
            args: Prisma.ProfileChangeLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfileChangeLog>
          }
          groupBy: {
            args: Prisma.ProfileChangeLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileChangeLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileChangeLogCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileChangeLogCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    cycle?: CycleOmit
    cycleProfileConfig?: CycleProfileConfigOmit
    cycleProvider?: CycleProviderOmit
    phase?: PhaseOmit
    exercise?: ExerciseOmit
    tag?: TagOmit
    exerciseTag?: ExerciseTagOmit
    phaseExercise?: PhaseExerciseOmit
    program?: ProgramOmit
    programExercise?: ProgramExerciseOmit
    notification?: NotificationOmit
    externalSync?: ExternalSyncOmit
    journalEntry?: JournalEntryOmit
    auditLog?: AuditLogOmit
    log?: LogOmit
    refreshToken?: RefreshTokenOmit
    authSession?: AuthSessionOmit
    moodTrack?: MoodTrackOmit
    symptomLog?: SymptomLogOmit
    userSettings?: UserSettingsOmit
    reminderSettings?: ReminderSettingsOmit
    userFeatureFlag?: UserFeatureFlagOmit
    userObjective?: UserObjectiveOmit
    profileChangeLog?: ProfileChangeLogOmit
    user?: UserOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CycleCountOutputType
   */

  export type CycleCountOutputType = {
    phases: number
  }

  export type CycleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    phases?: boolean | CycleCountOutputTypeCountPhasesArgs
  }

  // Custom InputTypes
  /**
   * CycleCountOutputType without action
   */
  export type CycleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CycleCountOutputType
     */
    select?: CycleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CycleCountOutputType without action
   */
  export type CycleCountOutputTypeCountPhasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhaseWhereInput
  }


  /**
   * Count Type CycleProviderCountOutputType
   */

  export type CycleProviderCountOutputType = {
    cycles: number
  }

  export type CycleProviderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cycles?: boolean | CycleProviderCountOutputTypeCountCyclesArgs
  }

  // Custom InputTypes
  /**
   * CycleProviderCountOutputType without action
   */
  export type CycleProviderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CycleProviderCountOutputType
     */
    select?: CycleProviderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CycleProviderCountOutputType without action
   */
  export type CycleProviderCountOutputTypeCountCyclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CycleWhereInput
  }


  /**
   * Count Type ExerciseCountOutputType
   */

  export type ExerciseCountOutputType = {
    exerciseTags: number
    phaseExercises: number
    programExercises: number
  }

  export type ExerciseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exerciseTags?: boolean | ExerciseCountOutputTypeCountExerciseTagsArgs
    phaseExercises?: boolean | ExerciseCountOutputTypeCountPhaseExercisesArgs
    programExercises?: boolean | ExerciseCountOutputTypeCountProgramExercisesArgs
  }

  // Custom InputTypes
  /**
   * ExerciseCountOutputType without action
   */
  export type ExerciseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseCountOutputType
     */
    select?: ExerciseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExerciseCountOutputType without action
   */
  export type ExerciseCountOutputTypeCountExerciseTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseTagWhereInput
  }

  /**
   * ExerciseCountOutputType without action
   */
  export type ExerciseCountOutputTypeCountPhaseExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhaseExerciseWhereInput
  }

  /**
   * ExerciseCountOutputType without action
   */
  export type ExerciseCountOutputTypeCountProgramExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramExerciseWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    exerciseTags: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exerciseTags?: boolean | TagCountOutputTypeCountExerciseTagsArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountExerciseTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseTagWhereInput
  }


  /**
   * Count Type ProgramCountOutputType
   */

  export type ProgramCountOutputType = {
    programExercises: number
    notifications: number
  }

  export type ProgramCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    programExercises?: boolean | ProgramCountOutputTypeCountProgramExercisesArgs
    notifications?: boolean | ProgramCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramCountOutputType
     */
    select?: ProgramCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeCountProgramExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramExerciseWhereInput
  }

  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    cycles: number
    programs: number
    moodTracks: number
    reminderSettings: number
    userFeatureFlags: number
    userObjectives: number
    profileChangeLogs: number
    symptomLogs: number
    notifications: number
    externalSyncs: number
    journalEntries: number
    auditLogs: number
    logs: number
    refreshTokens: number
    authSessions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cycles?: boolean | UserCountOutputTypeCountCyclesArgs
    programs?: boolean | UserCountOutputTypeCountProgramsArgs
    moodTracks?: boolean | UserCountOutputTypeCountMoodTracksArgs
    reminderSettings?: boolean | UserCountOutputTypeCountReminderSettingsArgs
    userFeatureFlags?: boolean | UserCountOutputTypeCountUserFeatureFlagsArgs
    userObjectives?: boolean | UserCountOutputTypeCountUserObjectivesArgs
    profileChangeLogs?: boolean | UserCountOutputTypeCountProfileChangeLogsArgs
    symptomLogs?: boolean | UserCountOutputTypeCountSymptomLogsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    externalSyncs?: boolean | UserCountOutputTypeCountExternalSyncsArgs
    journalEntries?: boolean | UserCountOutputTypeCountJournalEntriesArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    logs?: boolean | UserCountOutputTypeCountLogsArgs
    refreshTokens?: boolean | UserCountOutputTypeCountRefreshTokensArgs
    authSessions?: boolean | UserCountOutputTypeCountAuthSessionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCyclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CycleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProgramsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMoodTracksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MoodTrackWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReminderSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReminderSettingsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserFeatureFlagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFeatureFlagWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserObjectivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserObjectiveWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProfileChangeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileChangeLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSymptomLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SymptomLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExternalSyncsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExternalSyncWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountJournalEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalEntryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuthSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthSessionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Cycle
   */

  export type AggregateCycle = {
    _count: CycleCountAggregateOutputType | null
    _avg: CycleAvgAggregateOutputType | null
    _sum: CycleSumAggregateOutputType | null
    _min: CycleMinAggregateOutputType | null
    _max: CycleMaxAggregateOutputType | null
  }

  export type CycleAvgAggregateOutputType = {
    cycleLength: number | null
    periodLength: number | null
  }

  export type CycleSumAggregateOutputType = {
    cycleLength: number | null
    periodLength: number | null
  }

  export type CycleMinAggregateOutputType = {
    id: string | null
    userId: string | null
    startDate: Date | null
    cycleLength: number | null
    periodLength: number | null
    isRegular: boolean | null
    providerId: string | null
    externalCycleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CycleMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    startDate: Date | null
    cycleLength: number | null
    periodLength: number | null
    isRegular: boolean | null
    providerId: string | null
    externalCycleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CycleCountAggregateOutputType = {
    id: number
    userId: number
    startDate: number
    cycleLength: number
    periodLength: number
    isRegular: number
    providerId: number
    externalCycleId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CycleAvgAggregateInputType = {
    cycleLength?: true
    periodLength?: true
  }

  export type CycleSumAggregateInputType = {
    cycleLength?: true
    periodLength?: true
  }

  export type CycleMinAggregateInputType = {
    id?: true
    userId?: true
    startDate?: true
    cycleLength?: true
    periodLength?: true
    isRegular?: true
    providerId?: true
    externalCycleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CycleMaxAggregateInputType = {
    id?: true
    userId?: true
    startDate?: true
    cycleLength?: true
    periodLength?: true
    isRegular?: true
    providerId?: true
    externalCycleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CycleCountAggregateInputType = {
    id?: true
    userId?: true
    startDate?: true
    cycleLength?: true
    periodLength?: true
    isRegular?: true
    providerId?: true
    externalCycleId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CycleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cycle to aggregate.
     */
    where?: CycleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cycles to fetch.
     */
    orderBy?: CycleOrderByWithRelationInput | CycleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CycleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cycles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cycles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cycles
    **/
    _count?: true | CycleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CycleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CycleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CycleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CycleMaxAggregateInputType
  }

  export type GetCycleAggregateType<T extends CycleAggregateArgs> = {
        [P in keyof T & keyof AggregateCycle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCycle[P]>
      : GetScalarType<T[P], AggregateCycle[P]>
  }




  export type CycleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CycleWhereInput
    orderBy?: CycleOrderByWithAggregationInput | CycleOrderByWithAggregationInput[]
    by: CycleScalarFieldEnum[] | CycleScalarFieldEnum
    having?: CycleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CycleCountAggregateInputType | true
    _avg?: CycleAvgAggregateInputType
    _sum?: CycleSumAggregateInputType
    _min?: CycleMinAggregateInputType
    _max?: CycleMaxAggregateInputType
  }

  export type CycleGroupByOutputType = {
    id: string
    userId: string
    startDate: Date
    cycleLength: number | null
    periodLength: number | null
    isRegular: boolean
    providerId: string | null
    externalCycleId: string | null
    createdAt: Date
    updatedAt: Date
    _count: CycleCountAggregateOutputType | null
    _avg: CycleAvgAggregateOutputType | null
    _sum: CycleSumAggregateOutputType | null
    _min: CycleMinAggregateOutputType | null
    _max: CycleMaxAggregateOutputType | null
  }

  type GetCycleGroupByPayload<T extends CycleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CycleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CycleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CycleGroupByOutputType[P]>
            : GetScalarType<T[P], CycleGroupByOutputType[P]>
        }
      >
    >


  export type CycleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    startDate?: boolean
    cycleLength?: boolean
    periodLength?: boolean
    isRegular?: boolean
    providerId?: boolean
    externalCycleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    provider?: boolean | Cycle$providerArgs<ExtArgs>
    phases?: boolean | Cycle$phasesArgs<ExtArgs>
    _count?: boolean | CycleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cycle"]>

  export type CycleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    startDate?: boolean
    cycleLength?: boolean
    periodLength?: boolean
    isRegular?: boolean
    providerId?: boolean
    externalCycleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    provider?: boolean | Cycle$providerArgs<ExtArgs>
  }, ExtArgs["result"]["cycle"]>

  export type CycleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    startDate?: boolean
    cycleLength?: boolean
    periodLength?: boolean
    isRegular?: boolean
    providerId?: boolean
    externalCycleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    provider?: boolean | Cycle$providerArgs<ExtArgs>
  }, ExtArgs["result"]["cycle"]>

  export type CycleSelectScalar = {
    id?: boolean
    userId?: boolean
    startDate?: boolean
    cycleLength?: boolean
    periodLength?: boolean
    isRegular?: boolean
    providerId?: boolean
    externalCycleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CycleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "startDate" | "cycleLength" | "periodLength" | "isRegular" | "providerId" | "externalCycleId" | "createdAt" | "updatedAt", ExtArgs["result"]["cycle"]>
  export type CycleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    provider?: boolean | Cycle$providerArgs<ExtArgs>
    phases?: boolean | Cycle$phasesArgs<ExtArgs>
    _count?: boolean | CycleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CycleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    provider?: boolean | Cycle$providerArgs<ExtArgs>
  }
  export type CycleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    provider?: boolean | Cycle$providerArgs<ExtArgs>
  }

  export type $CyclePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cycle"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      provider: Prisma.$CycleProviderPayload<ExtArgs> | null
      phases: Prisma.$PhasePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      startDate: Date
      cycleLength: number | null
      periodLength: number | null
      isRegular: boolean
      providerId: string | null
      externalCycleId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cycle"]>
    composites: {}
  }

  type CycleGetPayload<S extends boolean | null | undefined | CycleDefaultArgs> = $Result.GetResult<Prisma.$CyclePayload, S>

  type CycleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CycleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CycleCountAggregateInputType | true
    }

  export interface CycleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cycle'], meta: { name: 'Cycle' } }
    /**
     * Find zero or one Cycle that matches the filter.
     * @param {CycleFindUniqueArgs} args - Arguments to find a Cycle
     * @example
     * // Get one Cycle
     * const cycle = await prisma.cycle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CycleFindUniqueArgs>(args: SelectSubset<T, CycleFindUniqueArgs<ExtArgs>>): Prisma__CycleClient<$Result.GetResult<Prisma.$CyclePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cycle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CycleFindUniqueOrThrowArgs} args - Arguments to find a Cycle
     * @example
     * // Get one Cycle
     * const cycle = await prisma.cycle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CycleFindUniqueOrThrowArgs>(args: SelectSubset<T, CycleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CycleClient<$Result.GetResult<Prisma.$CyclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cycle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CycleFindFirstArgs} args - Arguments to find a Cycle
     * @example
     * // Get one Cycle
     * const cycle = await prisma.cycle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CycleFindFirstArgs>(args?: SelectSubset<T, CycleFindFirstArgs<ExtArgs>>): Prisma__CycleClient<$Result.GetResult<Prisma.$CyclePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cycle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CycleFindFirstOrThrowArgs} args - Arguments to find a Cycle
     * @example
     * // Get one Cycle
     * const cycle = await prisma.cycle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CycleFindFirstOrThrowArgs>(args?: SelectSubset<T, CycleFindFirstOrThrowArgs<ExtArgs>>): Prisma__CycleClient<$Result.GetResult<Prisma.$CyclePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cycles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CycleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cycles
     * const cycles = await prisma.cycle.findMany()
     * 
     * // Get first 10 Cycles
     * const cycles = await prisma.cycle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cycleWithIdOnly = await prisma.cycle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CycleFindManyArgs>(args?: SelectSubset<T, CycleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CyclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cycle.
     * @param {CycleCreateArgs} args - Arguments to create a Cycle.
     * @example
     * // Create one Cycle
     * const Cycle = await prisma.cycle.create({
     *   data: {
     *     // ... data to create a Cycle
     *   }
     * })
     * 
     */
    create<T extends CycleCreateArgs>(args: SelectSubset<T, CycleCreateArgs<ExtArgs>>): Prisma__CycleClient<$Result.GetResult<Prisma.$CyclePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cycles.
     * @param {CycleCreateManyArgs} args - Arguments to create many Cycles.
     * @example
     * // Create many Cycles
     * const cycle = await prisma.cycle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CycleCreateManyArgs>(args?: SelectSubset<T, CycleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cycles and returns the data saved in the database.
     * @param {CycleCreateManyAndReturnArgs} args - Arguments to create many Cycles.
     * @example
     * // Create many Cycles
     * const cycle = await prisma.cycle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cycles and only return the `id`
     * const cycleWithIdOnly = await prisma.cycle.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CycleCreateManyAndReturnArgs>(args?: SelectSubset<T, CycleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CyclePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cycle.
     * @param {CycleDeleteArgs} args - Arguments to delete one Cycle.
     * @example
     * // Delete one Cycle
     * const Cycle = await prisma.cycle.delete({
     *   where: {
     *     // ... filter to delete one Cycle
     *   }
     * })
     * 
     */
    delete<T extends CycleDeleteArgs>(args: SelectSubset<T, CycleDeleteArgs<ExtArgs>>): Prisma__CycleClient<$Result.GetResult<Prisma.$CyclePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cycle.
     * @param {CycleUpdateArgs} args - Arguments to update one Cycle.
     * @example
     * // Update one Cycle
     * const cycle = await prisma.cycle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CycleUpdateArgs>(args: SelectSubset<T, CycleUpdateArgs<ExtArgs>>): Prisma__CycleClient<$Result.GetResult<Prisma.$CyclePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cycles.
     * @param {CycleDeleteManyArgs} args - Arguments to filter Cycles to delete.
     * @example
     * // Delete a few Cycles
     * const { count } = await prisma.cycle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CycleDeleteManyArgs>(args?: SelectSubset<T, CycleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cycles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CycleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cycles
     * const cycle = await prisma.cycle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CycleUpdateManyArgs>(args: SelectSubset<T, CycleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cycles and returns the data updated in the database.
     * @param {CycleUpdateManyAndReturnArgs} args - Arguments to update many Cycles.
     * @example
     * // Update many Cycles
     * const cycle = await prisma.cycle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cycles and only return the `id`
     * const cycleWithIdOnly = await prisma.cycle.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CycleUpdateManyAndReturnArgs>(args: SelectSubset<T, CycleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CyclePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cycle.
     * @param {CycleUpsertArgs} args - Arguments to update or create a Cycle.
     * @example
     * // Update or create a Cycle
     * const cycle = await prisma.cycle.upsert({
     *   create: {
     *     // ... data to create a Cycle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cycle we want to update
     *   }
     * })
     */
    upsert<T extends CycleUpsertArgs>(args: SelectSubset<T, CycleUpsertArgs<ExtArgs>>): Prisma__CycleClient<$Result.GetResult<Prisma.$CyclePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cycles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CycleCountArgs} args - Arguments to filter Cycles to count.
     * @example
     * // Count the number of Cycles
     * const count = await prisma.cycle.count({
     *   where: {
     *     // ... the filter for the Cycles we want to count
     *   }
     * })
    **/
    count<T extends CycleCountArgs>(
      args?: Subset<T, CycleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CycleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cycle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CycleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CycleAggregateArgs>(args: Subset<T, CycleAggregateArgs>): Prisma.PrismaPromise<GetCycleAggregateType<T>>

    /**
     * Group by Cycle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CycleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CycleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CycleGroupByArgs['orderBy'] }
        : { orderBy?: CycleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CycleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCycleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cycle model
   */
  readonly fields: CycleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cycle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CycleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    provider<T extends Cycle$providerArgs<ExtArgs> = {}>(args?: Subset<T, Cycle$providerArgs<ExtArgs>>): Prisma__CycleProviderClient<$Result.GetResult<Prisma.$CycleProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    phases<T extends Cycle$phasesArgs<ExtArgs> = {}>(args?: Subset<T, Cycle$phasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cycle model
   */
  interface CycleFieldRefs {
    readonly id: FieldRef<"Cycle", 'String'>
    readonly userId: FieldRef<"Cycle", 'String'>
    readonly startDate: FieldRef<"Cycle", 'DateTime'>
    readonly cycleLength: FieldRef<"Cycle", 'Int'>
    readonly periodLength: FieldRef<"Cycle", 'Int'>
    readonly isRegular: FieldRef<"Cycle", 'Boolean'>
    readonly providerId: FieldRef<"Cycle", 'String'>
    readonly externalCycleId: FieldRef<"Cycle", 'String'>
    readonly createdAt: FieldRef<"Cycle", 'DateTime'>
    readonly updatedAt: FieldRef<"Cycle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Cycle findUnique
   */
  export type CycleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cycle
     */
    select?: CycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cycle
     */
    omit?: CycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CycleInclude<ExtArgs> | null
    /**
     * Filter, which Cycle to fetch.
     */
    where: CycleWhereUniqueInput
  }

  /**
   * Cycle findUniqueOrThrow
   */
  export type CycleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cycle
     */
    select?: CycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cycle
     */
    omit?: CycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CycleInclude<ExtArgs> | null
    /**
     * Filter, which Cycle to fetch.
     */
    where: CycleWhereUniqueInput
  }

  /**
   * Cycle findFirst
   */
  export type CycleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cycle
     */
    select?: CycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cycle
     */
    omit?: CycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CycleInclude<ExtArgs> | null
    /**
     * Filter, which Cycle to fetch.
     */
    where?: CycleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cycles to fetch.
     */
    orderBy?: CycleOrderByWithRelationInput | CycleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cycles.
     */
    cursor?: CycleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cycles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cycles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cycles.
     */
    distinct?: CycleScalarFieldEnum | CycleScalarFieldEnum[]
  }

  /**
   * Cycle findFirstOrThrow
   */
  export type CycleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cycle
     */
    select?: CycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cycle
     */
    omit?: CycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CycleInclude<ExtArgs> | null
    /**
     * Filter, which Cycle to fetch.
     */
    where?: CycleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cycles to fetch.
     */
    orderBy?: CycleOrderByWithRelationInput | CycleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cycles.
     */
    cursor?: CycleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cycles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cycles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cycles.
     */
    distinct?: CycleScalarFieldEnum | CycleScalarFieldEnum[]
  }

  /**
   * Cycle findMany
   */
  export type CycleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cycle
     */
    select?: CycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cycle
     */
    omit?: CycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CycleInclude<ExtArgs> | null
    /**
     * Filter, which Cycles to fetch.
     */
    where?: CycleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cycles to fetch.
     */
    orderBy?: CycleOrderByWithRelationInput | CycleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cycles.
     */
    cursor?: CycleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cycles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cycles.
     */
    skip?: number
    distinct?: CycleScalarFieldEnum | CycleScalarFieldEnum[]
  }

  /**
   * Cycle create
   */
  export type CycleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cycle
     */
    select?: CycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cycle
     */
    omit?: CycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CycleInclude<ExtArgs> | null
    /**
     * The data needed to create a Cycle.
     */
    data: XOR<CycleCreateInput, CycleUncheckedCreateInput>
  }

  /**
   * Cycle createMany
   */
  export type CycleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cycles.
     */
    data: CycleCreateManyInput | CycleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cycle createManyAndReturn
   */
  export type CycleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cycle
     */
    select?: CycleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cycle
     */
    omit?: CycleOmit<ExtArgs> | null
    /**
     * The data used to create many Cycles.
     */
    data: CycleCreateManyInput | CycleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CycleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cycle update
   */
  export type CycleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cycle
     */
    select?: CycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cycle
     */
    omit?: CycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CycleInclude<ExtArgs> | null
    /**
     * The data needed to update a Cycle.
     */
    data: XOR<CycleUpdateInput, CycleUncheckedUpdateInput>
    /**
     * Choose, which Cycle to update.
     */
    where: CycleWhereUniqueInput
  }

  /**
   * Cycle updateMany
   */
  export type CycleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cycles.
     */
    data: XOR<CycleUpdateManyMutationInput, CycleUncheckedUpdateManyInput>
    /**
     * Filter which Cycles to update
     */
    where?: CycleWhereInput
    /**
     * Limit how many Cycles to update.
     */
    limit?: number
  }

  /**
   * Cycle updateManyAndReturn
   */
  export type CycleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cycle
     */
    select?: CycleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cycle
     */
    omit?: CycleOmit<ExtArgs> | null
    /**
     * The data used to update Cycles.
     */
    data: XOR<CycleUpdateManyMutationInput, CycleUncheckedUpdateManyInput>
    /**
     * Filter which Cycles to update
     */
    where?: CycleWhereInput
    /**
     * Limit how many Cycles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CycleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cycle upsert
   */
  export type CycleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cycle
     */
    select?: CycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cycle
     */
    omit?: CycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CycleInclude<ExtArgs> | null
    /**
     * The filter to search for the Cycle to update in case it exists.
     */
    where: CycleWhereUniqueInput
    /**
     * In case the Cycle found by the `where` argument doesn't exist, create a new Cycle with this data.
     */
    create: XOR<CycleCreateInput, CycleUncheckedCreateInput>
    /**
     * In case the Cycle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CycleUpdateInput, CycleUncheckedUpdateInput>
  }

  /**
   * Cycle delete
   */
  export type CycleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cycle
     */
    select?: CycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cycle
     */
    omit?: CycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CycleInclude<ExtArgs> | null
    /**
     * Filter which Cycle to delete.
     */
    where: CycleWhereUniqueInput
  }

  /**
   * Cycle deleteMany
   */
  export type CycleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cycles to delete
     */
    where?: CycleWhereInput
    /**
     * Limit how many Cycles to delete.
     */
    limit?: number
  }

  /**
   * Cycle.provider
   */
  export type Cycle$providerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CycleProvider
     */
    select?: CycleProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CycleProvider
     */
    omit?: CycleProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CycleProviderInclude<ExtArgs> | null
    where?: CycleProviderWhereInput
  }

  /**
   * Cycle.phases
   */
  export type Cycle$phasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phase
     */
    select?: PhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phase
     */
    omit?: PhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseInclude<ExtArgs> | null
    where?: PhaseWhereInput
    orderBy?: PhaseOrderByWithRelationInput | PhaseOrderByWithRelationInput[]
    cursor?: PhaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PhaseScalarFieldEnum | PhaseScalarFieldEnum[]
  }

  /**
   * Cycle without action
   */
  export type CycleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cycle
     */
    select?: CycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cycle
     */
    omit?: CycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CycleInclude<ExtArgs> | null
  }


  /**
   * Model CycleProfileConfig
   */

  export type AggregateCycleProfileConfig = {
    _count: CycleProfileConfigCountAggregateOutputType | null
    _avg: CycleProfileConfigAvgAggregateOutputType | null
    _sum: CycleProfileConfigSumAggregateOutputType | null
    _min: CycleProfileConfigMinAggregateOutputType | null
    _max: CycleProfileConfigMaxAggregateOutputType | null
  }

  export type CycleProfileConfigAvgAggregateOutputType = {
    averageCycleLength: number | null
    averagePeriodLength: number | null
  }

  export type CycleProfileConfigSumAggregateOutputType = {
    averageCycleLength: number | null
    averagePeriodLength: number | null
  }

  export type CycleProfileConfigMinAggregateOutputType = {
    id: string | null
    userId: string | null
    isCycleTrackingEnabled: boolean | null
    usesExternalProvider: boolean | null
    useMenopauseMode: boolean | null
    averageCycleLength: number | null
    averagePeriodLength: number | null
    prefersManualInput: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CycleProfileConfigMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    isCycleTrackingEnabled: boolean | null
    usesExternalProvider: boolean | null
    useMenopauseMode: boolean | null
    averageCycleLength: number | null
    averagePeriodLength: number | null
    prefersManualInput: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CycleProfileConfigCountAggregateOutputType = {
    id: number
    userId: number
    isCycleTrackingEnabled: number
    usesExternalProvider: number
    useMenopauseMode: number
    averageCycleLength: number
    averagePeriodLength: number
    prefersManualInput: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CycleProfileConfigAvgAggregateInputType = {
    averageCycleLength?: true
    averagePeriodLength?: true
  }

  export type CycleProfileConfigSumAggregateInputType = {
    averageCycleLength?: true
    averagePeriodLength?: true
  }

  export type CycleProfileConfigMinAggregateInputType = {
    id?: true
    userId?: true
    isCycleTrackingEnabled?: true
    usesExternalProvider?: true
    useMenopauseMode?: true
    averageCycleLength?: true
    averagePeriodLength?: true
    prefersManualInput?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CycleProfileConfigMaxAggregateInputType = {
    id?: true
    userId?: true
    isCycleTrackingEnabled?: true
    usesExternalProvider?: true
    useMenopauseMode?: true
    averageCycleLength?: true
    averagePeriodLength?: true
    prefersManualInput?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CycleProfileConfigCountAggregateInputType = {
    id?: true
    userId?: true
    isCycleTrackingEnabled?: true
    usesExternalProvider?: true
    useMenopauseMode?: true
    averageCycleLength?: true
    averagePeriodLength?: true
    prefersManualInput?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CycleProfileConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CycleProfileConfig to aggregate.
     */
    where?: CycleProfileConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CycleProfileConfigs to fetch.
     */
    orderBy?: CycleProfileConfigOrderByWithRelationInput | CycleProfileConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CycleProfileConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CycleProfileConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CycleProfileConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CycleProfileConfigs
    **/
    _count?: true | CycleProfileConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CycleProfileConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CycleProfileConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CycleProfileConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CycleProfileConfigMaxAggregateInputType
  }

  export type GetCycleProfileConfigAggregateType<T extends CycleProfileConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateCycleProfileConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCycleProfileConfig[P]>
      : GetScalarType<T[P], AggregateCycleProfileConfig[P]>
  }




  export type CycleProfileConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CycleProfileConfigWhereInput
    orderBy?: CycleProfileConfigOrderByWithAggregationInput | CycleProfileConfigOrderByWithAggregationInput[]
    by: CycleProfileConfigScalarFieldEnum[] | CycleProfileConfigScalarFieldEnum
    having?: CycleProfileConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CycleProfileConfigCountAggregateInputType | true
    _avg?: CycleProfileConfigAvgAggregateInputType
    _sum?: CycleProfileConfigSumAggregateInputType
    _min?: CycleProfileConfigMinAggregateInputType
    _max?: CycleProfileConfigMaxAggregateInputType
  }

  export type CycleProfileConfigGroupByOutputType = {
    id: string
    userId: string
    isCycleTrackingEnabled: boolean
    usesExternalProvider: boolean
    useMenopauseMode: boolean
    averageCycleLength: number | null
    averagePeriodLength: number | null
    prefersManualInput: boolean
    createdAt: Date
    updatedAt: Date
    _count: CycleProfileConfigCountAggregateOutputType | null
    _avg: CycleProfileConfigAvgAggregateOutputType | null
    _sum: CycleProfileConfigSumAggregateOutputType | null
    _min: CycleProfileConfigMinAggregateOutputType | null
    _max: CycleProfileConfigMaxAggregateOutputType | null
  }

  type GetCycleProfileConfigGroupByPayload<T extends CycleProfileConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CycleProfileConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CycleProfileConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CycleProfileConfigGroupByOutputType[P]>
            : GetScalarType<T[P], CycleProfileConfigGroupByOutputType[P]>
        }
      >
    >


  export type CycleProfileConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    isCycleTrackingEnabled?: boolean
    usesExternalProvider?: boolean
    useMenopauseMode?: boolean
    averageCycleLength?: boolean
    averagePeriodLength?: boolean
    prefersManualInput?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cycleProfileConfig"]>

  export type CycleProfileConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    isCycleTrackingEnabled?: boolean
    usesExternalProvider?: boolean
    useMenopauseMode?: boolean
    averageCycleLength?: boolean
    averagePeriodLength?: boolean
    prefersManualInput?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cycleProfileConfig"]>

  export type CycleProfileConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    isCycleTrackingEnabled?: boolean
    usesExternalProvider?: boolean
    useMenopauseMode?: boolean
    averageCycleLength?: boolean
    averagePeriodLength?: boolean
    prefersManualInput?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cycleProfileConfig"]>

  export type CycleProfileConfigSelectScalar = {
    id?: boolean
    userId?: boolean
    isCycleTrackingEnabled?: boolean
    usesExternalProvider?: boolean
    useMenopauseMode?: boolean
    averageCycleLength?: boolean
    averagePeriodLength?: boolean
    prefersManualInput?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CycleProfileConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "isCycleTrackingEnabled" | "usesExternalProvider" | "useMenopauseMode" | "averageCycleLength" | "averagePeriodLength" | "prefersManualInput" | "createdAt" | "updatedAt", ExtArgs["result"]["cycleProfileConfig"]>
  export type CycleProfileConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CycleProfileConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CycleProfileConfigIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CycleProfileConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CycleProfileConfig"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      isCycleTrackingEnabled: boolean
      usesExternalProvider: boolean
      useMenopauseMode: boolean
      averageCycleLength: number | null
      averagePeriodLength: number | null
      prefersManualInput: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cycleProfileConfig"]>
    composites: {}
  }

  type CycleProfileConfigGetPayload<S extends boolean | null | undefined | CycleProfileConfigDefaultArgs> = $Result.GetResult<Prisma.$CycleProfileConfigPayload, S>

  type CycleProfileConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CycleProfileConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CycleProfileConfigCountAggregateInputType | true
    }

  export interface CycleProfileConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CycleProfileConfig'], meta: { name: 'CycleProfileConfig' } }
    /**
     * Find zero or one CycleProfileConfig that matches the filter.
     * @param {CycleProfileConfigFindUniqueArgs} args - Arguments to find a CycleProfileConfig
     * @example
     * // Get one CycleProfileConfig
     * const cycleProfileConfig = await prisma.cycleProfileConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CycleProfileConfigFindUniqueArgs>(args: SelectSubset<T, CycleProfileConfigFindUniqueArgs<ExtArgs>>): Prisma__CycleProfileConfigClient<$Result.GetResult<Prisma.$CycleProfileConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CycleProfileConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CycleProfileConfigFindUniqueOrThrowArgs} args - Arguments to find a CycleProfileConfig
     * @example
     * // Get one CycleProfileConfig
     * const cycleProfileConfig = await prisma.cycleProfileConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CycleProfileConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, CycleProfileConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CycleProfileConfigClient<$Result.GetResult<Prisma.$CycleProfileConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CycleProfileConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CycleProfileConfigFindFirstArgs} args - Arguments to find a CycleProfileConfig
     * @example
     * // Get one CycleProfileConfig
     * const cycleProfileConfig = await prisma.cycleProfileConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CycleProfileConfigFindFirstArgs>(args?: SelectSubset<T, CycleProfileConfigFindFirstArgs<ExtArgs>>): Prisma__CycleProfileConfigClient<$Result.GetResult<Prisma.$CycleProfileConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CycleProfileConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CycleProfileConfigFindFirstOrThrowArgs} args - Arguments to find a CycleProfileConfig
     * @example
     * // Get one CycleProfileConfig
     * const cycleProfileConfig = await prisma.cycleProfileConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CycleProfileConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, CycleProfileConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__CycleProfileConfigClient<$Result.GetResult<Prisma.$CycleProfileConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CycleProfileConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CycleProfileConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CycleProfileConfigs
     * const cycleProfileConfigs = await prisma.cycleProfileConfig.findMany()
     * 
     * // Get first 10 CycleProfileConfigs
     * const cycleProfileConfigs = await prisma.cycleProfileConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cycleProfileConfigWithIdOnly = await prisma.cycleProfileConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CycleProfileConfigFindManyArgs>(args?: SelectSubset<T, CycleProfileConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CycleProfileConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CycleProfileConfig.
     * @param {CycleProfileConfigCreateArgs} args - Arguments to create a CycleProfileConfig.
     * @example
     * // Create one CycleProfileConfig
     * const CycleProfileConfig = await prisma.cycleProfileConfig.create({
     *   data: {
     *     // ... data to create a CycleProfileConfig
     *   }
     * })
     * 
     */
    create<T extends CycleProfileConfigCreateArgs>(args: SelectSubset<T, CycleProfileConfigCreateArgs<ExtArgs>>): Prisma__CycleProfileConfigClient<$Result.GetResult<Prisma.$CycleProfileConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CycleProfileConfigs.
     * @param {CycleProfileConfigCreateManyArgs} args - Arguments to create many CycleProfileConfigs.
     * @example
     * // Create many CycleProfileConfigs
     * const cycleProfileConfig = await prisma.cycleProfileConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CycleProfileConfigCreateManyArgs>(args?: SelectSubset<T, CycleProfileConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CycleProfileConfigs and returns the data saved in the database.
     * @param {CycleProfileConfigCreateManyAndReturnArgs} args - Arguments to create many CycleProfileConfigs.
     * @example
     * // Create many CycleProfileConfigs
     * const cycleProfileConfig = await prisma.cycleProfileConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CycleProfileConfigs and only return the `id`
     * const cycleProfileConfigWithIdOnly = await prisma.cycleProfileConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CycleProfileConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, CycleProfileConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CycleProfileConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CycleProfileConfig.
     * @param {CycleProfileConfigDeleteArgs} args - Arguments to delete one CycleProfileConfig.
     * @example
     * // Delete one CycleProfileConfig
     * const CycleProfileConfig = await prisma.cycleProfileConfig.delete({
     *   where: {
     *     // ... filter to delete one CycleProfileConfig
     *   }
     * })
     * 
     */
    delete<T extends CycleProfileConfigDeleteArgs>(args: SelectSubset<T, CycleProfileConfigDeleteArgs<ExtArgs>>): Prisma__CycleProfileConfigClient<$Result.GetResult<Prisma.$CycleProfileConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CycleProfileConfig.
     * @param {CycleProfileConfigUpdateArgs} args - Arguments to update one CycleProfileConfig.
     * @example
     * // Update one CycleProfileConfig
     * const cycleProfileConfig = await prisma.cycleProfileConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CycleProfileConfigUpdateArgs>(args: SelectSubset<T, CycleProfileConfigUpdateArgs<ExtArgs>>): Prisma__CycleProfileConfigClient<$Result.GetResult<Prisma.$CycleProfileConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CycleProfileConfigs.
     * @param {CycleProfileConfigDeleteManyArgs} args - Arguments to filter CycleProfileConfigs to delete.
     * @example
     * // Delete a few CycleProfileConfigs
     * const { count } = await prisma.cycleProfileConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CycleProfileConfigDeleteManyArgs>(args?: SelectSubset<T, CycleProfileConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CycleProfileConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CycleProfileConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CycleProfileConfigs
     * const cycleProfileConfig = await prisma.cycleProfileConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CycleProfileConfigUpdateManyArgs>(args: SelectSubset<T, CycleProfileConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CycleProfileConfigs and returns the data updated in the database.
     * @param {CycleProfileConfigUpdateManyAndReturnArgs} args - Arguments to update many CycleProfileConfigs.
     * @example
     * // Update many CycleProfileConfigs
     * const cycleProfileConfig = await prisma.cycleProfileConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CycleProfileConfigs and only return the `id`
     * const cycleProfileConfigWithIdOnly = await prisma.cycleProfileConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CycleProfileConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, CycleProfileConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CycleProfileConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CycleProfileConfig.
     * @param {CycleProfileConfigUpsertArgs} args - Arguments to update or create a CycleProfileConfig.
     * @example
     * // Update or create a CycleProfileConfig
     * const cycleProfileConfig = await prisma.cycleProfileConfig.upsert({
     *   create: {
     *     // ... data to create a CycleProfileConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CycleProfileConfig we want to update
     *   }
     * })
     */
    upsert<T extends CycleProfileConfigUpsertArgs>(args: SelectSubset<T, CycleProfileConfigUpsertArgs<ExtArgs>>): Prisma__CycleProfileConfigClient<$Result.GetResult<Prisma.$CycleProfileConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CycleProfileConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CycleProfileConfigCountArgs} args - Arguments to filter CycleProfileConfigs to count.
     * @example
     * // Count the number of CycleProfileConfigs
     * const count = await prisma.cycleProfileConfig.count({
     *   where: {
     *     // ... the filter for the CycleProfileConfigs we want to count
     *   }
     * })
    **/
    count<T extends CycleProfileConfigCountArgs>(
      args?: Subset<T, CycleProfileConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CycleProfileConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CycleProfileConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CycleProfileConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CycleProfileConfigAggregateArgs>(args: Subset<T, CycleProfileConfigAggregateArgs>): Prisma.PrismaPromise<GetCycleProfileConfigAggregateType<T>>

    /**
     * Group by CycleProfileConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CycleProfileConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CycleProfileConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CycleProfileConfigGroupByArgs['orderBy'] }
        : { orderBy?: CycleProfileConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CycleProfileConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCycleProfileConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CycleProfileConfig model
   */
  readonly fields: CycleProfileConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CycleProfileConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CycleProfileConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CycleProfileConfig model
   */
  interface CycleProfileConfigFieldRefs {
    readonly id: FieldRef<"CycleProfileConfig", 'String'>
    readonly userId: FieldRef<"CycleProfileConfig", 'String'>
    readonly isCycleTrackingEnabled: FieldRef<"CycleProfileConfig", 'Boolean'>
    readonly usesExternalProvider: FieldRef<"CycleProfileConfig", 'Boolean'>
    readonly useMenopauseMode: FieldRef<"CycleProfileConfig", 'Boolean'>
    readonly averageCycleLength: FieldRef<"CycleProfileConfig", 'Int'>
    readonly averagePeriodLength: FieldRef<"CycleProfileConfig", 'Int'>
    readonly prefersManualInput: FieldRef<"CycleProfileConfig", 'Boolean'>
    readonly createdAt: FieldRef<"CycleProfileConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"CycleProfileConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CycleProfileConfig findUnique
   */
  export type CycleProfileConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CycleProfileConfig
     */
    select?: CycleProfileConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CycleProfileConfig
     */
    omit?: CycleProfileConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CycleProfileConfigInclude<ExtArgs> | null
    /**
     * Filter, which CycleProfileConfig to fetch.
     */
    where: CycleProfileConfigWhereUniqueInput
  }

  /**
   * CycleProfileConfig findUniqueOrThrow
   */
  export type CycleProfileConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CycleProfileConfig
     */
    select?: CycleProfileConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CycleProfileConfig
     */
    omit?: CycleProfileConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CycleProfileConfigInclude<ExtArgs> | null
    /**
     * Filter, which CycleProfileConfig to fetch.
     */
    where: CycleProfileConfigWhereUniqueInput
  }

  /**
   * CycleProfileConfig findFirst
   */
  export type CycleProfileConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CycleProfileConfig
     */
    select?: CycleProfileConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CycleProfileConfig
     */
    omit?: CycleProfileConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CycleProfileConfigInclude<ExtArgs> | null
    /**
     * Filter, which CycleProfileConfig to fetch.
     */
    where?: CycleProfileConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CycleProfileConfigs to fetch.
     */
    orderBy?: CycleProfileConfigOrderByWithRelationInput | CycleProfileConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CycleProfileConfigs.
     */
    cursor?: CycleProfileConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CycleProfileConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CycleProfileConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CycleProfileConfigs.
     */
    distinct?: CycleProfileConfigScalarFieldEnum | CycleProfileConfigScalarFieldEnum[]
  }

  /**
   * CycleProfileConfig findFirstOrThrow
   */
  export type CycleProfileConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CycleProfileConfig
     */
    select?: CycleProfileConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CycleProfileConfig
     */
    omit?: CycleProfileConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CycleProfileConfigInclude<ExtArgs> | null
    /**
     * Filter, which CycleProfileConfig to fetch.
     */
    where?: CycleProfileConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CycleProfileConfigs to fetch.
     */
    orderBy?: CycleProfileConfigOrderByWithRelationInput | CycleProfileConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CycleProfileConfigs.
     */
    cursor?: CycleProfileConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CycleProfileConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CycleProfileConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CycleProfileConfigs.
     */
    distinct?: CycleProfileConfigScalarFieldEnum | CycleProfileConfigScalarFieldEnum[]
  }

  /**
   * CycleProfileConfig findMany
   */
  export type CycleProfileConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CycleProfileConfig
     */
    select?: CycleProfileConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CycleProfileConfig
     */
    omit?: CycleProfileConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CycleProfileConfigInclude<ExtArgs> | null
    /**
     * Filter, which CycleProfileConfigs to fetch.
     */
    where?: CycleProfileConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CycleProfileConfigs to fetch.
     */
    orderBy?: CycleProfileConfigOrderByWithRelationInput | CycleProfileConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CycleProfileConfigs.
     */
    cursor?: CycleProfileConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CycleProfileConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CycleProfileConfigs.
     */
    skip?: number
    distinct?: CycleProfileConfigScalarFieldEnum | CycleProfileConfigScalarFieldEnum[]
  }

  /**
   * CycleProfileConfig create
   */
  export type CycleProfileConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CycleProfileConfig
     */
    select?: CycleProfileConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CycleProfileConfig
     */
    omit?: CycleProfileConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CycleProfileConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a CycleProfileConfig.
     */
    data: XOR<CycleProfileConfigCreateInput, CycleProfileConfigUncheckedCreateInput>
  }

  /**
   * CycleProfileConfig createMany
   */
  export type CycleProfileConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CycleProfileConfigs.
     */
    data: CycleProfileConfigCreateManyInput | CycleProfileConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CycleProfileConfig createManyAndReturn
   */
  export type CycleProfileConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CycleProfileConfig
     */
    select?: CycleProfileConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CycleProfileConfig
     */
    omit?: CycleProfileConfigOmit<ExtArgs> | null
    /**
     * The data used to create many CycleProfileConfigs.
     */
    data: CycleProfileConfigCreateManyInput | CycleProfileConfigCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CycleProfileConfigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CycleProfileConfig update
   */
  export type CycleProfileConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CycleProfileConfig
     */
    select?: CycleProfileConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CycleProfileConfig
     */
    omit?: CycleProfileConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CycleProfileConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a CycleProfileConfig.
     */
    data: XOR<CycleProfileConfigUpdateInput, CycleProfileConfigUncheckedUpdateInput>
    /**
     * Choose, which CycleProfileConfig to update.
     */
    where: CycleProfileConfigWhereUniqueInput
  }

  /**
   * CycleProfileConfig updateMany
   */
  export type CycleProfileConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CycleProfileConfigs.
     */
    data: XOR<CycleProfileConfigUpdateManyMutationInput, CycleProfileConfigUncheckedUpdateManyInput>
    /**
     * Filter which CycleProfileConfigs to update
     */
    where?: CycleProfileConfigWhereInput
    /**
     * Limit how many CycleProfileConfigs to update.
     */
    limit?: number
  }

  /**
   * CycleProfileConfig updateManyAndReturn
   */
  export type CycleProfileConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CycleProfileConfig
     */
    select?: CycleProfileConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CycleProfileConfig
     */
    omit?: CycleProfileConfigOmit<ExtArgs> | null
    /**
     * The data used to update CycleProfileConfigs.
     */
    data: XOR<CycleProfileConfigUpdateManyMutationInput, CycleProfileConfigUncheckedUpdateManyInput>
    /**
     * Filter which CycleProfileConfigs to update
     */
    where?: CycleProfileConfigWhereInput
    /**
     * Limit how many CycleProfileConfigs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CycleProfileConfigIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CycleProfileConfig upsert
   */
  export type CycleProfileConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CycleProfileConfig
     */
    select?: CycleProfileConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CycleProfileConfig
     */
    omit?: CycleProfileConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CycleProfileConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the CycleProfileConfig to update in case it exists.
     */
    where: CycleProfileConfigWhereUniqueInput
    /**
     * In case the CycleProfileConfig found by the `where` argument doesn't exist, create a new CycleProfileConfig with this data.
     */
    create: XOR<CycleProfileConfigCreateInput, CycleProfileConfigUncheckedCreateInput>
    /**
     * In case the CycleProfileConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CycleProfileConfigUpdateInput, CycleProfileConfigUncheckedUpdateInput>
  }

  /**
   * CycleProfileConfig delete
   */
  export type CycleProfileConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CycleProfileConfig
     */
    select?: CycleProfileConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CycleProfileConfig
     */
    omit?: CycleProfileConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CycleProfileConfigInclude<ExtArgs> | null
    /**
     * Filter which CycleProfileConfig to delete.
     */
    where: CycleProfileConfigWhereUniqueInput
  }

  /**
   * CycleProfileConfig deleteMany
   */
  export type CycleProfileConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CycleProfileConfigs to delete
     */
    where?: CycleProfileConfigWhereInput
    /**
     * Limit how many CycleProfileConfigs to delete.
     */
    limit?: number
  }

  /**
   * CycleProfileConfig without action
   */
  export type CycleProfileConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CycleProfileConfig
     */
    select?: CycleProfileConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CycleProfileConfig
     */
    omit?: CycleProfileConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CycleProfileConfigInclude<ExtArgs> | null
  }


  /**
   * Model CycleProvider
   */

  export type AggregateCycleProvider = {
    _count: CycleProviderCountAggregateOutputType | null
    _min: CycleProviderMinAggregateOutputType | null
    _max: CycleProviderMaxAggregateOutputType | null
  }

  export type CycleProviderMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CycleProviderMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CycleProviderCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CycleProviderMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CycleProviderMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CycleProviderCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CycleProviderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CycleProvider to aggregate.
     */
    where?: CycleProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CycleProviders to fetch.
     */
    orderBy?: CycleProviderOrderByWithRelationInput | CycleProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CycleProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CycleProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CycleProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CycleProviders
    **/
    _count?: true | CycleProviderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CycleProviderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CycleProviderMaxAggregateInputType
  }

  export type GetCycleProviderAggregateType<T extends CycleProviderAggregateArgs> = {
        [P in keyof T & keyof AggregateCycleProvider]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCycleProvider[P]>
      : GetScalarType<T[P], AggregateCycleProvider[P]>
  }




  export type CycleProviderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CycleProviderWhereInput
    orderBy?: CycleProviderOrderByWithAggregationInput | CycleProviderOrderByWithAggregationInput[]
    by: CycleProviderScalarFieldEnum[] | CycleProviderScalarFieldEnum
    having?: CycleProviderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CycleProviderCountAggregateInputType | true
    _min?: CycleProviderMinAggregateInputType
    _max?: CycleProviderMaxAggregateInputType
  }

  export type CycleProviderGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: CycleProviderCountAggregateOutputType | null
    _min: CycleProviderMinAggregateOutputType | null
    _max: CycleProviderMaxAggregateOutputType | null
  }

  type GetCycleProviderGroupByPayload<T extends CycleProviderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CycleProviderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CycleProviderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CycleProviderGroupByOutputType[P]>
            : GetScalarType<T[P], CycleProviderGroupByOutputType[P]>
        }
      >
    >


  export type CycleProviderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cycles?: boolean | CycleProvider$cyclesArgs<ExtArgs>
    _count?: boolean | CycleProviderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cycleProvider"]>

  export type CycleProviderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cycleProvider"]>

  export type CycleProviderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cycleProvider"]>

  export type CycleProviderSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CycleProviderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["cycleProvider"]>
  export type CycleProviderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cycles?: boolean | CycleProvider$cyclesArgs<ExtArgs>
    _count?: boolean | CycleProviderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CycleProviderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CycleProviderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CycleProviderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CycleProvider"
    objects: {
      cycles: Prisma.$CyclePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cycleProvider"]>
    composites: {}
  }

  type CycleProviderGetPayload<S extends boolean | null | undefined | CycleProviderDefaultArgs> = $Result.GetResult<Prisma.$CycleProviderPayload, S>

  type CycleProviderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CycleProviderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CycleProviderCountAggregateInputType | true
    }

  export interface CycleProviderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CycleProvider'], meta: { name: 'CycleProvider' } }
    /**
     * Find zero or one CycleProvider that matches the filter.
     * @param {CycleProviderFindUniqueArgs} args - Arguments to find a CycleProvider
     * @example
     * // Get one CycleProvider
     * const cycleProvider = await prisma.cycleProvider.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CycleProviderFindUniqueArgs>(args: SelectSubset<T, CycleProviderFindUniqueArgs<ExtArgs>>): Prisma__CycleProviderClient<$Result.GetResult<Prisma.$CycleProviderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CycleProvider that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CycleProviderFindUniqueOrThrowArgs} args - Arguments to find a CycleProvider
     * @example
     * // Get one CycleProvider
     * const cycleProvider = await prisma.cycleProvider.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CycleProviderFindUniqueOrThrowArgs>(args: SelectSubset<T, CycleProviderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CycleProviderClient<$Result.GetResult<Prisma.$CycleProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CycleProvider that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CycleProviderFindFirstArgs} args - Arguments to find a CycleProvider
     * @example
     * // Get one CycleProvider
     * const cycleProvider = await prisma.cycleProvider.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CycleProviderFindFirstArgs>(args?: SelectSubset<T, CycleProviderFindFirstArgs<ExtArgs>>): Prisma__CycleProviderClient<$Result.GetResult<Prisma.$CycleProviderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CycleProvider that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CycleProviderFindFirstOrThrowArgs} args - Arguments to find a CycleProvider
     * @example
     * // Get one CycleProvider
     * const cycleProvider = await prisma.cycleProvider.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CycleProviderFindFirstOrThrowArgs>(args?: SelectSubset<T, CycleProviderFindFirstOrThrowArgs<ExtArgs>>): Prisma__CycleProviderClient<$Result.GetResult<Prisma.$CycleProviderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CycleProviders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CycleProviderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CycleProviders
     * const cycleProviders = await prisma.cycleProvider.findMany()
     * 
     * // Get first 10 CycleProviders
     * const cycleProviders = await prisma.cycleProvider.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cycleProviderWithIdOnly = await prisma.cycleProvider.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CycleProviderFindManyArgs>(args?: SelectSubset<T, CycleProviderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CycleProviderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CycleProvider.
     * @param {CycleProviderCreateArgs} args - Arguments to create a CycleProvider.
     * @example
     * // Create one CycleProvider
     * const CycleProvider = await prisma.cycleProvider.create({
     *   data: {
     *     // ... data to create a CycleProvider
     *   }
     * })
     * 
     */
    create<T extends CycleProviderCreateArgs>(args: SelectSubset<T, CycleProviderCreateArgs<ExtArgs>>): Prisma__CycleProviderClient<$Result.GetResult<Prisma.$CycleProviderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CycleProviders.
     * @param {CycleProviderCreateManyArgs} args - Arguments to create many CycleProviders.
     * @example
     * // Create many CycleProviders
     * const cycleProvider = await prisma.cycleProvider.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CycleProviderCreateManyArgs>(args?: SelectSubset<T, CycleProviderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CycleProviders and returns the data saved in the database.
     * @param {CycleProviderCreateManyAndReturnArgs} args - Arguments to create many CycleProviders.
     * @example
     * // Create many CycleProviders
     * const cycleProvider = await prisma.cycleProvider.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CycleProviders and only return the `id`
     * const cycleProviderWithIdOnly = await prisma.cycleProvider.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CycleProviderCreateManyAndReturnArgs>(args?: SelectSubset<T, CycleProviderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CycleProviderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CycleProvider.
     * @param {CycleProviderDeleteArgs} args - Arguments to delete one CycleProvider.
     * @example
     * // Delete one CycleProvider
     * const CycleProvider = await prisma.cycleProvider.delete({
     *   where: {
     *     // ... filter to delete one CycleProvider
     *   }
     * })
     * 
     */
    delete<T extends CycleProviderDeleteArgs>(args: SelectSubset<T, CycleProviderDeleteArgs<ExtArgs>>): Prisma__CycleProviderClient<$Result.GetResult<Prisma.$CycleProviderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CycleProvider.
     * @param {CycleProviderUpdateArgs} args - Arguments to update one CycleProvider.
     * @example
     * // Update one CycleProvider
     * const cycleProvider = await prisma.cycleProvider.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CycleProviderUpdateArgs>(args: SelectSubset<T, CycleProviderUpdateArgs<ExtArgs>>): Prisma__CycleProviderClient<$Result.GetResult<Prisma.$CycleProviderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CycleProviders.
     * @param {CycleProviderDeleteManyArgs} args - Arguments to filter CycleProviders to delete.
     * @example
     * // Delete a few CycleProviders
     * const { count } = await prisma.cycleProvider.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CycleProviderDeleteManyArgs>(args?: SelectSubset<T, CycleProviderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CycleProviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CycleProviderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CycleProviders
     * const cycleProvider = await prisma.cycleProvider.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CycleProviderUpdateManyArgs>(args: SelectSubset<T, CycleProviderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CycleProviders and returns the data updated in the database.
     * @param {CycleProviderUpdateManyAndReturnArgs} args - Arguments to update many CycleProviders.
     * @example
     * // Update many CycleProviders
     * const cycleProvider = await prisma.cycleProvider.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CycleProviders and only return the `id`
     * const cycleProviderWithIdOnly = await prisma.cycleProvider.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CycleProviderUpdateManyAndReturnArgs>(args: SelectSubset<T, CycleProviderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CycleProviderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CycleProvider.
     * @param {CycleProviderUpsertArgs} args - Arguments to update or create a CycleProvider.
     * @example
     * // Update or create a CycleProvider
     * const cycleProvider = await prisma.cycleProvider.upsert({
     *   create: {
     *     // ... data to create a CycleProvider
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CycleProvider we want to update
     *   }
     * })
     */
    upsert<T extends CycleProviderUpsertArgs>(args: SelectSubset<T, CycleProviderUpsertArgs<ExtArgs>>): Prisma__CycleProviderClient<$Result.GetResult<Prisma.$CycleProviderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CycleProviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CycleProviderCountArgs} args - Arguments to filter CycleProviders to count.
     * @example
     * // Count the number of CycleProviders
     * const count = await prisma.cycleProvider.count({
     *   where: {
     *     // ... the filter for the CycleProviders we want to count
     *   }
     * })
    **/
    count<T extends CycleProviderCountArgs>(
      args?: Subset<T, CycleProviderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CycleProviderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CycleProvider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CycleProviderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CycleProviderAggregateArgs>(args: Subset<T, CycleProviderAggregateArgs>): Prisma.PrismaPromise<GetCycleProviderAggregateType<T>>

    /**
     * Group by CycleProvider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CycleProviderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CycleProviderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CycleProviderGroupByArgs['orderBy'] }
        : { orderBy?: CycleProviderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CycleProviderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCycleProviderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CycleProvider model
   */
  readonly fields: CycleProviderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CycleProvider.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CycleProviderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cycles<T extends CycleProvider$cyclesArgs<ExtArgs> = {}>(args?: Subset<T, CycleProvider$cyclesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CyclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CycleProvider model
   */
  interface CycleProviderFieldRefs {
    readonly id: FieldRef<"CycleProvider", 'String'>
    readonly name: FieldRef<"CycleProvider", 'String'>
    readonly description: FieldRef<"CycleProvider", 'String'>
    readonly createdAt: FieldRef<"CycleProvider", 'DateTime'>
    readonly updatedAt: FieldRef<"CycleProvider", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CycleProvider findUnique
   */
  export type CycleProviderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CycleProvider
     */
    select?: CycleProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CycleProvider
     */
    omit?: CycleProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CycleProviderInclude<ExtArgs> | null
    /**
     * Filter, which CycleProvider to fetch.
     */
    where: CycleProviderWhereUniqueInput
  }

  /**
   * CycleProvider findUniqueOrThrow
   */
  export type CycleProviderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CycleProvider
     */
    select?: CycleProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CycleProvider
     */
    omit?: CycleProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CycleProviderInclude<ExtArgs> | null
    /**
     * Filter, which CycleProvider to fetch.
     */
    where: CycleProviderWhereUniqueInput
  }

  /**
   * CycleProvider findFirst
   */
  export type CycleProviderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CycleProvider
     */
    select?: CycleProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CycleProvider
     */
    omit?: CycleProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CycleProviderInclude<ExtArgs> | null
    /**
     * Filter, which CycleProvider to fetch.
     */
    where?: CycleProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CycleProviders to fetch.
     */
    orderBy?: CycleProviderOrderByWithRelationInput | CycleProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CycleProviders.
     */
    cursor?: CycleProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CycleProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CycleProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CycleProviders.
     */
    distinct?: CycleProviderScalarFieldEnum | CycleProviderScalarFieldEnum[]
  }

  /**
   * CycleProvider findFirstOrThrow
   */
  export type CycleProviderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CycleProvider
     */
    select?: CycleProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CycleProvider
     */
    omit?: CycleProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CycleProviderInclude<ExtArgs> | null
    /**
     * Filter, which CycleProvider to fetch.
     */
    where?: CycleProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CycleProviders to fetch.
     */
    orderBy?: CycleProviderOrderByWithRelationInput | CycleProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CycleProviders.
     */
    cursor?: CycleProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CycleProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CycleProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CycleProviders.
     */
    distinct?: CycleProviderScalarFieldEnum | CycleProviderScalarFieldEnum[]
  }

  /**
   * CycleProvider findMany
   */
  export type CycleProviderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CycleProvider
     */
    select?: CycleProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CycleProvider
     */
    omit?: CycleProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CycleProviderInclude<ExtArgs> | null
    /**
     * Filter, which CycleProviders to fetch.
     */
    where?: CycleProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CycleProviders to fetch.
     */
    orderBy?: CycleProviderOrderByWithRelationInput | CycleProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CycleProviders.
     */
    cursor?: CycleProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CycleProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CycleProviders.
     */
    skip?: number
    distinct?: CycleProviderScalarFieldEnum | CycleProviderScalarFieldEnum[]
  }

  /**
   * CycleProvider create
   */
  export type CycleProviderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CycleProvider
     */
    select?: CycleProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CycleProvider
     */
    omit?: CycleProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CycleProviderInclude<ExtArgs> | null
    /**
     * The data needed to create a CycleProvider.
     */
    data: XOR<CycleProviderCreateInput, CycleProviderUncheckedCreateInput>
  }

  /**
   * CycleProvider createMany
   */
  export type CycleProviderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CycleProviders.
     */
    data: CycleProviderCreateManyInput | CycleProviderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CycleProvider createManyAndReturn
   */
  export type CycleProviderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CycleProvider
     */
    select?: CycleProviderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CycleProvider
     */
    omit?: CycleProviderOmit<ExtArgs> | null
    /**
     * The data used to create many CycleProviders.
     */
    data: CycleProviderCreateManyInput | CycleProviderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CycleProvider update
   */
  export type CycleProviderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CycleProvider
     */
    select?: CycleProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CycleProvider
     */
    omit?: CycleProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CycleProviderInclude<ExtArgs> | null
    /**
     * The data needed to update a CycleProvider.
     */
    data: XOR<CycleProviderUpdateInput, CycleProviderUncheckedUpdateInput>
    /**
     * Choose, which CycleProvider to update.
     */
    where: CycleProviderWhereUniqueInput
  }

  /**
   * CycleProvider updateMany
   */
  export type CycleProviderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CycleProviders.
     */
    data: XOR<CycleProviderUpdateManyMutationInput, CycleProviderUncheckedUpdateManyInput>
    /**
     * Filter which CycleProviders to update
     */
    where?: CycleProviderWhereInput
    /**
     * Limit how many CycleProviders to update.
     */
    limit?: number
  }

  /**
   * CycleProvider updateManyAndReturn
   */
  export type CycleProviderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CycleProvider
     */
    select?: CycleProviderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CycleProvider
     */
    omit?: CycleProviderOmit<ExtArgs> | null
    /**
     * The data used to update CycleProviders.
     */
    data: XOR<CycleProviderUpdateManyMutationInput, CycleProviderUncheckedUpdateManyInput>
    /**
     * Filter which CycleProviders to update
     */
    where?: CycleProviderWhereInput
    /**
     * Limit how many CycleProviders to update.
     */
    limit?: number
  }

  /**
   * CycleProvider upsert
   */
  export type CycleProviderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CycleProvider
     */
    select?: CycleProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CycleProvider
     */
    omit?: CycleProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CycleProviderInclude<ExtArgs> | null
    /**
     * The filter to search for the CycleProvider to update in case it exists.
     */
    where: CycleProviderWhereUniqueInput
    /**
     * In case the CycleProvider found by the `where` argument doesn't exist, create a new CycleProvider with this data.
     */
    create: XOR<CycleProviderCreateInput, CycleProviderUncheckedCreateInput>
    /**
     * In case the CycleProvider was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CycleProviderUpdateInput, CycleProviderUncheckedUpdateInput>
  }

  /**
   * CycleProvider delete
   */
  export type CycleProviderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CycleProvider
     */
    select?: CycleProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CycleProvider
     */
    omit?: CycleProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CycleProviderInclude<ExtArgs> | null
    /**
     * Filter which CycleProvider to delete.
     */
    where: CycleProviderWhereUniqueInput
  }

  /**
   * CycleProvider deleteMany
   */
  export type CycleProviderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CycleProviders to delete
     */
    where?: CycleProviderWhereInput
    /**
     * Limit how many CycleProviders to delete.
     */
    limit?: number
  }

  /**
   * CycleProvider.cycles
   */
  export type CycleProvider$cyclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cycle
     */
    select?: CycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cycle
     */
    omit?: CycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CycleInclude<ExtArgs> | null
    where?: CycleWhereInput
    orderBy?: CycleOrderByWithRelationInput | CycleOrderByWithRelationInput[]
    cursor?: CycleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CycleScalarFieldEnum | CycleScalarFieldEnum[]
  }

  /**
   * CycleProvider without action
   */
  export type CycleProviderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CycleProvider
     */
    select?: CycleProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CycleProvider
     */
    omit?: CycleProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CycleProviderInclude<ExtArgs> | null
  }


  /**
   * Model Phase
   */

  export type AggregatePhase = {
    _count: PhaseCountAggregateOutputType | null
    _min: PhaseMinAggregateOutputType | null
    _max: PhaseMaxAggregateOutputType | null
  }

  export type PhaseMinAggregateOutputType = {
    id: string | null
    cycleId: string | null
    name: $Enums.CyclePhase | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PhaseMaxAggregateOutputType = {
    id: string | null
    cycleId: string | null
    name: $Enums.CyclePhase | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PhaseCountAggregateOutputType = {
    id: number
    cycleId: number
    name: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PhaseMinAggregateInputType = {
    id?: true
    cycleId?: true
    name?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PhaseMaxAggregateInputType = {
    id?: true
    cycleId?: true
    name?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PhaseCountAggregateInputType = {
    id?: true
    cycleId?: true
    name?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PhaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Phase to aggregate.
     */
    where?: PhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Phases to fetch.
     */
    orderBy?: PhaseOrderByWithRelationInput | PhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Phases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Phases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Phases
    **/
    _count?: true | PhaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhaseMaxAggregateInputType
  }

  export type GetPhaseAggregateType<T extends PhaseAggregateArgs> = {
        [P in keyof T & keyof AggregatePhase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhase[P]>
      : GetScalarType<T[P], AggregatePhase[P]>
  }




  export type PhaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhaseWhereInput
    orderBy?: PhaseOrderByWithAggregationInput | PhaseOrderByWithAggregationInput[]
    by: PhaseScalarFieldEnum[] | PhaseScalarFieldEnum
    having?: PhaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhaseCountAggregateInputType | true
    _min?: PhaseMinAggregateInputType
    _max?: PhaseMaxAggregateInputType
  }

  export type PhaseGroupByOutputType = {
    id: string
    cycleId: string
    name: $Enums.CyclePhase
    startDate: Date
    endDate: Date
    createdAt: Date
    updatedAt: Date
    _count: PhaseCountAggregateOutputType | null
    _min: PhaseMinAggregateOutputType | null
    _max: PhaseMaxAggregateOutputType | null
  }

  type GetPhaseGroupByPayload<T extends PhaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PhaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhaseGroupByOutputType[P]>
            : GetScalarType<T[P], PhaseGroupByOutputType[P]>
        }
      >
    >


  export type PhaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cycleId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cycle?: boolean | CycleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["phase"]>

  export type PhaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cycleId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cycle?: boolean | CycleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["phase"]>

  export type PhaseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cycleId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cycle?: boolean | CycleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["phase"]>

  export type PhaseSelectScalar = {
    id?: boolean
    cycleId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PhaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cycleId" | "name" | "startDate" | "endDate" | "createdAt" | "updatedAt", ExtArgs["result"]["phase"]>
  export type PhaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cycle?: boolean | CycleDefaultArgs<ExtArgs>
  }
  export type PhaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cycle?: boolean | CycleDefaultArgs<ExtArgs>
  }
  export type PhaseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cycle?: boolean | CycleDefaultArgs<ExtArgs>
  }

  export type $PhasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Phase"
    objects: {
      cycle: Prisma.$CyclePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cycleId: string
      name: $Enums.CyclePhase
      startDate: Date
      endDate: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["phase"]>
    composites: {}
  }

  type PhaseGetPayload<S extends boolean | null | undefined | PhaseDefaultArgs> = $Result.GetResult<Prisma.$PhasePayload, S>

  type PhaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PhaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PhaseCountAggregateInputType | true
    }

  export interface PhaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Phase'], meta: { name: 'Phase' } }
    /**
     * Find zero or one Phase that matches the filter.
     * @param {PhaseFindUniqueArgs} args - Arguments to find a Phase
     * @example
     * // Get one Phase
     * const phase = await prisma.phase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PhaseFindUniqueArgs>(args: SelectSubset<T, PhaseFindUniqueArgs<ExtArgs>>): Prisma__PhaseClient<$Result.GetResult<Prisma.$PhasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Phase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PhaseFindUniqueOrThrowArgs} args - Arguments to find a Phase
     * @example
     * // Get one Phase
     * const phase = await prisma.phase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PhaseFindUniqueOrThrowArgs>(args: SelectSubset<T, PhaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PhaseClient<$Result.GetResult<Prisma.$PhasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Phase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhaseFindFirstArgs} args - Arguments to find a Phase
     * @example
     * // Get one Phase
     * const phase = await prisma.phase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PhaseFindFirstArgs>(args?: SelectSubset<T, PhaseFindFirstArgs<ExtArgs>>): Prisma__PhaseClient<$Result.GetResult<Prisma.$PhasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Phase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhaseFindFirstOrThrowArgs} args - Arguments to find a Phase
     * @example
     * // Get one Phase
     * const phase = await prisma.phase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PhaseFindFirstOrThrowArgs>(args?: SelectSubset<T, PhaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__PhaseClient<$Result.GetResult<Prisma.$PhasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Phases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Phases
     * const phases = await prisma.phase.findMany()
     * 
     * // Get first 10 Phases
     * const phases = await prisma.phase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const phaseWithIdOnly = await prisma.phase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PhaseFindManyArgs>(args?: SelectSubset<T, PhaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Phase.
     * @param {PhaseCreateArgs} args - Arguments to create a Phase.
     * @example
     * // Create one Phase
     * const Phase = await prisma.phase.create({
     *   data: {
     *     // ... data to create a Phase
     *   }
     * })
     * 
     */
    create<T extends PhaseCreateArgs>(args: SelectSubset<T, PhaseCreateArgs<ExtArgs>>): Prisma__PhaseClient<$Result.GetResult<Prisma.$PhasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Phases.
     * @param {PhaseCreateManyArgs} args - Arguments to create many Phases.
     * @example
     * // Create many Phases
     * const phase = await prisma.phase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PhaseCreateManyArgs>(args?: SelectSubset<T, PhaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Phases and returns the data saved in the database.
     * @param {PhaseCreateManyAndReturnArgs} args - Arguments to create many Phases.
     * @example
     * // Create many Phases
     * const phase = await prisma.phase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Phases and only return the `id`
     * const phaseWithIdOnly = await prisma.phase.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PhaseCreateManyAndReturnArgs>(args?: SelectSubset<T, PhaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Phase.
     * @param {PhaseDeleteArgs} args - Arguments to delete one Phase.
     * @example
     * // Delete one Phase
     * const Phase = await prisma.phase.delete({
     *   where: {
     *     // ... filter to delete one Phase
     *   }
     * })
     * 
     */
    delete<T extends PhaseDeleteArgs>(args: SelectSubset<T, PhaseDeleteArgs<ExtArgs>>): Prisma__PhaseClient<$Result.GetResult<Prisma.$PhasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Phase.
     * @param {PhaseUpdateArgs} args - Arguments to update one Phase.
     * @example
     * // Update one Phase
     * const phase = await prisma.phase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PhaseUpdateArgs>(args: SelectSubset<T, PhaseUpdateArgs<ExtArgs>>): Prisma__PhaseClient<$Result.GetResult<Prisma.$PhasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Phases.
     * @param {PhaseDeleteManyArgs} args - Arguments to filter Phases to delete.
     * @example
     * // Delete a few Phases
     * const { count } = await prisma.phase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PhaseDeleteManyArgs>(args?: SelectSubset<T, PhaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Phases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Phases
     * const phase = await prisma.phase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PhaseUpdateManyArgs>(args: SelectSubset<T, PhaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Phases and returns the data updated in the database.
     * @param {PhaseUpdateManyAndReturnArgs} args - Arguments to update many Phases.
     * @example
     * // Update many Phases
     * const phase = await prisma.phase.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Phases and only return the `id`
     * const phaseWithIdOnly = await prisma.phase.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PhaseUpdateManyAndReturnArgs>(args: SelectSubset<T, PhaseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhasePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Phase.
     * @param {PhaseUpsertArgs} args - Arguments to update or create a Phase.
     * @example
     * // Update or create a Phase
     * const phase = await prisma.phase.upsert({
     *   create: {
     *     // ... data to create a Phase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Phase we want to update
     *   }
     * })
     */
    upsert<T extends PhaseUpsertArgs>(args: SelectSubset<T, PhaseUpsertArgs<ExtArgs>>): Prisma__PhaseClient<$Result.GetResult<Prisma.$PhasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Phases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhaseCountArgs} args - Arguments to filter Phases to count.
     * @example
     * // Count the number of Phases
     * const count = await prisma.phase.count({
     *   where: {
     *     // ... the filter for the Phases we want to count
     *   }
     * })
    **/
    count<T extends PhaseCountArgs>(
      args?: Subset<T, PhaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Phase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhaseAggregateArgs>(args: Subset<T, PhaseAggregateArgs>): Prisma.PrismaPromise<GetPhaseAggregateType<T>>

    /**
     * Group by Phase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhaseGroupByArgs['orderBy'] }
        : { orderBy?: PhaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Phase model
   */
  readonly fields: PhaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Phase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PhaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cycle<T extends CycleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CycleDefaultArgs<ExtArgs>>): Prisma__CycleClient<$Result.GetResult<Prisma.$CyclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Phase model
   */
  interface PhaseFieldRefs {
    readonly id: FieldRef<"Phase", 'String'>
    readonly cycleId: FieldRef<"Phase", 'String'>
    readonly name: FieldRef<"Phase", 'CyclePhase'>
    readonly startDate: FieldRef<"Phase", 'DateTime'>
    readonly endDate: FieldRef<"Phase", 'DateTime'>
    readonly createdAt: FieldRef<"Phase", 'DateTime'>
    readonly updatedAt: FieldRef<"Phase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Phase findUnique
   */
  export type PhaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phase
     */
    select?: PhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phase
     */
    omit?: PhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseInclude<ExtArgs> | null
    /**
     * Filter, which Phase to fetch.
     */
    where: PhaseWhereUniqueInput
  }

  /**
   * Phase findUniqueOrThrow
   */
  export type PhaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phase
     */
    select?: PhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phase
     */
    omit?: PhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseInclude<ExtArgs> | null
    /**
     * Filter, which Phase to fetch.
     */
    where: PhaseWhereUniqueInput
  }

  /**
   * Phase findFirst
   */
  export type PhaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phase
     */
    select?: PhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phase
     */
    omit?: PhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseInclude<ExtArgs> | null
    /**
     * Filter, which Phase to fetch.
     */
    where?: PhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Phases to fetch.
     */
    orderBy?: PhaseOrderByWithRelationInput | PhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Phases.
     */
    cursor?: PhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Phases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Phases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Phases.
     */
    distinct?: PhaseScalarFieldEnum | PhaseScalarFieldEnum[]
  }

  /**
   * Phase findFirstOrThrow
   */
  export type PhaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phase
     */
    select?: PhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phase
     */
    omit?: PhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseInclude<ExtArgs> | null
    /**
     * Filter, which Phase to fetch.
     */
    where?: PhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Phases to fetch.
     */
    orderBy?: PhaseOrderByWithRelationInput | PhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Phases.
     */
    cursor?: PhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Phases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Phases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Phases.
     */
    distinct?: PhaseScalarFieldEnum | PhaseScalarFieldEnum[]
  }

  /**
   * Phase findMany
   */
  export type PhaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phase
     */
    select?: PhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phase
     */
    omit?: PhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseInclude<ExtArgs> | null
    /**
     * Filter, which Phases to fetch.
     */
    where?: PhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Phases to fetch.
     */
    orderBy?: PhaseOrderByWithRelationInput | PhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Phases.
     */
    cursor?: PhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Phases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Phases.
     */
    skip?: number
    distinct?: PhaseScalarFieldEnum | PhaseScalarFieldEnum[]
  }

  /**
   * Phase create
   */
  export type PhaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phase
     */
    select?: PhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phase
     */
    omit?: PhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseInclude<ExtArgs> | null
    /**
     * The data needed to create a Phase.
     */
    data: XOR<PhaseCreateInput, PhaseUncheckedCreateInput>
  }

  /**
   * Phase createMany
   */
  export type PhaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Phases.
     */
    data: PhaseCreateManyInput | PhaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Phase createManyAndReturn
   */
  export type PhaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phase
     */
    select?: PhaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Phase
     */
    omit?: PhaseOmit<ExtArgs> | null
    /**
     * The data used to create many Phases.
     */
    data: PhaseCreateManyInput | PhaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Phase update
   */
  export type PhaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phase
     */
    select?: PhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phase
     */
    omit?: PhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseInclude<ExtArgs> | null
    /**
     * The data needed to update a Phase.
     */
    data: XOR<PhaseUpdateInput, PhaseUncheckedUpdateInput>
    /**
     * Choose, which Phase to update.
     */
    where: PhaseWhereUniqueInput
  }

  /**
   * Phase updateMany
   */
  export type PhaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Phases.
     */
    data: XOR<PhaseUpdateManyMutationInput, PhaseUncheckedUpdateManyInput>
    /**
     * Filter which Phases to update
     */
    where?: PhaseWhereInput
    /**
     * Limit how many Phases to update.
     */
    limit?: number
  }

  /**
   * Phase updateManyAndReturn
   */
  export type PhaseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phase
     */
    select?: PhaseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Phase
     */
    omit?: PhaseOmit<ExtArgs> | null
    /**
     * The data used to update Phases.
     */
    data: XOR<PhaseUpdateManyMutationInput, PhaseUncheckedUpdateManyInput>
    /**
     * Filter which Phases to update
     */
    where?: PhaseWhereInput
    /**
     * Limit how many Phases to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Phase upsert
   */
  export type PhaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phase
     */
    select?: PhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phase
     */
    omit?: PhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseInclude<ExtArgs> | null
    /**
     * The filter to search for the Phase to update in case it exists.
     */
    where: PhaseWhereUniqueInput
    /**
     * In case the Phase found by the `where` argument doesn't exist, create a new Phase with this data.
     */
    create: XOR<PhaseCreateInput, PhaseUncheckedCreateInput>
    /**
     * In case the Phase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PhaseUpdateInput, PhaseUncheckedUpdateInput>
  }

  /**
   * Phase delete
   */
  export type PhaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phase
     */
    select?: PhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phase
     */
    omit?: PhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseInclude<ExtArgs> | null
    /**
     * Filter which Phase to delete.
     */
    where: PhaseWhereUniqueInput
  }

  /**
   * Phase deleteMany
   */
  export type PhaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Phases to delete
     */
    where?: PhaseWhereInput
    /**
     * Limit how many Phases to delete.
     */
    limit?: number
  }

  /**
   * Phase without action
   */
  export type PhaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phase
     */
    select?: PhaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Phase
     */
    omit?: PhaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseInclude<ExtArgs> | null
  }


  /**
   * Model Exercise
   */

  export type AggregateExercise = {
    _count: ExerciseCountAggregateOutputType | null
    _avg: ExerciseAvgAggregateOutputType | null
    _sum: ExerciseSumAggregateOutputType | null
    _min: ExerciseMinAggregateOutputType | null
    _max: ExerciseMaxAggregateOutputType | null
  }

  export type ExerciseAvgAggregateOutputType = {
    durationMinutes: number | null
  }

  export type ExerciseSumAggregateOutputType = {
    durationMinutes: number | null
  }

  export type ExerciseMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    imageUrl: string | null
    durationMinutes: number | null
    intensity: $Enums.Intensity | null
    muscleZone: $Enums.MuscleZone | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExerciseMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    imageUrl: string | null
    durationMinutes: number | null
    intensity: $Enums.Intensity | null
    muscleZone: $Enums.MuscleZone | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExerciseCountAggregateOutputType = {
    id: number
    title: number
    description: number
    imageUrl: number
    durationMinutes: number
    intensity: number
    muscleZone: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExerciseAvgAggregateInputType = {
    durationMinutes?: true
  }

  export type ExerciseSumAggregateInputType = {
    durationMinutes?: true
  }

  export type ExerciseMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    imageUrl?: true
    durationMinutes?: true
    intensity?: true
    muscleZone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExerciseMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    imageUrl?: true
    durationMinutes?: true
    intensity?: true
    muscleZone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExerciseCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    imageUrl?: true
    durationMinutes?: true
    intensity?: true
    muscleZone?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExerciseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exercise to aggregate.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Exercises
    **/
    _count?: true | ExerciseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExerciseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExerciseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExerciseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExerciseMaxAggregateInputType
  }

  export type GetExerciseAggregateType<T extends ExerciseAggregateArgs> = {
        [P in keyof T & keyof AggregateExercise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExercise[P]>
      : GetScalarType<T[P], AggregateExercise[P]>
  }




  export type ExerciseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseWhereInput
    orderBy?: ExerciseOrderByWithAggregationInput | ExerciseOrderByWithAggregationInput[]
    by: ExerciseScalarFieldEnum[] | ExerciseScalarFieldEnum
    having?: ExerciseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExerciseCountAggregateInputType | true
    _avg?: ExerciseAvgAggregateInputType
    _sum?: ExerciseSumAggregateInputType
    _min?: ExerciseMinAggregateInputType
    _max?: ExerciseMaxAggregateInputType
  }

  export type ExerciseGroupByOutputType = {
    id: string
    title: string
    description: string | null
    imageUrl: string | null
    durationMinutes: number | null
    intensity: $Enums.Intensity | null
    muscleZone: $Enums.MuscleZone | null
    createdAt: Date
    updatedAt: Date
    _count: ExerciseCountAggregateOutputType | null
    _avg: ExerciseAvgAggregateOutputType | null
    _sum: ExerciseSumAggregateOutputType | null
    _min: ExerciseMinAggregateOutputType | null
    _max: ExerciseMaxAggregateOutputType | null
  }

  type GetExerciseGroupByPayload<T extends ExerciseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExerciseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExerciseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExerciseGroupByOutputType[P]>
            : GetScalarType<T[P], ExerciseGroupByOutputType[P]>
        }
      >
    >


  export type ExerciseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    imageUrl?: boolean
    durationMinutes?: boolean
    intensity?: boolean
    muscleZone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    exerciseTags?: boolean | Exercise$exerciseTagsArgs<ExtArgs>
    phaseExercises?: boolean | Exercise$phaseExercisesArgs<ExtArgs>
    programExercises?: boolean | Exercise$programExercisesArgs<ExtArgs>
    _count?: boolean | ExerciseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exercise"]>

  export type ExerciseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    imageUrl?: boolean
    durationMinutes?: boolean
    intensity?: boolean
    muscleZone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["exercise"]>

  export type ExerciseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    imageUrl?: boolean
    durationMinutes?: boolean
    intensity?: boolean
    muscleZone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["exercise"]>

  export type ExerciseSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    imageUrl?: boolean
    durationMinutes?: boolean
    intensity?: boolean
    muscleZone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExerciseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "imageUrl" | "durationMinutes" | "intensity" | "muscleZone" | "createdAt" | "updatedAt", ExtArgs["result"]["exercise"]>
  export type ExerciseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exerciseTags?: boolean | Exercise$exerciseTagsArgs<ExtArgs>
    phaseExercises?: boolean | Exercise$phaseExercisesArgs<ExtArgs>
    programExercises?: boolean | Exercise$programExercisesArgs<ExtArgs>
    _count?: boolean | ExerciseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExerciseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ExerciseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ExercisePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Exercise"
    objects: {
      exerciseTags: Prisma.$ExerciseTagPayload<ExtArgs>[]
      phaseExercises: Prisma.$PhaseExercisePayload<ExtArgs>[]
      programExercises: Prisma.$ProgramExercisePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      imageUrl: string | null
      durationMinutes: number | null
      intensity: $Enums.Intensity | null
      muscleZone: $Enums.MuscleZone | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["exercise"]>
    composites: {}
  }

  type ExerciseGetPayload<S extends boolean | null | undefined | ExerciseDefaultArgs> = $Result.GetResult<Prisma.$ExercisePayload, S>

  type ExerciseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExerciseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExerciseCountAggregateInputType | true
    }

  export interface ExerciseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Exercise'], meta: { name: 'Exercise' } }
    /**
     * Find zero or one Exercise that matches the filter.
     * @param {ExerciseFindUniqueArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExerciseFindUniqueArgs>(args: SelectSubset<T, ExerciseFindUniqueArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Exercise that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExerciseFindUniqueOrThrowArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExerciseFindUniqueOrThrowArgs>(args: SelectSubset<T, ExerciseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exercise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindFirstArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExerciseFindFirstArgs>(args?: SelectSubset<T, ExerciseFindFirstArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exercise that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindFirstOrThrowArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExerciseFindFirstOrThrowArgs>(args?: SelectSubset<T, ExerciseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Exercises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exercises
     * const exercises = await prisma.exercise.findMany()
     * 
     * // Get first 10 Exercises
     * const exercises = await prisma.exercise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exerciseWithIdOnly = await prisma.exercise.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExerciseFindManyArgs>(args?: SelectSubset<T, ExerciseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Exercise.
     * @param {ExerciseCreateArgs} args - Arguments to create a Exercise.
     * @example
     * // Create one Exercise
     * const Exercise = await prisma.exercise.create({
     *   data: {
     *     // ... data to create a Exercise
     *   }
     * })
     * 
     */
    create<T extends ExerciseCreateArgs>(args: SelectSubset<T, ExerciseCreateArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Exercises.
     * @param {ExerciseCreateManyArgs} args - Arguments to create many Exercises.
     * @example
     * // Create many Exercises
     * const exercise = await prisma.exercise.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExerciseCreateManyArgs>(args?: SelectSubset<T, ExerciseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Exercises and returns the data saved in the database.
     * @param {ExerciseCreateManyAndReturnArgs} args - Arguments to create many Exercises.
     * @example
     * // Create many Exercises
     * const exercise = await prisma.exercise.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Exercises and only return the `id`
     * const exerciseWithIdOnly = await prisma.exercise.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExerciseCreateManyAndReturnArgs>(args?: SelectSubset<T, ExerciseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Exercise.
     * @param {ExerciseDeleteArgs} args - Arguments to delete one Exercise.
     * @example
     * // Delete one Exercise
     * const Exercise = await prisma.exercise.delete({
     *   where: {
     *     // ... filter to delete one Exercise
     *   }
     * })
     * 
     */
    delete<T extends ExerciseDeleteArgs>(args: SelectSubset<T, ExerciseDeleteArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Exercise.
     * @param {ExerciseUpdateArgs} args - Arguments to update one Exercise.
     * @example
     * // Update one Exercise
     * const exercise = await prisma.exercise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExerciseUpdateArgs>(args: SelectSubset<T, ExerciseUpdateArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Exercises.
     * @param {ExerciseDeleteManyArgs} args - Arguments to filter Exercises to delete.
     * @example
     * // Delete a few Exercises
     * const { count } = await prisma.exercise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExerciseDeleteManyArgs>(args?: SelectSubset<T, ExerciseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exercises
     * const exercise = await prisma.exercise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExerciseUpdateManyArgs>(args: SelectSubset<T, ExerciseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exercises and returns the data updated in the database.
     * @param {ExerciseUpdateManyAndReturnArgs} args - Arguments to update many Exercises.
     * @example
     * // Update many Exercises
     * const exercise = await prisma.exercise.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Exercises and only return the `id`
     * const exerciseWithIdOnly = await prisma.exercise.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExerciseUpdateManyAndReturnArgs>(args: SelectSubset<T, ExerciseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Exercise.
     * @param {ExerciseUpsertArgs} args - Arguments to update or create a Exercise.
     * @example
     * // Update or create a Exercise
     * const exercise = await prisma.exercise.upsert({
     *   create: {
     *     // ... data to create a Exercise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exercise we want to update
     *   }
     * })
     */
    upsert<T extends ExerciseUpsertArgs>(args: SelectSubset<T, ExerciseUpsertArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Exercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseCountArgs} args - Arguments to filter Exercises to count.
     * @example
     * // Count the number of Exercises
     * const count = await prisma.exercise.count({
     *   where: {
     *     // ... the filter for the Exercises we want to count
     *   }
     * })
    **/
    count<T extends ExerciseCountArgs>(
      args?: Subset<T, ExerciseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExerciseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExerciseAggregateArgs>(args: Subset<T, ExerciseAggregateArgs>): Prisma.PrismaPromise<GetExerciseAggregateType<T>>

    /**
     * Group by Exercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExerciseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExerciseGroupByArgs['orderBy'] }
        : { orderBy?: ExerciseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExerciseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExerciseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Exercise model
   */
  readonly fields: ExerciseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Exercise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExerciseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    exerciseTags<T extends Exercise$exerciseTagsArgs<ExtArgs> = {}>(args?: Subset<T, Exercise$exerciseTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    phaseExercises<T extends Exercise$phaseExercisesArgs<ExtArgs> = {}>(args?: Subset<T, Exercise$phaseExercisesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhaseExercisePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    programExercises<T extends Exercise$programExercisesArgs<ExtArgs> = {}>(args?: Subset<T, Exercise$programExercisesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramExercisePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Exercise model
   */
  interface ExerciseFieldRefs {
    readonly id: FieldRef<"Exercise", 'String'>
    readonly title: FieldRef<"Exercise", 'String'>
    readonly description: FieldRef<"Exercise", 'String'>
    readonly imageUrl: FieldRef<"Exercise", 'String'>
    readonly durationMinutes: FieldRef<"Exercise", 'Int'>
    readonly intensity: FieldRef<"Exercise", 'Intensity'>
    readonly muscleZone: FieldRef<"Exercise", 'MuscleZone'>
    readonly createdAt: FieldRef<"Exercise", 'DateTime'>
    readonly updatedAt: FieldRef<"Exercise", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Exercise findUnique
   */
  export type ExerciseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise findUniqueOrThrow
   */
  export type ExerciseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise findFirst
   */
  export type ExerciseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exercises.
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exercises.
     */
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * Exercise findFirstOrThrow
   */
  export type ExerciseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exercises.
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exercises.
     */
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * Exercise findMany
   */
  export type ExerciseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercises to fetch.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Exercises.
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * Exercise create
   */
  export type ExerciseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * The data needed to create a Exercise.
     */
    data: XOR<ExerciseCreateInput, ExerciseUncheckedCreateInput>
  }

  /**
   * Exercise createMany
   */
  export type ExerciseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Exercises.
     */
    data: ExerciseCreateManyInput | ExerciseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Exercise createManyAndReturn
   */
  export type ExerciseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * The data used to create many Exercises.
     */
    data: ExerciseCreateManyInput | ExerciseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Exercise update
   */
  export type ExerciseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * The data needed to update a Exercise.
     */
    data: XOR<ExerciseUpdateInput, ExerciseUncheckedUpdateInput>
    /**
     * Choose, which Exercise to update.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise updateMany
   */
  export type ExerciseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Exercises.
     */
    data: XOR<ExerciseUpdateManyMutationInput, ExerciseUncheckedUpdateManyInput>
    /**
     * Filter which Exercises to update
     */
    where?: ExerciseWhereInput
    /**
     * Limit how many Exercises to update.
     */
    limit?: number
  }

  /**
   * Exercise updateManyAndReturn
   */
  export type ExerciseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * The data used to update Exercises.
     */
    data: XOR<ExerciseUpdateManyMutationInput, ExerciseUncheckedUpdateManyInput>
    /**
     * Filter which Exercises to update
     */
    where?: ExerciseWhereInput
    /**
     * Limit how many Exercises to update.
     */
    limit?: number
  }

  /**
   * Exercise upsert
   */
  export type ExerciseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * The filter to search for the Exercise to update in case it exists.
     */
    where: ExerciseWhereUniqueInput
    /**
     * In case the Exercise found by the `where` argument doesn't exist, create a new Exercise with this data.
     */
    create: XOR<ExerciseCreateInput, ExerciseUncheckedCreateInput>
    /**
     * In case the Exercise was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExerciseUpdateInput, ExerciseUncheckedUpdateInput>
  }

  /**
   * Exercise delete
   */
  export type ExerciseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter which Exercise to delete.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise deleteMany
   */
  export type ExerciseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exercises to delete
     */
    where?: ExerciseWhereInput
    /**
     * Limit how many Exercises to delete.
     */
    limit?: number
  }

  /**
   * Exercise.exerciseTags
   */
  export type Exercise$exerciseTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseTag
     */
    select?: ExerciseTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseTag
     */
    omit?: ExerciseTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseTagInclude<ExtArgs> | null
    where?: ExerciseTagWhereInput
    orderBy?: ExerciseTagOrderByWithRelationInput | ExerciseTagOrderByWithRelationInput[]
    cursor?: ExerciseTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExerciseTagScalarFieldEnum | ExerciseTagScalarFieldEnum[]
  }

  /**
   * Exercise.phaseExercises
   */
  export type Exercise$phaseExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhaseExercise
     */
    select?: PhaseExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhaseExercise
     */
    omit?: PhaseExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseExerciseInclude<ExtArgs> | null
    where?: PhaseExerciseWhereInput
    orderBy?: PhaseExerciseOrderByWithRelationInput | PhaseExerciseOrderByWithRelationInput[]
    cursor?: PhaseExerciseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PhaseExerciseScalarFieldEnum | PhaseExerciseScalarFieldEnum[]
  }

  /**
   * Exercise.programExercises
   */
  export type Exercise$programExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramExercise
     */
    select?: ProgramExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramExercise
     */
    omit?: ProgramExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramExerciseInclude<ExtArgs> | null
    where?: ProgramExerciseWhereInput
    orderBy?: ProgramExerciseOrderByWithRelationInput | ProgramExerciseOrderByWithRelationInput[]
    cursor?: ProgramExerciseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgramExerciseScalarFieldEnum | ProgramExerciseScalarFieldEnum[]
  }

  /**
   * Exercise without action
   */
  export type ExerciseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.TagType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.TagType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    type: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TagMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: string
    name: string
    type: $Enums.TagType
    createdAt: Date
    updatedAt: Date
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    exerciseTags?: boolean | Tag$exerciseTagsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "createdAt" | "updatedAt", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exerciseTags?: boolean | Tag$exerciseTagsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      exerciseTags: Prisma.$ExerciseTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.TagType
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    exerciseTags<T extends Tag$exerciseTagsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$exerciseTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'String'>
    readonly name: FieldRef<"Tag", 'String'>
    readonly type: FieldRef<"Tag", 'TagType'>
    readonly createdAt: FieldRef<"Tag", 'DateTime'>
    readonly updatedAt: FieldRef<"Tag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag.exerciseTags
   */
  export type Tag$exerciseTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseTag
     */
    select?: ExerciseTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseTag
     */
    omit?: ExerciseTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseTagInclude<ExtArgs> | null
    where?: ExerciseTagWhereInput
    orderBy?: ExerciseTagOrderByWithRelationInput | ExerciseTagOrderByWithRelationInput[]
    cursor?: ExerciseTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExerciseTagScalarFieldEnum | ExerciseTagScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model ExerciseTag
   */

  export type AggregateExerciseTag = {
    _count: ExerciseTagCountAggregateOutputType | null
    _min: ExerciseTagMinAggregateOutputType | null
    _max: ExerciseTagMaxAggregateOutputType | null
  }

  export type ExerciseTagMinAggregateOutputType = {
    id: string | null
    exerciseId: string | null
    tagId: string | null
    createdAt: Date | null
  }

  export type ExerciseTagMaxAggregateOutputType = {
    id: string | null
    exerciseId: string | null
    tagId: string | null
    createdAt: Date | null
  }

  export type ExerciseTagCountAggregateOutputType = {
    id: number
    exerciseId: number
    tagId: number
    createdAt: number
    _all: number
  }


  export type ExerciseTagMinAggregateInputType = {
    id?: true
    exerciseId?: true
    tagId?: true
    createdAt?: true
  }

  export type ExerciseTagMaxAggregateInputType = {
    id?: true
    exerciseId?: true
    tagId?: true
    createdAt?: true
  }

  export type ExerciseTagCountAggregateInputType = {
    id?: true
    exerciseId?: true
    tagId?: true
    createdAt?: true
    _all?: true
  }

  export type ExerciseTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExerciseTag to aggregate.
     */
    where?: ExerciseTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseTags to fetch.
     */
    orderBy?: ExerciseTagOrderByWithRelationInput | ExerciseTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExerciseTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExerciseTags
    **/
    _count?: true | ExerciseTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExerciseTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExerciseTagMaxAggregateInputType
  }

  export type GetExerciseTagAggregateType<T extends ExerciseTagAggregateArgs> = {
        [P in keyof T & keyof AggregateExerciseTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExerciseTag[P]>
      : GetScalarType<T[P], AggregateExerciseTag[P]>
  }




  export type ExerciseTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseTagWhereInput
    orderBy?: ExerciseTagOrderByWithAggregationInput | ExerciseTagOrderByWithAggregationInput[]
    by: ExerciseTagScalarFieldEnum[] | ExerciseTagScalarFieldEnum
    having?: ExerciseTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExerciseTagCountAggregateInputType | true
    _min?: ExerciseTagMinAggregateInputType
    _max?: ExerciseTagMaxAggregateInputType
  }

  export type ExerciseTagGroupByOutputType = {
    id: string
    exerciseId: string
    tagId: string
    createdAt: Date
    _count: ExerciseTagCountAggregateOutputType | null
    _min: ExerciseTagMinAggregateOutputType | null
    _max: ExerciseTagMaxAggregateOutputType | null
  }

  type GetExerciseTagGroupByPayload<T extends ExerciseTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExerciseTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExerciseTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExerciseTagGroupByOutputType[P]>
            : GetScalarType<T[P], ExerciseTagGroupByOutputType[P]>
        }
      >
    >


  export type ExerciseTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exerciseId?: boolean
    tagId?: boolean
    createdAt?: boolean
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exerciseTag"]>

  export type ExerciseTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exerciseId?: boolean
    tagId?: boolean
    createdAt?: boolean
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exerciseTag"]>

  export type ExerciseTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exerciseId?: boolean
    tagId?: boolean
    createdAt?: boolean
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exerciseTag"]>

  export type ExerciseTagSelectScalar = {
    id?: boolean
    exerciseId?: boolean
    tagId?: boolean
    createdAt?: boolean
  }

  export type ExerciseTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "exerciseId" | "tagId" | "createdAt", ExtArgs["result"]["exerciseTag"]>
  export type ExerciseTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type ExerciseTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type ExerciseTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $ExerciseTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExerciseTag"
    objects: {
      exercise: Prisma.$ExercisePayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      exerciseId: string
      tagId: string
      createdAt: Date
    }, ExtArgs["result"]["exerciseTag"]>
    composites: {}
  }

  type ExerciseTagGetPayload<S extends boolean | null | undefined | ExerciseTagDefaultArgs> = $Result.GetResult<Prisma.$ExerciseTagPayload, S>

  type ExerciseTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExerciseTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExerciseTagCountAggregateInputType | true
    }

  export interface ExerciseTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExerciseTag'], meta: { name: 'ExerciseTag' } }
    /**
     * Find zero or one ExerciseTag that matches the filter.
     * @param {ExerciseTagFindUniqueArgs} args - Arguments to find a ExerciseTag
     * @example
     * // Get one ExerciseTag
     * const exerciseTag = await prisma.exerciseTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExerciseTagFindUniqueArgs>(args: SelectSubset<T, ExerciseTagFindUniqueArgs<ExtArgs>>): Prisma__ExerciseTagClient<$Result.GetResult<Prisma.$ExerciseTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExerciseTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExerciseTagFindUniqueOrThrowArgs} args - Arguments to find a ExerciseTag
     * @example
     * // Get one ExerciseTag
     * const exerciseTag = await prisma.exerciseTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExerciseTagFindUniqueOrThrowArgs>(args: SelectSubset<T, ExerciseTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExerciseTagClient<$Result.GetResult<Prisma.$ExerciseTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExerciseTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseTagFindFirstArgs} args - Arguments to find a ExerciseTag
     * @example
     * // Get one ExerciseTag
     * const exerciseTag = await prisma.exerciseTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExerciseTagFindFirstArgs>(args?: SelectSubset<T, ExerciseTagFindFirstArgs<ExtArgs>>): Prisma__ExerciseTagClient<$Result.GetResult<Prisma.$ExerciseTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExerciseTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseTagFindFirstOrThrowArgs} args - Arguments to find a ExerciseTag
     * @example
     * // Get one ExerciseTag
     * const exerciseTag = await prisma.exerciseTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExerciseTagFindFirstOrThrowArgs>(args?: SelectSubset<T, ExerciseTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExerciseTagClient<$Result.GetResult<Prisma.$ExerciseTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExerciseTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExerciseTags
     * const exerciseTags = await prisma.exerciseTag.findMany()
     * 
     * // Get first 10 ExerciseTags
     * const exerciseTags = await prisma.exerciseTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exerciseTagWithIdOnly = await prisma.exerciseTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExerciseTagFindManyArgs>(args?: SelectSubset<T, ExerciseTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExerciseTag.
     * @param {ExerciseTagCreateArgs} args - Arguments to create a ExerciseTag.
     * @example
     * // Create one ExerciseTag
     * const ExerciseTag = await prisma.exerciseTag.create({
     *   data: {
     *     // ... data to create a ExerciseTag
     *   }
     * })
     * 
     */
    create<T extends ExerciseTagCreateArgs>(args: SelectSubset<T, ExerciseTagCreateArgs<ExtArgs>>): Prisma__ExerciseTagClient<$Result.GetResult<Prisma.$ExerciseTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExerciseTags.
     * @param {ExerciseTagCreateManyArgs} args - Arguments to create many ExerciseTags.
     * @example
     * // Create many ExerciseTags
     * const exerciseTag = await prisma.exerciseTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExerciseTagCreateManyArgs>(args?: SelectSubset<T, ExerciseTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExerciseTags and returns the data saved in the database.
     * @param {ExerciseTagCreateManyAndReturnArgs} args - Arguments to create many ExerciseTags.
     * @example
     * // Create many ExerciseTags
     * const exerciseTag = await prisma.exerciseTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExerciseTags and only return the `id`
     * const exerciseTagWithIdOnly = await prisma.exerciseTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExerciseTagCreateManyAndReturnArgs>(args?: SelectSubset<T, ExerciseTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExerciseTag.
     * @param {ExerciseTagDeleteArgs} args - Arguments to delete one ExerciseTag.
     * @example
     * // Delete one ExerciseTag
     * const ExerciseTag = await prisma.exerciseTag.delete({
     *   where: {
     *     // ... filter to delete one ExerciseTag
     *   }
     * })
     * 
     */
    delete<T extends ExerciseTagDeleteArgs>(args: SelectSubset<T, ExerciseTagDeleteArgs<ExtArgs>>): Prisma__ExerciseTagClient<$Result.GetResult<Prisma.$ExerciseTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExerciseTag.
     * @param {ExerciseTagUpdateArgs} args - Arguments to update one ExerciseTag.
     * @example
     * // Update one ExerciseTag
     * const exerciseTag = await prisma.exerciseTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExerciseTagUpdateArgs>(args: SelectSubset<T, ExerciseTagUpdateArgs<ExtArgs>>): Prisma__ExerciseTagClient<$Result.GetResult<Prisma.$ExerciseTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExerciseTags.
     * @param {ExerciseTagDeleteManyArgs} args - Arguments to filter ExerciseTags to delete.
     * @example
     * // Delete a few ExerciseTags
     * const { count } = await prisma.exerciseTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExerciseTagDeleteManyArgs>(args?: SelectSubset<T, ExerciseTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExerciseTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExerciseTags
     * const exerciseTag = await prisma.exerciseTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExerciseTagUpdateManyArgs>(args: SelectSubset<T, ExerciseTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExerciseTags and returns the data updated in the database.
     * @param {ExerciseTagUpdateManyAndReturnArgs} args - Arguments to update many ExerciseTags.
     * @example
     * // Update many ExerciseTags
     * const exerciseTag = await prisma.exerciseTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExerciseTags and only return the `id`
     * const exerciseTagWithIdOnly = await prisma.exerciseTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExerciseTagUpdateManyAndReturnArgs>(args: SelectSubset<T, ExerciseTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExerciseTag.
     * @param {ExerciseTagUpsertArgs} args - Arguments to update or create a ExerciseTag.
     * @example
     * // Update or create a ExerciseTag
     * const exerciseTag = await prisma.exerciseTag.upsert({
     *   create: {
     *     // ... data to create a ExerciseTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExerciseTag we want to update
     *   }
     * })
     */
    upsert<T extends ExerciseTagUpsertArgs>(args: SelectSubset<T, ExerciseTagUpsertArgs<ExtArgs>>): Prisma__ExerciseTagClient<$Result.GetResult<Prisma.$ExerciseTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExerciseTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseTagCountArgs} args - Arguments to filter ExerciseTags to count.
     * @example
     * // Count the number of ExerciseTags
     * const count = await prisma.exerciseTag.count({
     *   where: {
     *     // ... the filter for the ExerciseTags we want to count
     *   }
     * })
    **/
    count<T extends ExerciseTagCountArgs>(
      args?: Subset<T, ExerciseTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExerciseTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExerciseTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExerciseTagAggregateArgs>(args: Subset<T, ExerciseTagAggregateArgs>): Prisma.PrismaPromise<GetExerciseTagAggregateType<T>>

    /**
     * Group by ExerciseTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExerciseTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExerciseTagGroupByArgs['orderBy'] }
        : { orderBy?: ExerciseTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExerciseTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExerciseTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExerciseTag model
   */
  readonly fields: ExerciseTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExerciseTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExerciseTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    exercise<T extends ExerciseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExerciseDefaultArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExerciseTag model
   */
  interface ExerciseTagFieldRefs {
    readonly id: FieldRef<"ExerciseTag", 'String'>
    readonly exerciseId: FieldRef<"ExerciseTag", 'String'>
    readonly tagId: FieldRef<"ExerciseTag", 'String'>
    readonly createdAt: FieldRef<"ExerciseTag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExerciseTag findUnique
   */
  export type ExerciseTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseTag
     */
    select?: ExerciseTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseTag
     */
    omit?: ExerciseTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseTagInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseTag to fetch.
     */
    where: ExerciseTagWhereUniqueInput
  }

  /**
   * ExerciseTag findUniqueOrThrow
   */
  export type ExerciseTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseTag
     */
    select?: ExerciseTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseTag
     */
    omit?: ExerciseTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseTagInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseTag to fetch.
     */
    where: ExerciseTagWhereUniqueInput
  }

  /**
   * ExerciseTag findFirst
   */
  export type ExerciseTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseTag
     */
    select?: ExerciseTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseTag
     */
    omit?: ExerciseTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseTagInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseTag to fetch.
     */
    where?: ExerciseTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseTags to fetch.
     */
    orderBy?: ExerciseTagOrderByWithRelationInput | ExerciseTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExerciseTags.
     */
    cursor?: ExerciseTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExerciseTags.
     */
    distinct?: ExerciseTagScalarFieldEnum | ExerciseTagScalarFieldEnum[]
  }

  /**
   * ExerciseTag findFirstOrThrow
   */
  export type ExerciseTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseTag
     */
    select?: ExerciseTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseTag
     */
    omit?: ExerciseTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseTagInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseTag to fetch.
     */
    where?: ExerciseTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseTags to fetch.
     */
    orderBy?: ExerciseTagOrderByWithRelationInput | ExerciseTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExerciseTags.
     */
    cursor?: ExerciseTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExerciseTags.
     */
    distinct?: ExerciseTagScalarFieldEnum | ExerciseTagScalarFieldEnum[]
  }

  /**
   * ExerciseTag findMany
   */
  export type ExerciseTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseTag
     */
    select?: ExerciseTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseTag
     */
    omit?: ExerciseTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseTagInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseTags to fetch.
     */
    where?: ExerciseTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseTags to fetch.
     */
    orderBy?: ExerciseTagOrderByWithRelationInput | ExerciseTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExerciseTags.
     */
    cursor?: ExerciseTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseTags.
     */
    skip?: number
    distinct?: ExerciseTagScalarFieldEnum | ExerciseTagScalarFieldEnum[]
  }

  /**
   * ExerciseTag create
   */
  export type ExerciseTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseTag
     */
    select?: ExerciseTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseTag
     */
    omit?: ExerciseTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseTagInclude<ExtArgs> | null
    /**
     * The data needed to create a ExerciseTag.
     */
    data: XOR<ExerciseTagCreateInput, ExerciseTagUncheckedCreateInput>
  }

  /**
   * ExerciseTag createMany
   */
  export type ExerciseTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExerciseTags.
     */
    data: ExerciseTagCreateManyInput | ExerciseTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExerciseTag createManyAndReturn
   */
  export type ExerciseTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseTag
     */
    select?: ExerciseTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseTag
     */
    omit?: ExerciseTagOmit<ExtArgs> | null
    /**
     * The data used to create many ExerciseTags.
     */
    data: ExerciseTagCreateManyInput | ExerciseTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExerciseTag update
   */
  export type ExerciseTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseTag
     */
    select?: ExerciseTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseTag
     */
    omit?: ExerciseTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseTagInclude<ExtArgs> | null
    /**
     * The data needed to update a ExerciseTag.
     */
    data: XOR<ExerciseTagUpdateInput, ExerciseTagUncheckedUpdateInput>
    /**
     * Choose, which ExerciseTag to update.
     */
    where: ExerciseTagWhereUniqueInput
  }

  /**
   * ExerciseTag updateMany
   */
  export type ExerciseTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExerciseTags.
     */
    data: XOR<ExerciseTagUpdateManyMutationInput, ExerciseTagUncheckedUpdateManyInput>
    /**
     * Filter which ExerciseTags to update
     */
    where?: ExerciseTagWhereInput
    /**
     * Limit how many ExerciseTags to update.
     */
    limit?: number
  }

  /**
   * ExerciseTag updateManyAndReturn
   */
  export type ExerciseTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseTag
     */
    select?: ExerciseTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseTag
     */
    omit?: ExerciseTagOmit<ExtArgs> | null
    /**
     * The data used to update ExerciseTags.
     */
    data: XOR<ExerciseTagUpdateManyMutationInput, ExerciseTagUncheckedUpdateManyInput>
    /**
     * Filter which ExerciseTags to update
     */
    where?: ExerciseTagWhereInput
    /**
     * Limit how many ExerciseTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExerciseTag upsert
   */
  export type ExerciseTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseTag
     */
    select?: ExerciseTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseTag
     */
    omit?: ExerciseTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseTagInclude<ExtArgs> | null
    /**
     * The filter to search for the ExerciseTag to update in case it exists.
     */
    where: ExerciseTagWhereUniqueInput
    /**
     * In case the ExerciseTag found by the `where` argument doesn't exist, create a new ExerciseTag with this data.
     */
    create: XOR<ExerciseTagCreateInput, ExerciseTagUncheckedCreateInput>
    /**
     * In case the ExerciseTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExerciseTagUpdateInput, ExerciseTagUncheckedUpdateInput>
  }

  /**
   * ExerciseTag delete
   */
  export type ExerciseTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseTag
     */
    select?: ExerciseTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseTag
     */
    omit?: ExerciseTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseTagInclude<ExtArgs> | null
    /**
     * Filter which ExerciseTag to delete.
     */
    where: ExerciseTagWhereUniqueInput
  }

  /**
   * ExerciseTag deleteMany
   */
  export type ExerciseTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExerciseTags to delete
     */
    where?: ExerciseTagWhereInput
    /**
     * Limit how many ExerciseTags to delete.
     */
    limit?: number
  }

  /**
   * ExerciseTag without action
   */
  export type ExerciseTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseTag
     */
    select?: ExerciseTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseTag
     */
    omit?: ExerciseTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseTagInclude<ExtArgs> | null
  }


  /**
   * Model PhaseExercise
   */

  export type AggregatePhaseExercise = {
    _count: PhaseExerciseCountAggregateOutputType | null
    _min: PhaseExerciseMinAggregateOutputType | null
    _max: PhaseExerciseMaxAggregateOutputType | null
  }

  export type PhaseExerciseMinAggregateOutputType = {
    id: string | null
    phaseName: $Enums.CyclePhase | null
    exerciseId: string | null
    createdAt: Date | null
  }

  export type PhaseExerciseMaxAggregateOutputType = {
    id: string | null
    phaseName: $Enums.CyclePhase | null
    exerciseId: string | null
    createdAt: Date | null
  }

  export type PhaseExerciseCountAggregateOutputType = {
    id: number
    phaseName: number
    exerciseId: number
    createdAt: number
    _all: number
  }


  export type PhaseExerciseMinAggregateInputType = {
    id?: true
    phaseName?: true
    exerciseId?: true
    createdAt?: true
  }

  export type PhaseExerciseMaxAggregateInputType = {
    id?: true
    phaseName?: true
    exerciseId?: true
    createdAt?: true
  }

  export type PhaseExerciseCountAggregateInputType = {
    id?: true
    phaseName?: true
    exerciseId?: true
    createdAt?: true
    _all?: true
  }

  export type PhaseExerciseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PhaseExercise to aggregate.
     */
    where?: PhaseExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhaseExercises to fetch.
     */
    orderBy?: PhaseExerciseOrderByWithRelationInput | PhaseExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PhaseExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhaseExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhaseExercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PhaseExercises
    **/
    _count?: true | PhaseExerciseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhaseExerciseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhaseExerciseMaxAggregateInputType
  }

  export type GetPhaseExerciseAggregateType<T extends PhaseExerciseAggregateArgs> = {
        [P in keyof T & keyof AggregatePhaseExercise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhaseExercise[P]>
      : GetScalarType<T[P], AggregatePhaseExercise[P]>
  }




  export type PhaseExerciseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhaseExerciseWhereInput
    orderBy?: PhaseExerciseOrderByWithAggregationInput | PhaseExerciseOrderByWithAggregationInput[]
    by: PhaseExerciseScalarFieldEnum[] | PhaseExerciseScalarFieldEnum
    having?: PhaseExerciseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhaseExerciseCountAggregateInputType | true
    _min?: PhaseExerciseMinAggregateInputType
    _max?: PhaseExerciseMaxAggregateInputType
  }

  export type PhaseExerciseGroupByOutputType = {
    id: string
    phaseName: $Enums.CyclePhase
    exerciseId: string
    createdAt: Date
    _count: PhaseExerciseCountAggregateOutputType | null
    _min: PhaseExerciseMinAggregateOutputType | null
    _max: PhaseExerciseMaxAggregateOutputType | null
  }

  type GetPhaseExerciseGroupByPayload<T extends PhaseExerciseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PhaseExerciseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhaseExerciseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhaseExerciseGroupByOutputType[P]>
            : GetScalarType<T[P], PhaseExerciseGroupByOutputType[P]>
        }
      >
    >


  export type PhaseExerciseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phaseName?: boolean
    exerciseId?: boolean
    createdAt?: boolean
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["phaseExercise"]>

  export type PhaseExerciseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phaseName?: boolean
    exerciseId?: boolean
    createdAt?: boolean
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["phaseExercise"]>

  export type PhaseExerciseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phaseName?: boolean
    exerciseId?: boolean
    createdAt?: boolean
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["phaseExercise"]>

  export type PhaseExerciseSelectScalar = {
    id?: boolean
    phaseName?: boolean
    exerciseId?: boolean
    createdAt?: boolean
  }

  export type PhaseExerciseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "phaseName" | "exerciseId" | "createdAt", ExtArgs["result"]["phaseExercise"]>
  export type PhaseExerciseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }
  export type PhaseExerciseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }
  export type PhaseExerciseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }

  export type $PhaseExercisePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PhaseExercise"
    objects: {
      exercise: Prisma.$ExercisePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      phaseName: $Enums.CyclePhase
      exerciseId: string
      createdAt: Date
    }, ExtArgs["result"]["phaseExercise"]>
    composites: {}
  }

  type PhaseExerciseGetPayload<S extends boolean | null | undefined | PhaseExerciseDefaultArgs> = $Result.GetResult<Prisma.$PhaseExercisePayload, S>

  type PhaseExerciseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PhaseExerciseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PhaseExerciseCountAggregateInputType | true
    }

  export interface PhaseExerciseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PhaseExercise'], meta: { name: 'PhaseExercise' } }
    /**
     * Find zero or one PhaseExercise that matches the filter.
     * @param {PhaseExerciseFindUniqueArgs} args - Arguments to find a PhaseExercise
     * @example
     * // Get one PhaseExercise
     * const phaseExercise = await prisma.phaseExercise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PhaseExerciseFindUniqueArgs>(args: SelectSubset<T, PhaseExerciseFindUniqueArgs<ExtArgs>>): Prisma__PhaseExerciseClient<$Result.GetResult<Prisma.$PhaseExercisePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PhaseExercise that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PhaseExerciseFindUniqueOrThrowArgs} args - Arguments to find a PhaseExercise
     * @example
     * // Get one PhaseExercise
     * const phaseExercise = await prisma.phaseExercise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PhaseExerciseFindUniqueOrThrowArgs>(args: SelectSubset<T, PhaseExerciseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PhaseExerciseClient<$Result.GetResult<Prisma.$PhaseExercisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PhaseExercise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhaseExerciseFindFirstArgs} args - Arguments to find a PhaseExercise
     * @example
     * // Get one PhaseExercise
     * const phaseExercise = await prisma.phaseExercise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PhaseExerciseFindFirstArgs>(args?: SelectSubset<T, PhaseExerciseFindFirstArgs<ExtArgs>>): Prisma__PhaseExerciseClient<$Result.GetResult<Prisma.$PhaseExercisePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PhaseExercise that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhaseExerciseFindFirstOrThrowArgs} args - Arguments to find a PhaseExercise
     * @example
     * // Get one PhaseExercise
     * const phaseExercise = await prisma.phaseExercise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PhaseExerciseFindFirstOrThrowArgs>(args?: SelectSubset<T, PhaseExerciseFindFirstOrThrowArgs<ExtArgs>>): Prisma__PhaseExerciseClient<$Result.GetResult<Prisma.$PhaseExercisePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PhaseExercises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhaseExerciseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PhaseExercises
     * const phaseExercises = await prisma.phaseExercise.findMany()
     * 
     * // Get first 10 PhaseExercises
     * const phaseExercises = await prisma.phaseExercise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const phaseExerciseWithIdOnly = await prisma.phaseExercise.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PhaseExerciseFindManyArgs>(args?: SelectSubset<T, PhaseExerciseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhaseExercisePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PhaseExercise.
     * @param {PhaseExerciseCreateArgs} args - Arguments to create a PhaseExercise.
     * @example
     * // Create one PhaseExercise
     * const PhaseExercise = await prisma.phaseExercise.create({
     *   data: {
     *     // ... data to create a PhaseExercise
     *   }
     * })
     * 
     */
    create<T extends PhaseExerciseCreateArgs>(args: SelectSubset<T, PhaseExerciseCreateArgs<ExtArgs>>): Prisma__PhaseExerciseClient<$Result.GetResult<Prisma.$PhaseExercisePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PhaseExercises.
     * @param {PhaseExerciseCreateManyArgs} args - Arguments to create many PhaseExercises.
     * @example
     * // Create many PhaseExercises
     * const phaseExercise = await prisma.phaseExercise.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PhaseExerciseCreateManyArgs>(args?: SelectSubset<T, PhaseExerciseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PhaseExercises and returns the data saved in the database.
     * @param {PhaseExerciseCreateManyAndReturnArgs} args - Arguments to create many PhaseExercises.
     * @example
     * // Create many PhaseExercises
     * const phaseExercise = await prisma.phaseExercise.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PhaseExercises and only return the `id`
     * const phaseExerciseWithIdOnly = await prisma.phaseExercise.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PhaseExerciseCreateManyAndReturnArgs>(args?: SelectSubset<T, PhaseExerciseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhaseExercisePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PhaseExercise.
     * @param {PhaseExerciseDeleteArgs} args - Arguments to delete one PhaseExercise.
     * @example
     * // Delete one PhaseExercise
     * const PhaseExercise = await prisma.phaseExercise.delete({
     *   where: {
     *     // ... filter to delete one PhaseExercise
     *   }
     * })
     * 
     */
    delete<T extends PhaseExerciseDeleteArgs>(args: SelectSubset<T, PhaseExerciseDeleteArgs<ExtArgs>>): Prisma__PhaseExerciseClient<$Result.GetResult<Prisma.$PhaseExercisePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PhaseExercise.
     * @param {PhaseExerciseUpdateArgs} args - Arguments to update one PhaseExercise.
     * @example
     * // Update one PhaseExercise
     * const phaseExercise = await prisma.phaseExercise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PhaseExerciseUpdateArgs>(args: SelectSubset<T, PhaseExerciseUpdateArgs<ExtArgs>>): Prisma__PhaseExerciseClient<$Result.GetResult<Prisma.$PhaseExercisePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PhaseExercises.
     * @param {PhaseExerciseDeleteManyArgs} args - Arguments to filter PhaseExercises to delete.
     * @example
     * // Delete a few PhaseExercises
     * const { count } = await prisma.phaseExercise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PhaseExerciseDeleteManyArgs>(args?: SelectSubset<T, PhaseExerciseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PhaseExercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhaseExerciseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PhaseExercises
     * const phaseExercise = await prisma.phaseExercise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PhaseExerciseUpdateManyArgs>(args: SelectSubset<T, PhaseExerciseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PhaseExercises and returns the data updated in the database.
     * @param {PhaseExerciseUpdateManyAndReturnArgs} args - Arguments to update many PhaseExercises.
     * @example
     * // Update many PhaseExercises
     * const phaseExercise = await prisma.phaseExercise.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PhaseExercises and only return the `id`
     * const phaseExerciseWithIdOnly = await prisma.phaseExercise.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PhaseExerciseUpdateManyAndReturnArgs>(args: SelectSubset<T, PhaseExerciseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhaseExercisePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PhaseExercise.
     * @param {PhaseExerciseUpsertArgs} args - Arguments to update or create a PhaseExercise.
     * @example
     * // Update or create a PhaseExercise
     * const phaseExercise = await prisma.phaseExercise.upsert({
     *   create: {
     *     // ... data to create a PhaseExercise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PhaseExercise we want to update
     *   }
     * })
     */
    upsert<T extends PhaseExerciseUpsertArgs>(args: SelectSubset<T, PhaseExerciseUpsertArgs<ExtArgs>>): Prisma__PhaseExerciseClient<$Result.GetResult<Prisma.$PhaseExercisePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PhaseExercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhaseExerciseCountArgs} args - Arguments to filter PhaseExercises to count.
     * @example
     * // Count the number of PhaseExercises
     * const count = await prisma.phaseExercise.count({
     *   where: {
     *     // ... the filter for the PhaseExercises we want to count
     *   }
     * })
    **/
    count<T extends PhaseExerciseCountArgs>(
      args?: Subset<T, PhaseExerciseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhaseExerciseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PhaseExercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhaseExerciseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhaseExerciseAggregateArgs>(args: Subset<T, PhaseExerciseAggregateArgs>): Prisma.PrismaPromise<GetPhaseExerciseAggregateType<T>>

    /**
     * Group by PhaseExercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhaseExerciseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhaseExerciseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhaseExerciseGroupByArgs['orderBy'] }
        : { orderBy?: PhaseExerciseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhaseExerciseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhaseExerciseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PhaseExercise model
   */
  readonly fields: PhaseExerciseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PhaseExercise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PhaseExerciseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    exercise<T extends ExerciseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExerciseDefaultArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PhaseExercise model
   */
  interface PhaseExerciseFieldRefs {
    readonly id: FieldRef<"PhaseExercise", 'String'>
    readonly phaseName: FieldRef<"PhaseExercise", 'CyclePhase'>
    readonly exerciseId: FieldRef<"PhaseExercise", 'String'>
    readonly createdAt: FieldRef<"PhaseExercise", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PhaseExercise findUnique
   */
  export type PhaseExerciseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhaseExercise
     */
    select?: PhaseExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhaseExercise
     */
    omit?: PhaseExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseExerciseInclude<ExtArgs> | null
    /**
     * Filter, which PhaseExercise to fetch.
     */
    where: PhaseExerciseWhereUniqueInput
  }

  /**
   * PhaseExercise findUniqueOrThrow
   */
  export type PhaseExerciseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhaseExercise
     */
    select?: PhaseExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhaseExercise
     */
    omit?: PhaseExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseExerciseInclude<ExtArgs> | null
    /**
     * Filter, which PhaseExercise to fetch.
     */
    where: PhaseExerciseWhereUniqueInput
  }

  /**
   * PhaseExercise findFirst
   */
  export type PhaseExerciseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhaseExercise
     */
    select?: PhaseExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhaseExercise
     */
    omit?: PhaseExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseExerciseInclude<ExtArgs> | null
    /**
     * Filter, which PhaseExercise to fetch.
     */
    where?: PhaseExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhaseExercises to fetch.
     */
    orderBy?: PhaseExerciseOrderByWithRelationInput | PhaseExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhaseExercises.
     */
    cursor?: PhaseExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhaseExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhaseExercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhaseExercises.
     */
    distinct?: PhaseExerciseScalarFieldEnum | PhaseExerciseScalarFieldEnum[]
  }

  /**
   * PhaseExercise findFirstOrThrow
   */
  export type PhaseExerciseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhaseExercise
     */
    select?: PhaseExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhaseExercise
     */
    omit?: PhaseExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseExerciseInclude<ExtArgs> | null
    /**
     * Filter, which PhaseExercise to fetch.
     */
    where?: PhaseExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhaseExercises to fetch.
     */
    orderBy?: PhaseExerciseOrderByWithRelationInput | PhaseExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhaseExercises.
     */
    cursor?: PhaseExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhaseExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhaseExercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhaseExercises.
     */
    distinct?: PhaseExerciseScalarFieldEnum | PhaseExerciseScalarFieldEnum[]
  }

  /**
   * PhaseExercise findMany
   */
  export type PhaseExerciseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhaseExercise
     */
    select?: PhaseExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhaseExercise
     */
    omit?: PhaseExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseExerciseInclude<ExtArgs> | null
    /**
     * Filter, which PhaseExercises to fetch.
     */
    where?: PhaseExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhaseExercises to fetch.
     */
    orderBy?: PhaseExerciseOrderByWithRelationInput | PhaseExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PhaseExercises.
     */
    cursor?: PhaseExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhaseExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhaseExercises.
     */
    skip?: number
    distinct?: PhaseExerciseScalarFieldEnum | PhaseExerciseScalarFieldEnum[]
  }

  /**
   * PhaseExercise create
   */
  export type PhaseExerciseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhaseExercise
     */
    select?: PhaseExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhaseExercise
     */
    omit?: PhaseExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseExerciseInclude<ExtArgs> | null
    /**
     * The data needed to create a PhaseExercise.
     */
    data: XOR<PhaseExerciseCreateInput, PhaseExerciseUncheckedCreateInput>
  }

  /**
   * PhaseExercise createMany
   */
  export type PhaseExerciseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PhaseExercises.
     */
    data: PhaseExerciseCreateManyInput | PhaseExerciseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PhaseExercise createManyAndReturn
   */
  export type PhaseExerciseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhaseExercise
     */
    select?: PhaseExerciseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PhaseExercise
     */
    omit?: PhaseExerciseOmit<ExtArgs> | null
    /**
     * The data used to create many PhaseExercises.
     */
    data: PhaseExerciseCreateManyInput | PhaseExerciseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseExerciseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PhaseExercise update
   */
  export type PhaseExerciseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhaseExercise
     */
    select?: PhaseExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhaseExercise
     */
    omit?: PhaseExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseExerciseInclude<ExtArgs> | null
    /**
     * The data needed to update a PhaseExercise.
     */
    data: XOR<PhaseExerciseUpdateInput, PhaseExerciseUncheckedUpdateInput>
    /**
     * Choose, which PhaseExercise to update.
     */
    where: PhaseExerciseWhereUniqueInput
  }

  /**
   * PhaseExercise updateMany
   */
  export type PhaseExerciseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PhaseExercises.
     */
    data: XOR<PhaseExerciseUpdateManyMutationInput, PhaseExerciseUncheckedUpdateManyInput>
    /**
     * Filter which PhaseExercises to update
     */
    where?: PhaseExerciseWhereInput
    /**
     * Limit how many PhaseExercises to update.
     */
    limit?: number
  }

  /**
   * PhaseExercise updateManyAndReturn
   */
  export type PhaseExerciseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhaseExercise
     */
    select?: PhaseExerciseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PhaseExercise
     */
    omit?: PhaseExerciseOmit<ExtArgs> | null
    /**
     * The data used to update PhaseExercises.
     */
    data: XOR<PhaseExerciseUpdateManyMutationInput, PhaseExerciseUncheckedUpdateManyInput>
    /**
     * Filter which PhaseExercises to update
     */
    where?: PhaseExerciseWhereInput
    /**
     * Limit how many PhaseExercises to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseExerciseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PhaseExercise upsert
   */
  export type PhaseExerciseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhaseExercise
     */
    select?: PhaseExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhaseExercise
     */
    omit?: PhaseExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseExerciseInclude<ExtArgs> | null
    /**
     * The filter to search for the PhaseExercise to update in case it exists.
     */
    where: PhaseExerciseWhereUniqueInput
    /**
     * In case the PhaseExercise found by the `where` argument doesn't exist, create a new PhaseExercise with this data.
     */
    create: XOR<PhaseExerciseCreateInput, PhaseExerciseUncheckedCreateInput>
    /**
     * In case the PhaseExercise was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PhaseExerciseUpdateInput, PhaseExerciseUncheckedUpdateInput>
  }

  /**
   * PhaseExercise delete
   */
  export type PhaseExerciseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhaseExercise
     */
    select?: PhaseExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhaseExercise
     */
    omit?: PhaseExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseExerciseInclude<ExtArgs> | null
    /**
     * Filter which PhaseExercise to delete.
     */
    where: PhaseExerciseWhereUniqueInput
  }

  /**
   * PhaseExercise deleteMany
   */
  export type PhaseExerciseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PhaseExercises to delete
     */
    where?: PhaseExerciseWhereInput
    /**
     * Limit how many PhaseExercises to delete.
     */
    limit?: number
  }

  /**
   * PhaseExercise without action
   */
  export type PhaseExerciseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhaseExercise
     */
    select?: PhaseExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PhaseExercise
     */
    omit?: PhaseExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseExerciseInclude<ExtArgs> | null
  }


  /**
   * Model Program
   */

  export type AggregateProgram = {
    _count: ProgramCountAggregateOutputType | null
    _min: ProgramMinAggregateOutputType | null
    _max: ProgramMaxAggregateOutputType | null
  }

  export type ProgramMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    goal: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProgramMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    goal: string | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProgramCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    goal: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProgramMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    goal?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProgramMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    goal?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProgramCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    goal?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProgramAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Program to aggregate.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Programs
    **/
    _count?: true | ProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgramMaxAggregateInputType
  }

  export type GetProgramAggregateType<T extends ProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgram[P]>
      : GetScalarType<T[P], AggregateProgram[P]>
  }




  export type ProgramGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramWhereInput
    orderBy?: ProgramOrderByWithAggregationInput | ProgramOrderByWithAggregationInput[]
    by: ProgramScalarFieldEnum[] | ProgramScalarFieldEnum
    having?: ProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgramCountAggregateInputType | true
    _min?: ProgramMinAggregateInputType
    _max?: ProgramMaxAggregateInputType
  }

  export type ProgramGroupByOutputType = {
    id: string
    userId: string
    title: string
    goal: string | null
    startDate: Date
    endDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ProgramCountAggregateOutputType | null
    _min: ProgramMinAggregateOutputType | null
    _max: ProgramMaxAggregateOutputType | null
  }

  type GetProgramGroupByPayload<T extends ProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgramGroupByOutputType[P]>
            : GetScalarType<T[P], ProgramGroupByOutputType[P]>
        }
      >
    >


  export type ProgramSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    goal?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    programExercises?: boolean | Program$programExercisesArgs<ExtArgs>
    notifications?: boolean | Program$notificationsArgs<ExtArgs>
    _count?: boolean | ProgramCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["program"]>

  export type ProgramSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    goal?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["program"]>

  export type ProgramSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    goal?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["program"]>

  export type ProgramSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    goal?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProgramOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "goal" | "startDate" | "endDate" | "createdAt" | "updatedAt", ExtArgs["result"]["program"]>
  export type ProgramInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    programExercises?: boolean | Program$programExercisesArgs<ExtArgs>
    notifications?: boolean | Program$notificationsArgs<ExtArgs>
    _count?: boolean | ProgramCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProgramIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProgramIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProgramPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Program"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      programExercises: Prisma.$ProgramExercisePayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      goal: string | null
      startDate: Date
      endDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["program"]>
    composites: {}
  }

  type ProgramGetPayload<S extends boolean | null | undefined | ProgramDefaultArgs> = $Result.GetResult<Prisma.$ProgramPayload, S>

  type ProgramCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProgramFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProgramCountAggregateInputType | true
    }

  export interface ProgramDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Program'], meta: { name: 'Program' } }
    /**
     * Find zero or one Program that matches the filter.
     * @param {ProgramFindUniqueArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgramFindUniqueArgs>(args: SelectSubset<T, ProgramFindUniqueArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Program that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProgramFindUniqueOrThrowArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgramFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgramFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Program that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindFirstArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgramFindFirstArgs>(args?: SelectSubset<T, ProgramFindFirstArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Program that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindFirstOrThrowArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgramFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgramFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Programs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Programs
     * const programs = await prisma.program.findMany()
     * 
     * // Get first 10 Programs
     * const programs = await prisma.program.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const programWithIdOnly = await prisma.program.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProgramFindManyArgs>(args?: SelectSubset<T, ProgramFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Program.
     * @param {ProgramCreateArgs} args - Arguments to create a Program.
     * @example
     * // Create one Program
     * const Program = await prisma.program.create({
     *   data: {
     *     // ... data to create a Program
     *   }
     * })
     * 
     */
    create<T extends ProgramCreateArgs>(args: SelectSubset<T, ProgramCreateArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Programs.
     * @param {ProgramCreateManyArgs} args - Arguments to create many Programs.
     * @example
     * // Create many Programs
     * const program = await prisma.program.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgramCreateManyArgs>(args?: SelectSubset<T, ProgramCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Programs and returns the data saved in the database.
     * @param {ProgramCreateManyAndReturnArgs} args - Arguments to create many Programs.
     * @example
     * // Create many Programs
     * const program = await prisma.program.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Programs and only return the `id`
     * const programWithIdOnly = await prisma.program.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProgramCreateManyAndReturnArgs>(args?: SelectSubset<T, ProgramCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Program.
     * @param {ProgramDeleteArgs} args - Arguments to delete one Program.
     * @example
     * // Delete one Program
     * const Program = await prisma.program.delete({
     *   where: {
     *     // ... filter to delete one Program
     *   }
     * })
     * 
     */
    delete<T extends ProgramDeleteArgs>(args: SelectSubset<T, ProgramDeleteArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Program.
     * @param {ProgramUpdateArgs} args - Arguments to update one Program.
     * @example
     * // Update one Program
     * const program = await prisma.program.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgramUpdateArgs>(args: SelectSubset<T, ProgramUpdateArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Programs.
     * @param {ProgramDeleteManyArgs} args - Arguments to filter Programs to delete.
     * @example
     * // Delete a few Programs
     * const { count } = await prisma.program.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgramDeleteManyArgs>(args?: SelectSubset<T, ProgramDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Programs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Programs
     * const program = await prisma.program.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgramUpdateManyArgs>(args: SelectSubset<T, ProgramUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Programs and returns the data updated in the database.
     * @param {ProgramUpdateManyAndReturnArgs} args - Arguments to update many Programs.
     * @example
     * // Update many Programs
     * const program = await prisma.program.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Programs and only return the `id`
     * const programWithIdOnly = await prisma.program.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProgramUpdateManyAndReturnArgs>(args: SelectSubset<T, ProgramUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Program.
     * @param {ProgramUpsertArgs} args - Arguments to update or create a Program.
     * @example
     * // Update or create a Program
     * const program = await prisma.program.upsert({
     *   create: {
     *     // ... data to create a Program
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Program we want to update
     *   }
     * })
     */
    upsert<T extends ProgramUpsertArgs>(args: SelectSubset<T, ProgramUpsertArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Programs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramCountArgs} args - Arguments to filter Programs to count.
     * @example
     * // Count the number of Programs
     * const count = await prisma.program.count({
     *   where: {
     *     // ... the filter for the Programs we want to count
     *   }
     * })
    **/
    count<T extends ProgramCountArgs>(
      args?: Subset<T, ProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Program.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgramAggregateArgs>(args: Subset<T, ProgramAggregateArgs>): Prisma.PrismaPromise<GetProgramAggregateType<T>>

    /**
     * Group by Program.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgramGroupByArgs['orderBy'] }
        : { orderBy?: ProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Program model
   */
  readonly fields: ProgramFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Program.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgramClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    programExercises<T extends Program$programExercisesArgs<ExtArgs> = {}>(args?: Subset<T, Program$programExercisesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramExercisePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Program$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Program$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Program model
   */
  interface ProgramFieldRefs {
    readonly id: FieldRef<"Program", 'String'>
    readonly userId: FieldRef<"Program", 'String'>
    readonly title: FieldRef<"Program", 'String'>
    readonly goal: FieldRef<"Program", 'String'>
    readonly startDate: FieldRef<"Program", 'DateTime'>
    readonly endDate: FieldRef<"Program", 'DateTime'>
    readonly createdAt: FieldRef<"Program", 'DateTime'>
    readonly updatedAt: FieldRef<"Program", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Program findUnique
   */
  export type ProgramFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program findUniqueOrThrow
   */
  export type ProgramFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program findFirst
   */
  export type ProgramFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Programs.
     */
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Program findFirstOrThrow
   */
  export type ProgramFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Programs.
     */
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Program findMany
   */
  export type ProgramFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Programs to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Program create
   */
  export type ProgramCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * The data needed to create a Program.
     */
    data: XOR<ProgramCreateInput, ProgramUncheckedCreateInput>
  }

  /**
   * Program createMany
   */
  export type ProgramCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Programs.
     */
    data: ProgramCreateManyInput | ProgramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Program createManyAndReturn
   */
  export type ProgramCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * The data used to create many Programs.
     */
    data: ProgramCreateManyInput | ProgramCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Program update
   */
  export type ProgramUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * The data needed to update a Program.
     */
    data: XOR<ProgramUpdateInput, ProgramUncheckedUpdateInput>
    /**
     * Choose, which Program to update.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program updateMany
   */
  export type ProgramUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Programs.
     */
    data: XOR<ProgramUpdateManyMutationInput, ProgramUncheckedUpdateManyInput>
    /**
     * Filter which Programs to update
     */
    where?: ProgramWhereInput
    /**
     * Limit how many Programs to update.
     */
    limit?: number
  }

  /**
   * Program updateManyAndReturn
   */
  export type ProgramUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * The data used to update Programs.
     */
    data: XOR<ProgramUpdateManyMutationInput, ProgramUncheckedUpdateManyInput>
    /**
     * Filter which Programs to update
     */
    where?: ProgramWhereInput
    /**
     * Limit how many Programs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Program upsert
   */
  export type ProgramUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * The filter to search for the Program to update in case it exists.
     */
    where: ProgramWhereUniqueInput
    /**
     * In case the Program found by the `where` argument doesn't exist, create a new Program with this data.
     */
    create: XOR<ProgramCreateInput, ProgramUncheckedCreateInput>
    /**
     * In case the Program was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgramUpdateInput, ProgramUncheckedUpdateInput>
  }

  /**
   * Program delete
   */
  export type ProgramDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter which Program to delete.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program deleteMany
   */
  export type ProgramDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Programs to delete
     */
    where?: ProgramWhereInput
    /**
     * Limit how many Programs to delete.
     */
    limit?: number
  }

  /**
   * Program.programExercises
   */
  export type Program$programExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramExercise
     */
    select?: ProgramExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramExercise
     */
    omit?: ProgramExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramExerciseInclude<ExtArgs> | null
    where?: ProgramExerciseWhereInput
    orderBy?: ProgramExerciseOrderByWithRelationInput | ProgramExerciseOrderByWithRelationInput[]
    cursor?: ProgramExerciseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgramExerciseScalarFieldEnum | ProgramExerciseScalarFieldEnum[]
  }

  /**
   * Program.notifications
   */
  export type Program$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Program without action
   */
  export type ProgramDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
  }


  /**
   * Model ProgramExercise
   */

  export type AggregateProgramExercise = {
    _count: ProgramExerciseCountAggregateOutputType | null
    _avg: ProgramExerciseAvgAggregateOutputType | null
    _sum: ProgramExerciseSumAggregateOutputType | null
    _min: ProgramExerciseMinAggregateOutputType | null
    _max: ProgramExerciseMaxAggregateOutputType | null
  }

  export type ProgramExerciseAvgAggregateOutputType = {
    day: number | null
    order: number | null
  }

  export type ProgramExerciseSumAggregateOutputType = {
    day: number | null
    order: number | null
  }

  export type ProgramExerciseMinAggregateOutputType = {
    id: string | null
    programId: string | null
    exerciseId: string | null
    day: number | null
    order: number | null
    createdAt: Date | null
  }

  export type ProgramExerciseMaxAggregateOutputType = {
    id: string | null
    programId: string | null
    exerciseId: string | null
    day: number | null
    order: number | null
    createdAt: Date | null
  }

  export type ProgramExerciseCountAggregateOutputType = {
    id: number
    programId: number
    exerciseId: number
    day: number
    order: number
    createdAt: number
    _all: number
  }


  export type ProgramExerciseAvgAggregateInputType = {
    day?: true
    order?: true
  }

  export type ProgramExerciseSumAggregateInputType = {
    day?: true
    order?: true
  }

  export type ProgramExerciseMinAggregateInputType = {
    id?: true
    programId?: true
    exerciseId?: true
    day?: true
    order?: true
    createdAt?: true
  }

  export type ProgramExerciseMaxAggregateInputType = {
    id?: true
    programId?: true
    exerciseId?: true
    day?: true
    order?: true
    createdAt?: true
  }

  export type ProgramExerciseCountAggregateInputType = {
    id?: true
    programId?: true
    exerciseId?: true
    day?: true
    order?: true
    createdAt?: true
    _all?: true
  }

  export type ProgramExerciseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgramExercise to aggregate.
     */
    where?: ProgramExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramExercises to fetch.
     */
    orderBy?: ProgramExerciseOrderByWithRelationInput | ProgramExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgramExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramExercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProgramExercises
    **/
    _count?: true | ProgramExerciseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProgramExerciseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProgramExerciseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgramExerciseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgramExerciseMaxAggregateInputType
  }

  export type GetProgramExerciseAggregateType<T extends ProgramExerciseAggregateArgs> = {
        [P in keyof T & keyof AggregateProgramExercise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgramExercise[P]>
      : GetScalarType<T[P], AggregateProgramExercise[P]>
  }




  export type ProgramExerciseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramExerciseWhereInput
    orderBy?: ProgramExerciseOrderByWithAggregationInput | ProgramExerciseOrderByWithAggregationInput[]
    by: ProgramExerciseScalarFieldEnum[] | ProgramExerciseScalarFieldEnum
    having?: ProgramExerciseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgramExerciseCountAggregateInputType | true
    _avg?: ProgramExerciseAvgAggregateInputType
    _sum?: ProgramExerciseSumAggregateInputType
    _min?: ProgramExerciseMinAggregateInputType
    _max?: ProgramExerciseMaxAggregateInputType
  }

  export type ProgramExerciseGroupByOutputType = {
    id: string
    programId: string
    exerciseId: string
    day: number
    order: number
    createdAt: Date
    _count: ProgramExerciseCountAggregateOutputType | null
    _avg: ProgramExerciseAvgAggregateOutputType | null
    _sum: ProgramExerciseSumAggregateOutputType | null
    _min: ProgramExerciseMinAggregateOutputType | null
    _max: ProgramExerciseMaxAggregateOutputType | null
  }

  type GetProgramExerciseGroupByPayload<T extends ProgramExerciseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgramExerciseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgramExerciseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgramExerciseGroupByOutputType[P]>
            : GetScalarType<T[P], ProgramExerciseGroupByOutputType[P]>
        }
      >
    >


  export type ProgramExerciseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    programId?: boolean
    exerciseId?: boolean
    day?: boolean
    order?: boolean
    createdAt?: boolean
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["programExercise"]>

  export type ProgramExerciseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    programId?: boolean
    exerciseId?: boolean
    day?: boolean
    order?: boolean
    createdAt?: boolean
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["programExercise"]>

  export type ProgramExerciseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    programId?: boolean
    exerciseId?: boolean
    day?: boolean
    order?: boolean
    createdAt?: boolean
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["programExercise"]>

  export type ProgramExerciseSelectScalar = {
    id?: boolean
    programId?: boolean
    exerciseId?: boolean
    day?: boolean
    order?: boolean
    createdAt?: boolean
  }

  export type ProgramExerciseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "programId" | "exerciseId" | "day" | "order" | "createdAt", ExtArgs["result"]["programExercise"]>
  export type ProgramExerciseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }
  export type ProgramExerciseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }
  export type ProgramExerciseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }

  export type $ProgramExercisePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProgramExercise"
    objects: {
      program: Prisma.$ProgramPayload<ExtArgs>
      exercise: Prisma.$ExercisePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      programId: string
      exerciseId: string
      day: number
      order: number
      createdAt: Date
    }, ExtArgs["result"]["programExercise"]>
    composites: {}
  }

  type ProgramExerciseGetPayload<S extends boolean | null | undefined | ProgramExerciseDefaultArgs> = $Result.GetResult<Prisma.$ProgramExercisePayload, S>

  type ProgramExerciseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProgramExerciseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProgramExerciseCountAggregateInputType | true
    }

  export interface ProgramExerciseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProgramExercise'], meta: { name: 'ProgramExercise' } }
    /**
     * Find zero or one ProgramExercise that matches the filter.
     * @param {ProgramExerciseFindUniqueArgs} args - Arguments to find a ProgramExercise
     * @example
     * // Get one ProgramExercise
     * const programExercise = await prisma.programExercise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgramExerciseFindUniqueArgs>(args: SelectSubset<T, ProgramExerciseFindUniqueArgs<ExtArgs>>): Prisma__ProgramExerciseClient<$Result.GetResult<Prisma.$ProgramExercisePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProgramExercise that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProgramExerciseFindUniqueOrThrowArgs} args - Arguments to find a ProgramExercise
     * @example
     * // Get one ProgramExercise
     * const programExercise = await prisma.programExercise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgramExerciseFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgramExerciseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgramExerciseClient<$Result.GetResult<Prisma.$ProgramExercisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProgramExercise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramExerciseFindFirstArgs} args - Arguments to find a ProgramExercise
     * @example
     * // Get one ProgramExercise
     * const programExercise = await prisma.programExercise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgramExerciseFindFirstArgs>(args?: SelectSubset<T, ProgramExerciseFindFirstArgs<ExtArgs>>): Prisma__ProgramExerciseClient<$Result.GetResult<Prisma.$ProgramExercisePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProgramExercise that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramExerciseFindFirstOrThrowArgs} args - Arguments to find a ProgramExercise
     * @example
     * // Get one ProgramExercise
     * const programExercise = await prisma.programExercise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgramExerciseFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgramExerciseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgramExerciseClient<$Result.GetResult<Prisma.$ProgramExercisePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProgramExercises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramExerciseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProgramExercises
     * const programExercises = await prisma.programExercise.findMany()
     * 
     * // Get first 10 ProgramExercises
     * const programExercises = await prisma.programExercise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const programExerciseWithIdOnly = await prisma.programExercise.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProgramExerciseFindManyArgs>(args?: SelectSubset<T, ProgramExerciseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramExercisePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProgramExercise.
     * @param {ProgramExerciseCreateArgs} args - Arguments to create a ProgramExercise.
     * @example
     * // Create one ProgramExercise
     * const ProgramExercise = await prisma.programExercise.create({
     *   data: {
     *     // ... data to create a ProgramExercise
     *   }
     * })
     * 
     */
    create<T extends ProgramExerciseCreateArgs>(args: SelectSubset<T, ProgramExerciseCreateArgs<ExtArgs>>): Prisma__ProgramExerciseClient<$Result.GetResult<Prisma.$ProgramExercisePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProgramExercises.
     * @param {ProgramExerciseCreateManyArgs} args - Arguments to create many ProgramExercises.
     * @example
     * // Create many ProgramExercises
     * const programExercise = await prisma.programExercise.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgramExerciseCreateManyArgs>(args?: SelectSubset<T, ProgramExerciseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProgramExercises and returns the data saved in the database.
     * @param {ProgramExerciseCreateManyAndReturnArgs} args - Arguments to create many ProgramExercises.
     * @example
     * // Create many ProgramExercises
     * const programExercise = await prisma.programExercise.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProgramExercises and only return the `id`
     * const programExerciseWithIdOnly = await prisma.programExercise.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProgramExerciseCreateManyAndReturnArgs>(args?: SelectSubset<T, ProgramExerciseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramExercisePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProgramExercise.
     * @param {ProgramExerciseDeleteArgs} args - Arguments to delete one ProgramExercise.
     * @example
     * // Delete one ProgramExercise
     * const ProgramExercise = await prisma.programExercise.delete({
     *   where: {
     *     // ... filter to delete one ProgramExercise
     *   }
     * })
     * 
     */
    delete<T extends ProgramExerciseDeleteArgs>(args: SelectSubset<T, ProgramExerciseDeleteArgs<ExtArgs>>): Prisma__ProgramExerciseClient<$Result.GetResult<Prisma.$ProgramExercisePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProgramExercise.
     * @param {ProgramExerciseUpdateArgs} args - Arguments to update one ProgramExercise.
     * @example
     * // Update one ProgramExercise
     * const programExercise = await prisma.programExercise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgramExerciseUpdateArgs>(args: SelectSubset<T, ProgramExerciseUpdateArgs<ExtArgs>>): Prisma__ProgramExerciseClient<$Result.GetResult<Prisma.$ProgramExercisePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProgramExercises.
     * @param {ProgramExerciseDeleteManyArgs} args - Arguments to filter ProgramExercises to delete.
     * @example
     * // Delete a few ProgramExercises
     * const { count } = await prisma.programExercise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgramExerciseDeleteManyArgs>(args?: SelectSubset<T, ProgramExerciseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProgramExercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramExerciseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProgramExercises
     * const programExercise = await prisma.programExercise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgramExerciseUpdateManyArgs>(args: SelectSubset<T, ProgramExerciseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProgramExercises and returns the data updated in the database.
     * @param {ProgramExerciseUpdateManyAndReturnArgs} args - Arguments to update many ProgramExercises.
     * @example
     * // Update many ProgramExercises
     * const programExercise = await prisma.programExercise.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProgramExercises and only return the `id`
     * const programExerciseWithIdOnly = await prisma.programExercise.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProgramExerciseUpdateManyAndReturnArgs>(args: SelectSubset<T, ProgramExerciseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramExercisePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProgramExercise.
     * @param {ProgramExerciseUpsertArgs} args - Arguments to update or create a ProgramExercise.
     * @example
     * // Update or create a ProgramExercise
     * const programExercise = await prisma.programExercise.upsert({
     *   create: {
     *     // ... data to create a ProgramExercise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProgramExercise we want to update
     *   }
     * })
     */
    upsert<T extends ProgramExerciseUpsertArgs>(args: SelectSubset<T, ProgramExerciseUpsertArgs<ExtArgs>>): Prisma__ProgramExerciseClient<$Result.GetResult<Prisma.$ProgramExercisePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProgramExercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramExerciseCountArgs} args - Arguments to filter ProgramExercises to count.
     * @example
     * // Count the number of ProgramExercises
     * const count = await prisma.programExercise.count({
     *   where: {
     *     // ... the filter for the ProgramExercises we want to count
     *   }
     * })
    **/
    count<T extends ProgramExerciseCountArgs>(
      args?: Subset<T, ProgramExerciseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgramExerciseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProgramExercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramExerciseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgramExerciseAggregateArgs>(args: Subset<T, ProgramExerciseAggregateArgs>): Prisma.PrismaPromise<GetProgramExerciseAggregateType<T>>

    /**
     * Group by ProgramExercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramExerciseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgramExerciseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgramExerciseGroupByArgs['orderBy'] }
        : { orderBy?: ProgramExerciseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgramExerciseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgramExerciseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProgramExercise model
   */
  readonly fields: ProgramExerciseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProgramExercise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgramExerciseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    program<T extends ProgramDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProgramDefaultArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    exercise<T extends ExerciseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExerciseDefaultArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProgramExercise model
   */
  interface ProgramExerciseFieldRefs {
    readonly id: FieldRef<"ProgramExercise", 'String'>
    readonly programId: FieldRef<"ProgramExercise", 'String'>
    readonly exerciseId: FieldRef<"ProgramExercise", 'String'>
    readonly day: FieldRef<"ProgramExercise", 'Int'>
    readonly order: FieldRef<"ProgramExercise", 'Int'>
    readonly createdAt: FieldRef<"ProgramExercise", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProgramExercise findUnique
   */
  export type ProgramExerciseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramExercise
     */
    select?: ProgramExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramExercise
     */
    omit?: ProgramExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramExerciseInclude<ExtArgs> | null
    /**
     * Filter, which ProgramExercise to fetch.
     */
    where: ProgramExerciseWhereUniqueInput
  }

  /**
   * ProgramExercise findUniqueOrThrow
   */
  export type ProgramExerciseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramExercise
     */
    select?: ProgramExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramExercise
     */
    omit?: ProgramExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramExerciseInclude<ExtArgs> | null
    /**
     * Filter, which ProgramExercise to fetch.
     */
    where: ProgramExerciseWhereUniqueInput
  }

  /**
   * ProgramExercise findFirst
   */
  export type ProgramExerciseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramExercise
     */
    select?: ProgramExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramExercise
     */
    omit?: ProgramExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramExerciseInclude<ExtArgs> | null
    /**
     * Filter, which ProgramExercise to fetch.
     */
    where?: ProgramExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramExercises to fetch.
     */
    orderBy?: ProgramExerciseOrderByWithRelationInput | ProgramExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgramExercises.
     */
    cursor?: ProgramExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramExercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgramExercises.
     */
    distinct?: ProgramExerciseScalarFieldEnum | ProgramExerciseScalarFieldEnum[]
  }

  /**
   * ProgramExercise findFirstOrThrow
   */
  export type ProgramExerciseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramExercise
     */
    select?: ProgramExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramExercise
     */
    omit?: ProgramExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramExerciseInclude<ExtArgs> | null
    /**
     * Filter, which ProgramExercise to fetch.
     */
    where?: ProgramExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramExercises to fetch.
     */
    orderBy?: ProgramExerciseOrderByWithRelationInput | ProgramExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgramExercises.
     */
    cursor?: ProgramExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramExercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgramExercises.
     */
    distinct?: ProgramExerciseScalarFieldEnum | ProgramExerciseScalarFieldEnum[]
  }

  /**
   * ProgramExercise findMany
   */
  export type ProgramExerciseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramExercise
     */
    select?: ProgramExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramExercise
     */
    omit?: ProgramExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramExerciseInclude<ExtArgs> | null
    /**
     * Filter, which ProgramExercises to fetch.
     */
    where?: ProgramExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramExercises to fetch.
     */
    orderBy?: ProgramExerciseOrderByWithRelationInput | ProgramExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProgramExercises.
     */
    cursor?: ProgramExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramExercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramExercises.
     */
    skip?: number
    distinct?: ProgramExerciseScalarFieldEnum | ProgramExerciseScalarFieldEnum[]
  }

  /**
   * ProgramExercise create
   */
  export type ProgramExerciseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramExercise
     */
    select?: ProgramExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramExercise
     */
    omit?: ProgramExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramExerciseInclude<ExtArgs> | null
    /**
     * The data needed to create a ProgramExercise.
     */
    data: XOR<ProgramExerciseCreateInput, ProgramExerciseUncheckedCreateInput>
  }

  /**
   * ProgramExercise createMany
   */
  export type ProgramExerciseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProgramExercises.
     */
    data: ProgramExerciseCreateManyInput | ProgramExerciseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProgramExercise createManyAndReturn
   */
  export type ProgramExerciseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramExercise
     */
    select?: ProgramExerciseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramExercise
     */
    omit?: ProgramExerciseOmit<ExtArgs> | null
    /**
     * The data used to create many ProgramExercises.
     */
    data: ProgramExerciseCreateManyInput | ProgramExerciseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramExerciseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProgramExercise update
   */
  export type ProgramExerciseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramExercise
     */
    select?: ProgramExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramExercise
     */
    omit?: ProgramExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramExerciseInclude<ExtArgs> | null
    /**
     * The data needed to update a ProgramExercise.
     */
    data: XOR<ProgramExerciseUpdateInput, ProgramExerciseUncheckedUpdateInput>
    /**
     * Choose, which ProgramExercise to update.
     */
    where: ProgramExerciseWhereUniqueInput
  }

  /**
   * ProgramExercise updateMany
   */
  export type ProgramExerciseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProgramExercises.
     */
    data: XOR<ProgramExerciseUpdateManyMutationInput, ProgramExerciseUncheckedUpdateManyInput>
    /**
     * Filter which ProgramExercises to update
     */
    where?: ProgramExerciseWhereInput
    /**
     * Limit how many ProgramExercises to update.
     */
    limit?: number
  }

  /**
   * ProgramExercise updateManyAndReturn
   */
  export type ProgramExerciseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramExercise
     */
    select?: ProgramExerciseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramExercise
     */
    omit?: ProgramExerciseOmit<ExtArgs> | null
    /**
     * The data used to update ProgramExercises.
     */
    data: XOR<ProgramExerciseUpdateManyMutationInput, ProgramExerciseUncheckedUpdateManyInput>
    /**
     * Filter which ProgramExercises to update
     */
    where?: ProgramExerciseWhereInput
    /**
     * Limit how many ProgramExercises to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramExerciseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProgramExercise upsert
   */
  export type ProgramExerciseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramExercise
     */
    select?: ProgramExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramExercise
     */
    omit?: ProgramExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramExerciseInclude<ExtArgs> | null
    /**
     * The filter to search for the ProgramExercise to update in case it exists.
     */
    where: ProgramExerciseWhereUniqueInput
    /**
     * In case the ProgramExercise found by the `where` argument doesn't exist, create a new ProgramExercise with this data.
     */
    create: XOR<ProgramExerciseCreateInput, ProgramExerciseUncheckedCreateInput>
    /**
     * In case the ProgramExercise was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgramExerciseUpdateInput, ProgramExerciseUncheckedUpdateInput>
  }

  /**
   * ProgramExercise delete
   */
  export type ProgramExerciseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramExercise
     */
    select?: ProgramExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramExercise
     */
    omit?: ProgramExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramExerciseInclude<ExtArgs> | null
    /**
     * Filter which ProgramExercise to delete.
     */
    where: ProgramExerciseWhereUniqueInput
  }

  /**
   * ProgramExercise deleteMany
   */
  export type ProgramExerciseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgramExercises to delete
     */
    where?: ProgramExerciseWhereInput
    /**
     * Limit how many ProgramExercises to delete.
     */
    limit?: number
  }

  /**
   * ProgramExercise without action
   */
  export type ProgramExerciseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramExercise
     */
    select?: ProgramExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramExercise
     */
    omit?: ProgramExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramExerciseInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    message: string | null
    date: Date | null
    relatedPhase: string | null
    relatedProgramId: string | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    message: string | null
    date: Date | null
    relatedPhase: string | null
    relatedProgramId: string | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    message: number
    date: number
    relatedPhase: number
    relatedProgramId: number
    isRead: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    message?: true
    date?: true
    relatedPhase?: true
    relatedProgramId?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    message?: true
    date?: true
    relatedPhase?: true
    relatedProgramId?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    message?: true
    date?: true
    relatedPhase?: true
    relatedProgramId?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.NotificationType
    message: string
    date: Date
    relatedPhase: string | null
    relatedProgramId: string | null
    isRead: boolean
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    message?: boolean
    date?: boolean
    relatedPhase?: boolean
    relatedProgramId?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    relatedProgram?: boolean | Notification$relatedProgramArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    message?: boolean
    date?: boolean
    relatedPhase?: boolean
    relatedProgramId?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    relatedProgram?: boolean | Notification$relatedProgramArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    message?: boolean
    date?: boolean
    relatedPhase?: boolean
    relatedProgramId?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    relatedProgram?: boolean | Notification$relatedProgramArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    message?: boolean
    date?: boolean
    relatedPhase?: boolean
    relatedProgramId?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "message" | "date" | "relatedPhase" | "relatedProgramId" | "isRead" | "createdAt" | "updatedAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    relatedProgram?: boolean | Notification$relatedProgramArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    relatedProgram?: boolean | Notification$relatedProgramArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    relatedProgram?: boolean | Notification$relatedProgramArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      relatedProgram: Prisma.$ProgramPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.NotificationType
      message: string
      date: Date
      relatedPhase: string | null
      relatedProgramId: string | null
      isRead: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    relatedProgram<T extends Notification$relatedProgramArgs<ExtArgs> = {}>(args?: Subset<T, Notification$relatedProgramArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly date: FieldRef<"Notification", 'DateTime'>
    readonly relatedPhase: FieldRef<"Notification", 'String'>
    readonly relatedProgramId: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification.relatedProgram
   */
  export type Notification$relatedProgramArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    where?: ProgramWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model ExternalSync
   */

  export type AggregateExternalSync = {
    _count: ExternalSyncCountAggregateOutputType | null
    _min: ExternalSyncMinAggregateOutputType | null
    _max: ExternalSyncMaxAggregateOutputType | null
  }

  export type ExternalSyncMinAggregateOutputType = {
    id: string | null
    userId: string | null
    provider: $Enums.ExternalProvider | null
    entitySynced: string | null
    externalId: string | null
    status: $Enums.ExternalSyncStatus | null
    message: string | null
    syncedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExternalSyncMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    provider: $Enums.ExternalProvider | null
    entitySynced: string | null
    externalId: string | null
    status: $Enums.ExternalSyncStatus | null
    message: string | null
    syncedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExternalSyncCountAggregateOutputType = {
    id: number
    userId: number
    provider: number
    entitySynced: number
    externalId: number
    status: number
    message: number
    syncedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExternalSyncMinAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    entitySynced?: true
    externalId?: true
    status?: true
    message?: true
    syncedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExternalSyncMaxAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    entitySynced?: true
    externalId?: true
    status?: true
    message?: true
    syncedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExternalSyncCountAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    entitySynced?: true
    externalId?: true
    status?: true
    message?: true
    syncedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExternalSyncAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExternalSync to aggregate.
     */
    where?: ExternalSyncWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalSyncs to fetch.
     */
    orderBy?: ExternalSyncOrderByWithRelationInput | ExternalSyncOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExternalSyncWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalSyncs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalSyncs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExternalSyncs
    **/
    _count?: true | ExternalSyncCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExternalSyncMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExternalSyncMaxAggregateInputType
  }

  export type GetExternalSyncAggregateType<T extends ExternalSyncAggregateArgs> = {
        [P in keyof T & keyof AggregateExternalSync]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExternalSync[P]>
      : GetScalarType<T[P], AggregateExternalSync[P]>
  }




  export type ExternalSyncGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExternalSyncWhereInput
    orderBy?: ExternalSyncOrderByWithAggregationInput | ExternalSyncOrderByWithAggregationInput[]
    by: ExternalSyncScalarFieldEnum[] | ExternalSyncScalarFieldEnum
    having?: ExternalSyncScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExternalSyncCountAggregateInputType | true
    _min?: ExternalSyncMinAggregateInputType
    _max?: ExternalSyncMaxAggregateInputType
  }

  export type ExternalSyncGroupByOutputType = {
    id: string
    userId: string
    provider: $Enums.ExternalProvider
    entitySynced: string
    externalId: string
    status: $Enums.ExternalSyncStatus
    message: string | null
    syncedAt: Date
    createdAt: Date
    updatedAt: Date
    _count: ExternalSyncCountAggregateOutputType | null
    _min: ExternalSyncMinAggregateOutputType | null
    _max: ExternalSyncMaxAggregateOutputType | null
  }

  type GetExternalSyncGroupByPayload<T extends ExternalSyncGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExternalSyncGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExternalSyncGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExternalSyncGroupByOutputType[P]>
            : GetScalarType<T[P], ExternalSyncGroupByOutputType[P]>
        }
      >
    >


  export type ExternalSyncSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    entitySynced?: boolean
    externalId?: boolean
    status?: boolean
    message?: boolean
    syncedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["externalSync"]>

  export type ExternalSyncSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    entitySynced?: boolean
    externalId?: boolean
    status?: boolean
    message?: boolean
    syncedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["externalSync"]>

  export type ExternalSyncSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    entitySynced?: boolean
    externalId?: boolean
    status?: boolean
    message?: boolean
    syncedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["externalSync"]>

  export type ExternalSyncSelectScalar = {
    id?: boolean
    userId?: boolean
    provider?: boolean
    entitySynced?: boolean
    externalId?: boolean
    status?: boolean
    message?: boolean
    syncedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExternalSyncOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "provider" | "entitySynced" | "externalId" | "status" | "message" | "syncedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["externalSync"]>
  export type ExternalSyncInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ExternalSyncIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ExternalSyncIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ExternalSyncPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExternalSync"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      provider: $Enums.ExternalProvider
      entitySynced: string
      externalId: string
      status: $Enums.ExternalSyncStatus
      message: string | null
      syncedAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["externalSync"]>
    composites: {}
  }

  type ExternalSyncGetPayload<S extends boolean | null | undefined | ExternalSyncDefaultArgs> = $Result.GetResult<Prisma.$ExternalSyncPayload, S>

  type ExternalSyncCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExternalSyncFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExternalSyncCountAggregateInputType | true
    }

  export interface ExternalSyncDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExternalSync'], meta: { name: 'ExternalSync' } }
    /**
     * Find zero or one ExternalSync that matches the filter.
     * @param {ExternalSyncFindUniqueArgs} args - Arguments to find a ExternalSync
     * @example
     * // Get one ExternalSync
     * const externalSync = await prisma.externalSync.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExternalSyncFindUniqueArgs>(args: SelectSubset<T, ExternalSyncFindUniqueArgs<ExtArgs>>): Prisma__ExternalSyncClient<$Result.GetResult<Prisma.$ExternalSyncPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExternalSync that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExternalSyncFindUniqueOrThrowArgs} args - Arguments to find a ExternalSync
     * @example
     * // Get one ExternalSync
     * const externalSync = await prisma.externalSync.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExternalSyncFindUniqueOrThrowArgs>(args: SelectSubset<T, ExternalSyncFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExternalSyncClient<$Result.GetResult<Prisma.$ExternalSyncPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExternalSync that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalSyncFindFirstArgs} args - Arguments to find a ExternalSync
     * @example
     * // Get one ExternalSync
     * const externalSync = await prisma.externalSync.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExternalSyncFindFirstArgs>(args?: SelectSubset<T, ExternalSyncFindFirstArgs<ExtArgs>>): Prisma__ExternalSyncClient<$Result.GetResult<Prisma.$ExternalSyncPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExternalSync that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalSyncFindFirstOrThrowArgs} args - Arguments to find a ExternalSync
     * @example
     * // Get one ExternalSync
     * const externalSync = await prisma.externalSync.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExternalSyncFindFirstOrThrowArgs>(args?: SelectSubset<T, ExternalSyncFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExternalSyncClient<$Result.GetResult<Prisma.$ExternalSyncPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExternalSyncs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalSyncFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExternalSyncs
     * const externalSyncs = await prisma.externalSync.findMany()
     * 
     * // Get first 10 ExternalSyncs
     * const externalSyncs = await prisma.externalSync.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const externalSyncWithIdOnly = await prisma.externalSync.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExternalSyncFindManyArgs>(args?: SelectSubset<T, ExternalSyncFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExternalSyncPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExternalSync.
     * @param {ExternalSyncCreateArgs} args - Arguments to create a ExternalSync.
     * @example
     * // Create one ExternalSync
     * const ExternalSync = await prisma.externalSync.create({
     *   data: {
     *     // ... data to create a ExternalSync
     *   }
     * })
     * 
     */
    create<T extends ExternalSyncCreateArgs>(args: SelectSubset<T, ExternalSyncCreateArgs<ExtArgs>>): Prisma__ExternalSyncClient<$Result.GetResult<Prisma.$ExternalSyncPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExternalSyncs.
     * @param {ExternalSyncCreateManyArgs} args - Arguments to create many ExternalSyncs.
     * @example
     * // Create many ExternalSyncs
     * const externalSync = await prisma.externalSync.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExternalSyncCreateManyArgs>(args?: SelectSubset<T, ExternalSyncCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExternalSyncs and returns the data saved in the database.
     * @param {ExternalSyncCreateManyAndReturnArgs} args - Arguments to create many ExternalSyncs.
     * @example
     * // Create many ExternalSyncs
     * const externalSync = await prisma.externalSync.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExternalSyncs and only return the `id`
     * const externalSyncWithIdOnly = await prisma.externalSync.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExternalSyncCreateManyAndReturnArgs>(args?: SelectSubset<T, ExternalSyncCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExternalSyncPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExternalSync.
     * @param {ExternalSyncDeleteArgs} args - Arguments to delete one ExternalSync.
     * @example
     * // Delete one ExternalSync
     * const ExternalSync = await prisma.externalSync.delete({
     *   where: {
     *     // ... filter to delete one ExternalSync
     *   }
     * })
     * 
     */
    delete<T extends ExternalSyncDeleteArgs>(args: SelectSubset<T, ExternalSyncDeleteArgs<ExtArgs>>): Prisma__ExternalSyncClient<$Result.GetResult<Prisma.$ExternalSyncPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExternalSync.
     * @param {ExternalSyncUpdateArgs} args - Arguments to update one ExternalSync.
     * @example
     * // Update one ExternalSync
     * const externalSync = await prisma.externalSync.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExternalSyncUpdateArgs>(args: SelectSubset<T, ExternalSyncUpdateArgs<ExtArgs>>): Prisma__ExternalSyncClient<$Result.GetResult<Prisma.$ExternalSyncPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExternalSyncs.
     * @param {ExternalSyncDeleteManyArgs} args - Arguments to filter ExternalSyncs to delete.
     * @example
     * // Delete a few ExternalSyncs
     * const { count } = await prisma.externalSync.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExternalSyncDeleteManyArgs>(args?: SelectSubset<T, ExternalSyncDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExternalSyncs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalSyncUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExternalSyncs
     * const externalSync = await prisma.externalSync.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExternalSyncUpdateManyArgs>(args: SelectSubset<T, ExternalSyncUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExternalSyncs and returns the data updated in the database.
     * @param {ExternalSyncUpdateManyAndReturnArgs} args - Arguments to update many ExternalSyncs.
     * @example
     * // Update many ExternalSyncs
     * const externalSync = await prisma.externalSync.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExternalSyncs and only return the `id`
     * const externalSyncWithIdOnly = await prisma.externalSync.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExternalSyncUpdateManyAndReturnArgs>(args: SelectSubset<T, ExternalSyncUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExternalSyncPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExternalSync.
     * @param {ExternalSyncUpsertArgs} args - Arguments to update or create a ExternalSync.
     * @example
     * // Update or create a ExternalSync
     * const externalSync = await prisma.externalSync.upsert({
     *   create: {
     *     // ... data to create a ExternalSync
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExternalSync we want to update
     *   }
     * })
     */
    upsert<T extends ExternalSyncUpsertArgs>(args: SelectSubset<T, ExternalSyncUpsertArgs<ExtArgs>>): Prisma__ExternalSyncClient<$Result.GetResult<Prisma.$ExternalSyncPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExternalSyncs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalSyncCountArgs} args - Arguments to filter ExternalSyncs to count.
     * @example
     * // Count the number of ExternalSyncs
     * const count = await prisma.externalSync.count({
     *   where: {
     *     // ... the filter for the ExternalSyncs we want to count
     *   }
     * })
    **/
    count<T extends ExternalSyncCountArgs>(
      args?: Subset<T, ExternalSyncCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExternalSyncCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExternalSync.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalSyncAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExternalSyncAggregateArgs>(args: Subset<T, ExternalSyncAggregateArgs>): Prisma.PrismaPromise<GetExternalSyncAggregateType<T>>

    /**
     * Group by ExternalSync.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalSyncGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExternalSyncGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExternalSyncGroupByArgs['orderBy'] }
        : { orderBy?: ExternalSyncGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExternalSyncGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExternalSyncGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExternalSync model
   */
  readonly fields: ExternalSyncFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExternalSync.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExternalSyncClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExternalSync model
   */
  interface ExternalSyncFieldRefs {
    readonly id: FieldRef<"ExternalSync", 'String'>
    readonly userId: FieldRef<"ExternalSync", 'String'>
    readonly provider: FieldRef<"ExternalSync", 'ExternalProvider'>
    readonly entitySynced: FieldRef<"ExternalSync", 'String'>
    readonly externalId: FieldRef<"ExternalSync", 'String'>
    readonly status: FieldRef<"ExternalSync", 'ExternalSyncStatus'>
    readonly message: FieldRef<"ExternalSync", 'String'>
    readonly syncedAt: FieldRef<"ExternalSync", 'DateTime'>
    readonly createdAt: FieldRef<"ExternalSync", 'DateTime'>
    readonly updatedAt: FieldRef<"ExternalSync", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExternalSync findUnique
   */
  export type ExternalSyncFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalSync
     */
    select?: ExternalSyncSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalSync
     */
    omit?: ExternalSyncOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalSyncInclude<ExtArgs> | null
    /**
     * Filter, which ExternalSync to fetch.
     */
    where: ExternalSyncWhereUniqueInput
  }

  /**
   * ExternalSync findUniqueOrThrow
   */
  export type ExternalSyncFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalSync
     */
    select?: ExternalSyncSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalSync
     */
    omit?: ExternalSyncOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalSyncInclude<ExtArgs> | null
    /**
     * Filter, which ExternalSync to fetch.
     */
    where: ExternalSyncWhereUniqueInput
  }

  /**
   * ExternalSync findFirst
   */
  export type ExternalSyncFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalSync
     */
    select?: ExternalSyncSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalSync
     */
    omit?: ExternalSyncOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalSyncInclude<ExtArgs> | null
    /**
     * Filter, which ExternalSync to fetch.
     */
    where?: ExternalSyncWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalSyncs to fetch.
     */
    orderBy?: ExternalSyncOrderByWithRelationInput | ExternalSyncOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExternalSyncs.
     */
    cursor?: ExternalSyncWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalSyncs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalSyncs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExternalSyncs.
     */
    distinct?: ExternalSyncScalarFieldEnum | ExternalSyncScalarFieldEnum[]
  }

  /**
   * ExternalSync findFirstOrThrow
   */
  export type ExternalSyncFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalSync
     */
    select?: ExternalSyncSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalSync
     */
    omit?: ExternalSyncOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalSyncInclude<ExtArgs> | null
    /**
     * Filter, which ExternalSync to fetch.
     */
    where?: ExternalSyncWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalSyncs to fetch.
     */
    orderBy?: ExternalSyncOrderByWithRelationInput | ExternalSyncOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExternalSyncs.
     */
    cursor?: ExternalSyncWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalSyncs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalSyncs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExternalSyncs.
     */
    distinct?: ExternalSyncScalarFieldEnum | ExternalSyncScalarFieldEnum[]
  }

  /**
   * ExternalSync findMany
   */
  export type ExternalSyncFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalSync
     */
    select?: ExternalSyncSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalSync
     */
    omit?: ExternalSyncOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalSyncInclude<ExtArgs> | null
    /**
     * Filter, which ExternalSyncs to fetch.
     */
    where?: ExternalSyncWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalSyncs to fetch.
     */
    orderBy?: ExternalSyncOrderByWithRelationInput | ExternalSyncOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExternalSyncs.
     */
    cursor?: ExternalSyncWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalSyncs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalSyncs.
     */
    skip?: number
    distinct?: ExternalSyncScalarFieldEnum | ExternalSyncScalarFieldEnum[]
  }

  /**
   * ExternalSync create
   */
  export type ExternalSyncCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalSync
     */
    select?: ExternalSyncSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalSync
     */
    omit?: ExternalSyncOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalSyncInclude<ExtArgs> | null
    /**
     * The data needed to create a ExternalSync.
     */
    data: XOR<ExternalSyncCreateInput, ExternalSyncUncheckedCreateInput>
  }

  /**
   * ExternalSync createMany
   */
  export type ExternalSyncCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExternalSyncs.
     */
    data: ExternalSyncCreateManyInput | ExternalSyncCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExternalSync createManyAndReturn
   */
  export type ExternalSyncCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalSync
     */
    select?: ExternalSyncSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalSync
     */
    omit?: ExternalSyncOmit<ExtArgs> | null
    /**
     * The data used to create many ExternalSyncs.
     */
    data: ExternalSyncCreateManyInput | ExternalSyncCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalSyncIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExternalSync update
   */
  export type ExternalSyncUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalSync
     */
    select?: ExternalSyncSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalSync
     */
    omit?: ExternalSyncOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalSyncInclude<ExtArgs> | null
    /**
     * The data needed to update a ExternalSync.
     */
    data: XOR<ExternalSyncUpdateInput, ExternalSyncUncheckedUpdateInput>
    /**
     * Choose, which ExternalSync to update.
     */
    where: ExternalSyncWhereUniqueInput
  }

  /**
   * ExternalSync updateMany
   */
  export type ExternalSyncUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExternalSyncs.
     */
    data: XOR<ExternalSyncUpdateManyMutationInput, ExternalSyncUncheckedUpdateManyInput>
    /**
     * Filter which ExternalSyncs to update
     */
    where?: ExternalSyncWhereInput
    /**
     * Limit how many ExternalSyncs to update.
     */
    limit?: number
  }

  /**
   * ExternalSync updateManyAndReturn
   */
  export type ExternalSyncUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalSync
     */
    select?: ExternalSyncSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalSync
     */
    omit?: ExternalSyncOmit<ExtArgs> | null
    /**
     * The data used to update ExternalSyncs.
     */
    data: XOR<ExternalSyncUpdateManyMutationInput, ExternalSyncUncheckedUpdateManyInput>
    /**
     * Filter which ExternalSyncs to update
     */
    where?: ExternalSyncWhereInput
    /**
     * Limit how many ExternalSyncs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalSyncIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExternalSync upsert
   */
  export type ExternalSyncUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalSync
     */
    select?: ExternalSyncSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalSync
     */
    omit?: ExternalSyncOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalSyncInclude<ExtArgs> | null
    /**
     * The filter to search for the ExternalSync to update in case it exists.
     */
    where: ExternalSyncWhereUniqueInput
    /**
     * In case the ExternalSync found by the `where` argument doesn't exist, create a new ExternalSync with this data.
     */
    create: XOR<ExternalSyncCreateInput, ExternalSyncUncheckedCreateInput>
    /**
     * In case the ExternalSync was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExternalSyncUpdateInput, ExternalSyncUncheckedUpdateInput>
  }

  /**
   * ExternalSync delete
   */
  export type ExternalSyncDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalSync
     */
    select?: ExternalSyncSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalSync
     */
    omit?: ExternalSyncOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalSyncInclude<ExtArgs> | null
    /**
     * Filter which ExternalSync to delete.
     */
    where: ExternalSyncWhereUniqueInput
  }

  /**
   * ExternalSync deleteMany
   */
  export type ExternalSyncDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExternalSyncs to delete
     */
    where?: ExternalSyncWhereInput
    /**
     * Limit how many ExternalSyncs to delete.
     */
    limit?: number
  }

  /**
   * ExternalSync without action
   */
  export type ExternalSyncDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalSync
     */
    select?: ExternalSyncSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalSync
     */
    omit?: ExternalSyncOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalSyncInclude<ExtArgs> | null
  }


  /**
   * Model JournalEntry
   */

  export type AggregateJournalEntry = {
    _count: JournalEntryCountAggregateOutputType | null
    _min: JournalEntryMinAggregateOutputType | null
    _max: JournalEntryMaxAggregateOutputType | null
  }

  export type JournalEntryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    date: Date | null
    category: $Enums.JournalCategory | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JournalEntryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    date: Date | null
    category: $Enums.JournalCategory | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JournalEntryCountAggregateOutputType = {
    id: number
    userId: number
    date: number
    category: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type JournalEntryMinAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    category?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JournalEntryMaxAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    category?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JournalEntryCountAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    category?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type JournalEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalEntry to aggregate.
     */
    where?: JournalEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalEntries to fetch.
     */
    orderBy?: JournalEntryOrderByWithRelationInput | JournalEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JournalEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JournalEntries
    **/
    _count?: true | JournalEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JournalEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JournalEntryMaxAggregateInputType
  }

  export type GetJournalEntryAggregateType<T extends JournalEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateJournalEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJournalEntry[P]>
      : GetScalarType<T[P], AggregateJournalEntry[P]>
  }




  export type JournalEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalEntryWhereInput
    orderBy?: JournalEntryOrderByWithAggregationInput | JournalEntryOrderByWithAggregationInput[]
    by: JournalEntryScalarFieldEnum[] | JournalEntryScalarFieldEnum
    having?: JournalEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JournalEntryCountAggregateInputType | true
    _min?: JournalEntryMinAggregateInputType
    _max?: JournalEntryMaxAggregateInputType
  }

  export type JournalEntryGroupByOutputType = {
    id: string
    userId: string
    date: Date
    category: $Enums.JournalCategory
    content: string
    createdAt: Date
    updatedAt: Date
    _count: JournalEntryCountAggregateOutputType | null
    _min: JournalEntryMinAggregateOutputType | null
    _max: JournalEntryMaxAggregateOutputType | null
  }

  type GetJournalEntryGroupByPayload<T extends JournalEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JournalEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JournalEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JournalEntryGroupByOutputType[P]>
            : GetScalarType<T[P], JournalEntryGroupByOutputType[P]>
        }
      >
    >


  export type JournalEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    category?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalEntry"]>

  export type JournalEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    category?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalEntry"]>

  export type JournalEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    category?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journalEntry"]>

  export type JournalEntrySelectScalar = {
    id?: boolean
    userId?: boolean
    date?: boolean
    category?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type JournalEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "date" | "category" | "content" | "createdAt" | "updatedAt", ExtArgs["result"]["journalEntry"]>
  export type JournalEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type JournalEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type JournalEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $JournalEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JournalEntry"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      date: Date
      category: $Enums.JournalCategory
      content: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["journalEntry"]>
    composites: {}
  }

  type JournalEntryGetPayload<S extends boolean | null | undefined | JournalEntryDefaultArgs> = $Result.GetResult<Prisma.$JournalEntryPayload, S>

  type JournalEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JournalEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JournalEntryCountAggregateInputType | true
    }

  export interface JournalEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JournalEntry'], meta: { name: 'JournalEntry' } }
    /**
     * Find zero or one JournalEntry that matches the filter.
     * @param {JournalEntryFindUniqueArgs} args - Arguments to find a JournalEntry
     * @example
     * // Get one JournalEntry
     * const journalEntry = await prisma.journalEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JournalEntryFindUniqueArgs>(args: SelectSubset<T, JournalEntryFindUniqueArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JournalEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JournalEntryFindUniqueOrThrowArgs} args - Arguments to find a JournalEntry
     * @example
     * // Get one JournalEntry
     * const journalEntry = await prisma.journalEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JournalEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, JournalEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryFindFirstArgs} args - Arguments to find a JournalEntry
     * @example
     * // Get one JournalEntry
     * const journalEntry = await prisma.journalEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JournalEntryFindFirstArgs>(args?: SelectSubset<T, JournalEntryFindFirstArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JournalEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryFindFirstOrThrowArgs} args - Arguments to find a JournalEntry
     * @example
     * // Get one JournalEntry
     * const journalEntry = await prisma.journalEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JournalEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, JournalEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JournalEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JournalEntries
     * const journalEntries = await prisma.journalEntry.findMany()
     * 
     * // Get first 10 JournalEntries
     * const journalEntries = await prisma.journalEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const journalEntryWithIdOnly = await prisma.journalEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JournalEntryFindManyArgs>(args?: SelectSubset<T, JournalEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JournalEntry.
     * @param {JournalEntryCreateArgs} args - Arguments to create a JournalEntry.
     * @example
     * // Create one JournalEntry
     * const JournalEntry = await prisma.journalEntry.create({
     *   data: {
     *     // ... data to create a JournalEntry
     *   }
     * })
     * 
     */
    create<T extends JournalEntryCreateArgs>(args: SelectSubset<T, JournalEntryCreateArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JournalEntries.
     * @param {JournalEntryCreateManyArgs} args - Arguments to create many JournalEntries.
     * @example
     * // Create many JournalEntries
     * const journalEntry = await prisma.journalEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JournalEntryCreateManyArgs>(args?: SelectSubset<T, JournalEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JournalEntries and returns the data saved in the database.
     * @param {JournalEntryCreateManyAndReturnArgs} args - Arguments to create many JournalEntries.
     * @example
     * // Create many JournalEntries
     * const journalEntry = await prisma.journalEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JournalEntries and only return the `id`
     * const journalEntryWithIdOnly = await prisma.journalEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JournalEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, JournalEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JournalEntry.
     * @param {JournalEntryDeleteArgs} args - Arguments to delete one JournalEntry.
     * @example
     * // Delete one JournalEntry
     * const JournalEntry = await prisma.journalEntry.delete({
     *   where: {
     *     // ... filter to delete one JournalEntry
     *   }
     * })
     * 
     */
    delete<T extends JournalEntryDeleteArgs>(args: SelectSubset<T, JournalEntryDeleteArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JournalEntry.
     * @param {JournalEntryUpdateArgs} args - Arguments to update one JournalEntry.
     * @example
     * // Update one JournalEntry
     * const journalEntry = await prisma.journalEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JournalEntryUpdateArgs>(args: SelectSubset<T, JournalEntryUpdateArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JournalEntries.
     * @param {JournalEntryDeleteManyArgs} args - Arguments to filter JournalEntries to delete.
     * @example
     * // Delete a few JournalEntries
     * const { count } = await prisma.journalEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JournalEntryDeleteManyArgs>(args?: SelectSubset<T, JournalEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JournalEntries
     * const journalEntry = await prisma.journalEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JournalEntryUpdateManyArgs>(args: SelectSubset<T, JournalEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalEntries and returns the data updated in the database.
     * @param {JournalEntryUpdateManyAndReturnArgs} args - Arguments to update many JournalEntries.
     * @example
     * // Update many JournalEntries
     * const journalEntry = await prisma.journalEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JournalEntries and only return the `id`
     * const journalEntryWithIdOnly = await prisma.journalEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JournalEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, JournalEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JournalEntry.
     * @param {JournalEntryUpsertArgs} args - Arguments to update or create a JournalEntry.
     * @example
     * // Update or create a JournalEntry
     * const journalEntry = await prisma.journalEntry.upsert({
     *   create: {
     *     // ... data to create a JournalEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JournalEntry we want to update
     *   }
     * })
     */
    upsert<T extends JournalEntryUpsertArgs>(args: SelectSubset<T, JournalEntryUpsertArgs<ExtArgs>>): Prisma__JournalEntryClient<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JournalEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryCountArgs} args - Arguments to filter JournalEntries to count.
     * @example
     * // Count the number of JournalEntries
     * const count = await prisma.journalEntry.count({
     *   where: {
     *     // ... the filter for the JournalEntries we want to count
     *   }
     * })
    **/
    count<T extends JournalEntryCountArgs>(
      args?: Subset<T, JournalEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JournalEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JournalEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JournalEntryAggregateArgs>(args: Subset<T, JournalEntryAggregateArgs>): Prisma.PrismaPromise<GetJournalEntryAggregateType<T>>

    /**
     * Group by JournalEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JournalEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JournalEntryGroupByArgs['orderBy'] }
        : { orderBy?: JournalEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JournalEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJournalEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JournalEntry model
   */
  readonly fields: JournalEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JournalEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JournalEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JournalEntry model
   */
  interface JournalEntryFieldRefs {
    readonly id: FieldRef<"JournalEntry", 'String'>
    readonly userId: FieldRef<"JournalEntry", 'String'>
    readonly date: FieldRef<"JournalEntry", 'DateTime'>
    readonly category: FieldRef<"JournalEntry", 'JournalCategory'>
    readonly content: FieldRef<"JournalEntry", 'String'>
    readonly createdAt: FieldRef<"JournalEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"JournalEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JournalEntry findUnique
   */
  export type JournalEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntry to fetch.
     */
    where: JournalEntryWhereUniqueInput
  }

  /**
   * JournalEntry findUniqueOrThrow
   */
  export type JournalEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntry to fetch.
     */
    where: JournalEntryWhereUniqueInput
  }

  /**
   * JournalEntry findFirst
   */
  export type JournalEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntry to fetch.
     */
    where?: JournalEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalEntries to fetch.
     */
    orderBy?: JournalEntryOrderByWithRelationInput | JournalEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalEntries.
     */
    cursor?: JournalEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalEntries.
     */
    distinct?: JournalEntryScalarFieldEnum | JournalEntryScalarFieldEnum[]
  }

  /**
   * JournalEntry findFirstOrThrow
   */
  export type JournalEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntry to fetch.
     */
    where?: JournalEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalEntries to fetch.
     */
    orderBy?: JournalEntryOrderByWithRelationInput | JournalEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalEntries.
     */
    cursor?: JournalEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalEntries.
     */
    distinct?: JournalEntryScalarFieldEnum | JournalEntryScalarFieldEnum[]
  }

  /**
   * JournalEntry findMany
   */
  export type JournalEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter, which JournalEntries to fetch.
     */
    where?: JournalEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalEntries to fetch.
     */
    orderBy?: JournalEntryOrderByWithRelationInput | JournalEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JournalEntries.
     */
    cursor?: JournalEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalEntries.
     */
    skip?: number
    distinct?: JournalEntryScalarFieldEnum | JournalEntryScalarFieldEnum[]
  }

  /**
   * JournalEntry create
   */
  export type JournalEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a JournalEntry.
     */
    data: XOR<JournalEntryCreateInput, JournalEntryUncheckedCreateInput>
  }

  /**
   * JournalEntry createMany
   */
  export type JournalEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JournalEntries.
     */
    data: JournalEntryCreateManyInput | JournalEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JournalEntry createManyAndReturn
   */
  export type JournalEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * The data used to create many JournalEntries.
     */
    data: JournalEntryCreateManyInput | JournalEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalEntry update
   */
  export type JournalEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a JournalEntry.
     */
    data: XOR<JournalEntryUpdateInput, JournalEntryUncheckedUpdateInput>
    /**
     * Choose, which JournalEntry to update.
     */
    where: JournalEntryWhereUniqueInput
  }

  /**
   * JournalEntry updateMany
   */
  export type JournalEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JournalEntries.
     */
    data: XOR<JournalEntryUpdateManyMutationInput, JournalEntryUncheckedUpdateManyInput>
    /**
     * Filter which JournalEntries to update
     */
    where?: JournalEntryWhereInput
    /**
     * Limit how many JournalEntries to update.
     */
    limit?: number
  }

  /**
   * JournalEntry updateManyAndReturn
   */
  export type JournalEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * The data used to update JournalEntries.
     */
    data: XOR<JournalEntryUpdateManyMutationInput, JournalEntryUncheckedUpdateManyInput>
    /**
     * Filter which JournalEntries to update
     */
    where?: JournalEntryWhereInput
    /**
     * Limit how many JournalEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JournalEntry upsert
   */
  export type JournalEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the JournalEntry to update in case it exists.
     */
    where: JournalEntryWhereUniqueInput
    /**
     * In case the JournalEntry found by the `where` argument doesn't exist, create a new JournalEntry with this data.
     */
    create: XOR<JournalEntryCreateInput, JournalEntryUncheckedCreateInput>
    /**
     * In case the JournalEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JournalEntryUpdateInput, JournalEntryUncheckedUpdateInput>
  }

  /**
   * JournalEntry delete
   */
  export type JournalEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    /**
     * Filter which JournalEntry to delete.
     */
    where: JournalEntryWhereUniqueInput
  }

  /**
   * JournalEntry deleteMany
   */
  export type JournalEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalEntries to delete
     */
    where?: JournalEntryWhereInput
    /**
     * Limit how many JournalEntries to delete.
     */
    limit?: number
  }

  /**
   * JournalEntry without action
   */
  export type JournalEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    entity: number
    entityId: number
    oldData: number
    newData: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    oldData?: true
    newData?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string | null
    action: string
    entity: string
    entityId: string | null
    oldData: JsonValue | null
    newData: JsonValue | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    oldData?: boolean
    newData?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    oldData?: boolean
    newData?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    oldData?: boolean
    newData?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    oldData?: boolean
    newData?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "entity" | "entityId" | "oldData" | "newData" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      action: string
      entity: string
      entityId: string | null
      oldData: Prisma.JsonValue | null
      newData: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entity: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly oldData: FieldRef<"AuditLog", 'Json'>
    readonly newData: FieldRef<"AuditLog", 'Json'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model Log
   */

  export type AggregateLog = {
    _count: LogCountAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  export type LogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    eventType: $Enums.EventType | null
    description: string | null
    timestamp: Date | null
  }

  export type LogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    eventType: $Enums.EventType | null
    description: string | null
    timestamp: Date | null
  }

  export type LogCountAggregateOutputType = {
    id: number
    userId: number
    eventType: number
    description: number
    timestamp: number
    metadata: number
    _all: number
  }


  export type LogMinAggregateInputType = {
    id?: true
    userId?: true
    eventType?: true
    description?: true
    timestamp?: true
  }

  export type LogMaxAggregateInputType = {
    id?: true
    userId?: true
    eventType?: true
    description?: true
    timestamp?: true
  }

  export type LogCountAggregateInputType = {
    id?: true
    userId?: true
    eventType?: true
    description?: true
    timestamp?: true
    metadata?: true
    _all?: true
  }

  export type LogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Log to aggregate.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Logs
    **/
    _count?: true | LogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogMaxAggregateInputType
  }

  export type GetLogAggregateType<T extends LogAggregateArgs> = {
        [P in keyof T & keyof AggregateLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLog[P]>
      : GetScalarType<T[P], AggregateLog[P]>
  }




  export type LogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogWhereInput
    orderBy?: LogOrderByWithAggregationInput | LogOrderByWithAggregationInput[]
    by: LogScalarFieldEnum[] | LogScalarFieldEnum
    having?: LogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogCountAggregateInputType | true
    _min?: LogMinAggregateInputType
    _max?: LogMaxAggregateInputType
  }

  export type LogGroupByOutputType = {
    id: string
    userId: string | null
    eventType: $Enums.EventType
    description: string | null
    timestamp: Date
    metadata: JsonValue | null
    _count: LogCountAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  type GetLogGroupByPayload<T extends LogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogGroupByOutputType[P]>
            : GetScalarType<T[P], LogGroupByOutputType[P]>
        }
      >
    >


  export type LogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    eventType?: boolean
    description?: boolean
    timestamp?: boolean
    metadata?: boolean
    user?: boolean | Log$userArgs<ExtArgs>
  }, ExtArgs["result"]["log"]>

  export type LogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    eventType?: boolean
    description?: boolean
    timestamp?: boolean
    metadata?: boolean
    user?: boolean | Log$userArgs<ExtArgs>
  }, ExtArgs["result"]["log"]>

  export type LogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    eventType?: boolean
    description?: boolean
    timestamp?: boolean
    metadata?: boolean
    user?: boolean | Log$userArgs<ExtArgs>
  }, ExtArgs["result"]["log"]>

  export type LogSelectScalar = {
    id?: boolean
    userId?: boolean
    eventType?: boolean
    description?: boolean
    timestamp?: boolean
    metadata?: boolean
  }

  export type LogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "eventType" | "description" | "timestamp" | "metadata", ExtArgs["result"]["log"]>
  export type LogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Log$userArgs<ExtArgs>
  }
  export type LogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Log$userArgs<ExtArgs>
  }
  export type LogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Log$userArgs<ExtArgs>
  }

  export type $LogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Log"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      eventType: $Enums.EventType
      description: string | null
      timestamp: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["log"]>
    composites: {}
  }

  type LogGetPayload<S extends boolean | null | undefined | LogDefaultArgs> = $Result.GetResult<Prisma.$LogPayload, S>

  type LogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LogCountAggregateInputType | true
    }

  export interface LogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Log'], meta: { name: 'Log' } }
    /**
     * Find zero or one Log that matches the filter.
     * @param {LogFindUniqueArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LogFindUniqueArgs>(args: SelectSubset<T, LogFindUniqueArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Log that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LogFindUniqueOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LogFindUniqueOrThrowArgs>(args: SelectSubset<T, LogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindFirstArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LogFindFirstArgs>(args?: SelectSubset<T, LogFindFirstArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Log that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindFirstOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LogFindFirstOrThrowArgs>(args?: SelectSubset<T, LogFindFirstOrThrowArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logs
     * const logs = await prisma.log.findMany()
     * 
     * // Get first 10 Logs
     * const logs = await prisma.log.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logWithIdOnly = await prisma.log.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LogFindManyArgs>(args?: SelectSubset<T, LogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Log.
     * @param {LogCreateArgs} args - Arguments to create a Log.
     * @example
     * // Create one Log
     * const Log = await prisma.log.create({
     *   data: {
     *     // ... data to create a Log
     *   }
     * })
     * 
     */
    create<T extends LogCreateArgs>(args: SelectSubset<T, LogCreateArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Logs.
     * @param {LogCreateManyArgs} args - Arguments to create many Logs.
     * @example
     * // Create many Logs
     * const log = await prisma.log.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LogCreateManyArgs>(args?: SelectSubset<T, LogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Logs and returns the data saved in the database.
     * @param {LogCreateManyAndReturnArgs} args - Arguments to create many Logs.
     * @example
     * // Create many Logs
     * const log = await prisma.log.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Logs and only return the `id`
     * const logWithIdOnly = await prisma.log.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LogCreateManyAndReturnArgs>(args?: SelectSubset<T, LogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Log.
     * @param {LogDeleteArgs} args - Arguments to delete one Log.
     * @example
     * // Delete one Log
     * const Log = await prisma.log.delete({
     *   where: {
     *     // ... filter to delete one Log
     *   }
     * })
     * 
     */
    delete<T extends LogDeleteArgs>(args: SelectSubset<T, LogDeleteArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Log.
     * @param {LogUpdateArgs} args - Arguments to update one Log.
     * @example
     * // Update one Log
     * const log = await prisma.log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LogUpdateArgs>(args: SelectSubset<T, LogUpdateArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Logs.
     * @param {LogDeleteManyArgs} args - Arguments to filter Logs to delete.
     * @example
     * // Delete a few Logs
     * const { count } = await prisma.log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LogDeleteManyArgs>(args?: SelectSubset<T, LogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logs
     * const log = await prisma.log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LogUpdateManyArgs>(args: SelectSubset<T, LogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs and returns the data updated in the database.
     * @param {LogUpdateManyAndReturnArgs} args - Arguments to update many Logs.
     * @example
     * // Update many Logs
     * const log = await prisma.log.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Logs and only return the `id`
     * const logWithIdOnly = await prisma.log.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LogUpdateManyAndReturnArgs>(args: SelectSubset<T, LogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Log.
     * @param {LogUpsertArgs} args - Arguments to update or create a Log.
     * @example
     * // Update or create a Log
     * const log = await prisma.log.upsert({
     *   create: {
     *     // ... data to create a Log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Log we want to update
     *   }
     * })
     */
    upsert<T extends LogUpsertArgs>(args: SelectSubset<T, LogUpsertArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogCountArgs} args - Arguments to filter Logs to count.
     * @example
     * // Count the number of Logs
     * const count = await prisma.log.count({
     *   where: {
     *     // ... the filter for the Logs we want to count
     *   }
     * })
    **/
    count<T extends LogCountArgs>(
      args?: Subset<T, LogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogAggregateArgs>(args: Subset<T, LogAggregateArgs>): Prisma.PrismaPromise<GetLogAggregateType<T>>

    /**
     * Group by Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogGroupByArgs['orderBy'] }
        : { orderBy?: LogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Log model
   */
  readonly fields: LogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Log$userArgs<ExtArgs> = {}>(args?: Subset<T, Log$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Log model
   */
  interface LogFieldRefs {
    readonly id: FieldRef<"Log", 'String'>
    readonly userId: FieldRef<"Log", 'String'>
    readonly eventType: FieldRef<"Log", 'EventType'>
    readonly description: FieldRef<"Log", 'String'>
    readonly timestamp: FieldRef<"Log", 'DateTime'>
    readonly metadata: FieldRef<"Log", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Log findUnique
   */
  export type LogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log findUniqueOrThrow
   */
  export type LogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log findFirst
   */
  export type LogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log findFirstOrThrow
   */
  export type LogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log findMany
   */
  export type LogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log create
   */
  export type LogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The data needed to create a Log.
     */
    data: XOR<LogCreateInput, LogUncheckedCreateInput>
  }

  /**
   * Log createMany
   */
  export type LogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Logs.
     */
    data: LogCreateManyInput | LogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Log createManyAndReturn
   */
  export type LogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * The data used to create many Logs.
     */
    data: LogCreateManyInput | LogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Log update
   */
  export type LogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The data needed to update a Log.
     */
    data: XOR<LogUpdateInput, LogUncheckedUpdateInput>
    /**
     * Choose, which Log to update.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log updateMany
   */
  export type LogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Logs.
     */
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyInput>
    /**
     * Filter which Logs to update
     */
    where?: LogWhereInput
    /**
     * Limit how many Logs to update.
     */
    limit?: number
  }

  /**
   * Log updateManyAndReturn
   */
  export type LogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * The data used to update Logs.
     */
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyInput>
    /**
     * Filter which Logs to update
     */
    where?: LogWhereInput
    /**
     * Limit how many Logs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Log upsert
   */
  export type LogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The filter to search for the Log to update in case it exists.
     */
    where: LogWhereUniqueInput
    /**
     * In case the Log found by the `where` argument doesn't exist, create a new Log with this data.
     */
    create: XOR<LogCreateInput, LogUncheckedCreateInput>
    /**
     * In case the Log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogUpdateInput, LogUncheckedUpdateInput>
  }

  /**
   * Log delete
   */
  export type LogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter which Log to delete.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log deleteMany
   */
  export type LogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Logs to delete
     */
    where?: LogWhereInput
    /**
     * Limit how many Logs to delete.
     */
    limit?: number
  }

  /**
   * Log.user
   */
  export type Log$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Log without action
   */
  export type LogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: string | null
    userId: string | null
    tokenHash: string | null
    expiresAt: Date | null
    revoked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    tokenHash: string | null
    expiresAt: Date | null
    revoked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    userId: number
    tokenHash: number
    expiresAt: number
    revoked: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RefreshTokenMinAggregateInputType = {
    id?: true
    userId?: true
    tokenHash?: true
    expiresAt?: true
    revoked?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    tokenHash?: true
    expiresAt?: true
    revoked?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    userId?: true
    tokenHash?: true
    expiresAt?: true
    revoked?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: string
    userId: string
    tokenHash: string
    expiresAt: Date
    revoked: boolean
    createdAt: Date
    updatedAt: Date
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenHash?: boolean
    expiresAt?: boolean
    revoked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenHash?: boolean
    expiresAt?: boolean
    revoked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenHash?: boolean
    expiresAt?: boolean
    revoked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    tokenHash?: boolean
    expiresAt?: boolean
    revoked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RefreshTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "tokenHash" | "expiresAt" | "revoked" | "createdAt" | "updatedAt", ExtArgs["result"]["refreshToken"]>
  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      tokenHash: string
      expiresAt: Date
      revoked: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens and returns the data updated in the database.
     * @param {RefreshTokenUpdateManyAndReturnArgs} args - Arguments to update many RefreshTokens.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RefreshTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, RefreshTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'String'>
    readonly userId: FieldRef<"RefreshToken", 'String'>
    readonly tokenHash: FieldRef<"RefreshToken", 'String'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly revoked: FieldRef<"RefreshToken", 'Boolean'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly updatedAt: FieldRef<"RefreshToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
  }

  /**
   * RefreshToken updateManyAndReturn
   */
  export type RefreshTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to delete.
     */
    limit?: number
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Model AuthSession
   */

  export type AggregateAuthSession = {
    _count: AuthSessionCountAggregateOutputType | null
    _min: AuthSessionMinAggregateOutputType | null
    _max: AuthSessionMaxAggregateOutputType | null
  }

  export type AuthSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    userAgent: string | null
    ipAddress: string | null
    lastSeen: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuthSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    userAgent: string | null
    ipAddress: string | null
    lastSeen: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuthSessionCountAggregateOutputType = {
    id: number
    userId: number
    userAgent: number
    ipAddress: number
    lastSeen: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AuthSessionMinAggregateInputType = {
    id?: true
    userId?: true
    userAgent?: true
    ipAddress?: true
    lastSeen?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuthSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    userAgent?: true
    ipAddress?: true
    lastSeen?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuthSessionCountAggregateInputType = {
    id?: true
    userId?: true
    userAgent?: true
    ipAddress?: true
    lastSeen?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AuthSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuthSession to aggregate.
     */
    where?: AuthSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthSessions to fetch.
     */
    orderBy?: AuthSessionOrderByWithRelationInput | AuthSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuthSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuthSessions
    **/
    _count?: true | AuthSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuthSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuthSessionMaxAggregateInputType
  }

  export type GetAuthSessionAggregateType<T extends AuthSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateAuthSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthSession[P]>
      : GetScalarType<T[P], AggregateAuthSession[P]>
  }




  export type AuthSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthSessionWhereInput
    orderBy?: AuthSessionOrderByWithAggregationInput | AuthSessionOrderByWithAggregationInput[]
    by: AuthSessionScalarFieldEnum[] | AuthSessionScalarFieldEnum
    having?: AuthSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuthSessionCountAggregateInputType | true
    _min?: AuthSessionMinAggregateInputType
    _max?: AuthSessionMaxAggregateInputType
  }

  export type AuthSessionGroupByOutputType = {
    id: string
    userId: string
    userAgent: string | null
    ipAddress: string | null
    lastSeen: Date
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: AuthSessionCountAggregateOutputType | null
    _min: AuthSessionMinAggregateOutputType | null
    _max: AuthSessionMaxAggregateOutputType | null
  }

  type GetAuthSessionGroupByPayload<T extends AuthSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuthSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuthSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuthSessionGroupByOutputType[P]>
            : GetScalarType<T[P], AuthSessionGroupByOutputType[P]>
        }
      >
    >


  export type AuthSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    lastSeen?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["authSession"]>

  export type AuthSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    lastSeen?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["authSession"]>

  export type AuthSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    lastSeen?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["authSession"]>

  export type AuthSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    lastSeen?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AuthSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "userAgent" | "ipAddress" | "lastSeen" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["authSession"]>
  export type AuthSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuthSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuthSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuthSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuthSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      userAgent: string | null
      ipAddress: string | null
      lastSeen: Date
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["authSession"]>
    composites: {}
  }

  type AuthSessionGetPayload<S extends boolean | null | undefined | AuthSessionDefaultArgs> = $Result.GetResult<Prisma.$AuthSessionPayload, S>

  type AuthSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuthSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuthSessionCountAggregateInputType | true
    }

  export interface AuthSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuthSession'], meta: { name: 'AuthSession' } }
    /**
     * Find zero or one AuthSession that matches the filter.
     * @param {AuthSessionFindUniqueArgs} args - Arguments to find a AuthSession
     * @example
     * // Get one AuthSession
     * const authSession = await prisma.authSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuthSessionFindUniqueArgs>(args: SelectSubset<T, AuthSessionFindUniqueArgs<ExtArgs>>): Prisma__AuthSessionClient<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuthSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuthSessionFindUniqueOrThrowArgs} args - Arguments to find a AuthSession
     * @example
     * // Get one AuthSession
     * const authSession = await prisma.authSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuthSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, AuthSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuthSessionClient<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuthSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthSessionFindFirstArgs} args - Arguments to find a AuthSession
     * @example
     * // Get one AuthSession
     * const authSession = await prisma.authSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuthSessionFindFirstArgs>(args?: SelectSubset<T, AuthSessionFindFirstArgs<ExtArgs>>): Prisma__AuthSessionClient<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuthSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthSessionFindFirstOrThrowArgs} args - Arguments to find a AuthSession
     * @example
     * // Get one AuthSession
     * const authSession = await prisma.authSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuthSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, AuthSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuthSessionClient<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuthSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuthSessions
     * const authSessions = await prisma.authSession.findMany()
     * 
     * // Get first 10 AuthSessions
     * const authSessions = await prisma.authSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const authSessionWithIdOnly = await prisma.authSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuthSessionFindManyArgs>(args?: SelectSubset<T, AuthSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuthSession.
     * @param {AuthSessionCreateArgs} args - Arguments to create a AuthSession.
     * @example
     * // Create one AuthSession
     * const AuthSession = await prisma.authSession.create({
     *   data: {
     *     // ... data to create a AuthSession
     *   }
     * })
     * 
     */
    create<T extends AuthSessionCreateArgs>(args: SelectSubset<T, AuthSessionCreateArgs<ExtArgs>>): Prisma__AuthSessionClient<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuthSessions.
     * @param {AuthSessionCreateManyArgs} args - Arguments to create many AuthSessions.
     * @example
     * // Create many AuthSessions
     * const authSession = await prisma.authSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuthSessionCreateManyArgs>(args?: SelectSubset<T, AuthSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuthSessions and returns the data saved in the database.
     * @param {AuthSessionCreateManyAndReturnArgs} args - Arguments to create many AuthSessions.
     * @example
     * // Create many AuthSessions
     * const authSession = await prisma.authSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuthSessions and only return the `id`
     * const authSessionWithIdOnly = await prisma.authSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuthSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, AuthSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuthSession.
     * @param {AuthSessionDeleteArgs} args - Arguments to delete one AuthSession.
     * @example
     * // Delete one AuthSession
     * const AuthSession = await prisma.authSession.delete({
     *   where: {
     *     // ... filter to delete one AuthSession
     *   }
     * })
     * 
     */
    delete<T extends AuthSessionDeleteArgs>(args: SelectSubset<T, AuthSessionDeleteArgs<ExtArgs>>): Prisma__AuthSessionClient<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuthSession.
     * @param {AuthSessionUpdateArgs} args - Arguments to update one AuthSession.
     * @example
     * // Update one AuthSession
     * const authSession = await prisma.authSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuthSessionUpdateArgs>(args: SelectSubset<T, AuthSessionUpdateArgs<ExtArgs>>): Prisma__AuthSessionClient<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuthSessions.
     * @param {AuthSessionDeleteManyArgs} args - Arguments to filter AuthSessions to delete.
     * @example
     * // Delete a few AuthSessions
     * const { count } = await prisma.authSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuthSessionDeleteManyArgs>(args?: SelectSubset<T, AuthSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuthSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuthSessions
     * const authSession = await prisma.authSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuthSessionUpdateManyArgs>(args: SelectSubset<T, AuthSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuthSessions and returns the data updated in the database.
     * @param {AuthSessionUpdateManyAndReturnArgs} args - Arguments to update many AuthSessions.
     * @example
     * // Update many AuthSessions
     * const authSession = await prisma.authSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuthSessions and only return the `id`
     * const authSessionWithIdOnly = await prisma.authSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuthSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, AuthSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuthSession.
     * @param {AuthSessionUpsertArgs} args - Arguments to update or create a AuthSession.
     * @example
     * // Update or create a AuthSession
     * const authSession = await prisma.authSession.upsert({
     *   create: {
     *     // ... data to create a AuthSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuthSession we want to update
     *   }
     * })
     */
    upsert<T extends AuthSessionUpsertArgs>(args: SelectSubset<T, AuthSessionUpsertArgs<ExtArgs>>): Prisma__AuthSessionClient<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuthSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthSessionCountArgs} args - Arguments to filter AuthSessions to count.
     * @example
     * // Count the number of AuthSessions
     * const count = await prisma.authSession.count({
     *   where: {
     *     // ... the filter for the AuthSessions we want to count
     *   }
     * })
    **/
    count<T extends AuthSessionCountArgs>(
      args?: Subset<T, AuthSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuthSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthSessionAggregateArgs>(args: Subset<T, AuthSessionAggregateArgs>): Prisma.PrismaPromise<GetAuthSessionAggregateType<T>>

    /**
     * Group by AuthSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuthSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuthSessionGroupByArgs['orderBy'] }
        : { orderBy?: AuthSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuthSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuthSession model
   */
  readonly fields: AuthSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuthSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuthSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuthSession model
   */
  interface AuthSessionFieldRefs {
    readonly id: FieldRef<"AuthSession", 'String'>
    readonly userId: FieldRef<"AuthSession", 'String'>
    readonly userAgent: FieldRef<"AuthSession", 'String'>
    readonly ipAddress: FieldRef<"AuthSession", 'String'>
    readonly lastSeen: FieldRef<"AuthSession", 'DateTime'>
    readonly isActive: FieldRef<"AuthSession", 'Boolean'>
    readonly createdAt: FieldRef<"AuthSession", 'DateTime'>
    readonly updatedAt: FieldRef<"AuthSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuthSession findUnique
   */
  export type AuthSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
    /**
     * Filter, which AuthSession to fetch.
     */
    where: AuthSessionWhereUniqueInput
  }

  /**
   * AuthSession findUniqueOrThrow
   */
  export type AuthSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
    /**
     * Filter, which AuthSession to fetch.
     */
    where: AuthSessionWhereUniqueInput
  }

  /**
   * AuthSession findFirst
   */
  export type AuthSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
    /**
     * Filter, which AuthSession to fetch.
     */
    where?: AuthSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthSessions to fetch.
     */
    orderBy?: AuthSessionOrderByWithRelationInput | AuthSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuthSessions.
     */
    cursor?: AuthSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuthSessions.
     */
    distinct?: AuthSessionScalarFieldEnum | AuthSessionScalarFieldEnum[]
  }

  /**
   * AuthSession findFirstOrThrow
   */
  export type AuthSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
    /**
     * Filter, which AuthSession to fetch.
     */
    where?: AuthSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthSessions to fetch.
     */
    orderBy?: AuthSessionOrderByWithRelationInput | AuthSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuthSessions.
     */
    cursor?: AuthSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuthSessions.
     */
    distinct?: AuthSessionScalarFieldEnum | AuthSessionScalarFieldEnum[]
  }

  /**
   * AuthSession findMany
   */
  export type AuthSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
    /**
     * Filter, which AuthSessions to fetch.
     */
    where?: AuthSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthSessions to fetch.
     */
    orderBy?: AuthSessionOrderByWithRelationInput | AuthSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuthSessions.
     */
    cursor?: AuthSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthSessions.
     */
    skip?: number
    distinct?: AuthSessionScalarFieldEnum | AuthSessionScalarFieldEnum[]
  }

  /**
   * AuthSession create
   */
  export type AuthSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a AuthSession.
     */
    data: XOR<AuthSessionCreateInput, AuthSessionUncheckedCreateInput>
  }

  /**
   * AuthSession createMany
   */
  export type AuthSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuthSessions.
     */
    data: AuthSessionCreateManyInput | AuthSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuthSession createManyAndReturn
   */
  export type AuthSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * The data used to create many AuthSessions.
     */
    data: AuthSessionCreateManyInput | AuthSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuthSession update
   */
  export type AuthSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a AuthSession.
     */
    data: XOR<AuthSessionUpdateInput, AuthSessionUncheckedUpdateInput>
    /**
     * Choose, which AuthSession to update.
     */
    where: AuthSessionWhereUniqueInput
  }

  /**
   * AuthSession updateMany
   */
  export type AuthSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuthSessions.
     */
    data: XOR<AuthSessionUpdateManyMutationInput, AuthSessionUncheckedUpdateManyInput>
    /**
     * Filter which AuthSessions to update
     */
    where?: AuthSessionWhereInput
    /**
     * Limit how many AuthSessions to update.
     */
    limit?: number
  }

  /**
   * AuthSession updateManyAndReturn
   */
  export type AuthSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * The data used to update AuthSessions.
     */
    data: XOR<AuthSessionUpdateManyMutationInput, AuthSessionUncheckedUpdateManyInput>
    /**
     * Filter which AuthSessions to update
     */
    where?: AuthSessionWhereInput
    /**
     * Limit how many AuthSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuthSession upsert
   */
  export type AuthSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the AuthSession to update in case it exists.
     */
    where: AuthSessionWhereUniqueInput
    /**
     * In case the AuthSession found by the `where` argument doesn't exist, create a new AuthSession with this data.
     */
    create: XOR<AuthSessionCreateInput, AuthSessionUncheckedCreateInput>
    /**
     * In case the AuthSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuthSessionUpdateInput, AuthSessionUncheckedUpdateInput>
  }

  /**
   * AuthSession delete
   */
  export type AuthSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
    /**
     * Filter which AuthSession to delete.
     */
    where: AuthSessionWhereUniqueInput
  }

  /**
   * AuthSession deleteMany
   */
  export type AuthSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuthSessions to delete
     */
    where?: AuthSessionWhereInput
    /**
     * Limit how many AuthSessions to delete.
     */
    limit?: number
  }

  /**
   * AuthSession without action
   */
  export type AuthSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
  }


  /**
   * Model MoodTrack
   */

  export type AggregateMoodTrack = {
    _count: MoodTrackCountAggregateOutputType | null
    _min: MoodTrackMinAggregateOutputType | null
    _max: MoodTrackMaxAggregateOutputType | null
  }

  export type MoodTrackMinAggregateOutputType = {
    id: string | null
    userId: string | null
    date: Date | null
    mood: $Enums.MoodType | null
    energy: $Enums.EnergyLevel | null
    pain: $Enums.PainLevel | null
    stress: $Enums.StressLevel | null
    sleepQuality: $Enums.SleepQuality | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MoodTrackMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    date: Date | null
    mood: $Enums.MoodType | null
    energy: $Enums.EnergyLevel | null
    pain: $Enums.PainLevel | null
    stress: $Enums.StressLevel | null
    sleepQuality: $Enums.SleepQuality | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MoodTrackCountAggregateOutputType = {
    id: number
    userId: number
    date: number
    mood: number
    energy: number
    pain: number
    stress: number
    sleepQuality: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MoodTrackMinAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    mood?: true
    energy?: true
    pain?: true
    stress?: true
    sleepQuality?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MoodTrackMaxAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    mood?: true
    energy?: true
    pain?: true
    stress?: true
    sleepQuality?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MoodTrackCountAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    mood?: true
    energy?: true
    pain?: true
    stress?: true
    sleepQuality?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MoodTrackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MoodTrack to aggregate.
     */
    where?: MoodTrackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MoodTracks to fetch.
     */
    orderBy?: MoodTrackOrderByWithRelationInput | MoodTrackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MoodTrackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MoodTracks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MoodTracks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MoodTracks
    **/
    _count?: true | MoodTrackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MoodTrackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MoodTrackMaxAggregateInputType
  }

  export type GetMoodTrackAggregateType<T extends MoodTrackAggregateArgs> = {
        [P in keyof T & keyof AggregateMoodTrack]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMoodTrack[P]>
      : GetScalarType<T[P], AggregateMoodTrack[P]>
  }




  export type MoodTrackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MoodTrackWhereInput
    orderBy?: MoodTrackOrderByWithAggregationInput | MoodTrackOrderByWithAggregationInput[]
    by: MoodTrackScalarFieldEnum[] | MoodTrackScalarFieldEnum
    having?: MoodTrackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MoodTrackCountAggregateInputType | true
    _min?: MoodTrackMinAggregateInputType
    _max?: MoodTrackMaxAggregateInputType
  }

  export type MoodTrackGroupByOutputType = {
    id: string
    userId: string
    date: Date
    mood: $Enums.MoodType | null
    energy: $Enums.EnergyLevel | null
    pain: $Enums.PainLevel | null
    stress: $Enums.StressLevel | null
    sleepQuality: $Enums.SleepQuality | null
    createdAt: Date
    updatedAt: Date
    _count: MoodTrackCountAggregateOutputType | null
    _min: MoodTrackMinAggregateOutputType | null
    _max: MoodTrackMaxAggregateOutputType | null
  }

  type GetMoodTrackGroupByPayload<T extends MoodTrackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MoodTrackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MoodTrackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MoodTrackGroupByOutputType[P]>
            : GetScalarType<T[P], MoodTrackGroupByOutputType[P]>
        }
      >
    >


  export type MoodTrackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    mood?: boolean
    energy?: boolean
    pain?: boolean
    stress?: boolean
    sleepQuality?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moodTrack"]>

  export type MoodTrackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    mood?: boolean
    energy?: boolean
    pain?: boolean
    stress?: boolean
    sleepQuality?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moodTrack"]>

  export type MoodTrackSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    mood?: boolean
    energy?: boolean
    pain?: boolean
    stress?: boolean
    sleepQuality?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moodTrack"]>

  export type MoodTrackSelectScalar = {
    id?: boolean
    userId?: boolean
    date?: boolean
    mood?: boolean
    energy?: boolean
    pain?: boolean
    stress?: boolean
    sleepQuality?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MoodTrackOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "date" | "mood" | "energy" | "pain" | "stress" | "sleepQuality" | "createdAt" | "updatedAt", ExtArgs["result"]["moodTrack"]>
  export type MoodTrackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MoodTrackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MoodTrackIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MoodTrackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MoodTrack"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      date: Date
      mood: $Enums.MoodType | null
      energy: $Enums.EnergyLevel | null
      pain: $Enums.PainLevel | null
      stress: $Enums.StressLevel | null
      sleepQuality: $Enums.SleepQuality | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["moodTrack"]>
    composites: {}
  }

  type MoodTrackGetPayload<S extends boolean | null | undefined | MoodTrackDefaultArgs> = $Result.GetResult<Prisma.$MoodTrackPayload, S>

  type MoodTrackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MoodTrackFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MoodTrackCountAggregateInputType | true
    }

  export interface MoodTrackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MoodTrack'], meta: { name: 'MoodTrack' } }
    /**
     * Find zero or one MoodTrack that matches the filter.
     * @param {MoodTrackFindUniqueArgs} args - Arguments to find a MoodTrack
     * @example
     * // Get one MoodTrack
     * const moodTrack = await prisma.moodTrack.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MoodTrackFindUniqueArgs>(args: SelectSubset<T, MoodTrackFindUniqueArgs<ExtArgs>>): Prisma__MoodTrackClient<$Result.GetResult<Prisma.$MoodTrackPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MoodTrack that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MoodTrackFindUniqueOrThrowArgs} args - Arguments to find a MoodTrack
     * @example
     * // Get one MoodTrack
     * const moodTrack = await prisma.moodTrack.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MoodTrackFindUniqueOrThrowArgs>(args: SelectSubset<T, MoodTrackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MoodTrackClient<$Result.GetResult<Prisma.$MoodTrackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MoodTrack that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodTrackFindFirstArgs} args - Arguments to find a MoodTrack
     * @example
     * // Get one MoodTrack
     * const moodTrack = await prisma.moodTrack.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MoodTrackFindFirstArgs>(args?: SelectSubset<T, MoodTrackFindFirstArgs<ExtArgs>>): Prisma__MoodTrackClient<$Result.GetResult<Prisma.$MoodTrackPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MoodTrack that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodTrackFindFirstOrThrowArgs} args - Arguments to find a MoodTrack
     * @example
     * // Get one MoodTrack
     * const moodTrack = await prisma.moodTrack.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MoodTrackFindFirstOrThrowArgs>(args?: SelectSubset<T, MoodTrackFindFirstOrThrowArgs<ExtArgs>>): Prisma__MoodTrackClient<$Result.GetResult<Prisma.$MoodTrackPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MoodTracks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodTrackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MoodTracks
     * const moodTracks = await prisma.moodTrack.findMany()
     * 
     * // Get first 10 MoodTracks
     * const moodTracks = await prisma.moodTrack.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moodTrackWithIdOnly = await prisma.moodTrack.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MoodTrackFindManyArgs>(args?: SelectSubset<T, MoodTrackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoodTrackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MoodTrack.
     * @param {MoodTrackCreateArgs} args - Arguments to create a MoodTrack.
     * @example
     * // Create one MoodTrack
     * const MoodTrack = await prisma.moodTrack.create({
     *   data: {
     *     // ... data to create a MoodTrack
     *   }
     * })
     * 
     */
    create<T extends MoodTrackCreateArgs>(args: SelectSubset<T, MoodTrackCreateArgs<ExtArgs>>): Prisma__MoodTrackClient<$Result.GetResult<Prisma.$MoodTrackPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MoodTracks.
     * @param {MoodTrackCreateManyArgs} args - Arguments to create many MoodTracks.
     * @example
     * // Create many MoodTracks
     * const moodTrack = await prisma.moodTrack.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MoodTrackCreateManyArgs>(args?: SelectSubset<T, MoodTrackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MoodTracks and returns the data saved in the database.
     * @param {MoodTrackCreateManyAndReturnArgs} args - Arguments to create many MoodTracks.
     * @example
     * // Create many MoodTracks
     * const moodTrack = await prisma.moodTrack.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MoodTracks and only return the `id`
     * const moodTrackWithIdOnly = await prisma.moodTrack.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MoodTrackCreateManyAndReturnArgs>(args?: SelectSubset<T, MoodTrackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoodTrackPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MoodTrack.
     * @param {MoodTrackDeleteArgs} args - Arguments to delete one MoodTrack.
     * @example
     * // Delete one MoodTrack
     * const MoodTrack = await prisma.moodTrack.delete({
     *   where: {
     *     // ... filter to delete one MoodTrack
     *   }
     * })
     * 
     */
    delete<T extends MoodTrackDeleteArgs>(args: SelectSubset<T, MoodTrackDeleteArgs<ExtArgs>>): Prisma__MoodTrackClient<$Result.GetResult<Prisma.$MoodTrackPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MoodTrack.
     * @param {MoodTrackUpdateArgs} args - Arguments to update one MoodTrack.
     * @example
     * // Update one MoodTrack
     * const moodTrack = await prisma.moodTrack.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MoodTrackUpdateArgs>(args: SelectSubset<T, MoodTrackUpdateArgs<ExtArgs>>): Prisma__MoodTrackClient<$Result.GetResult<Prisma.$MoodTrackPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MoodTracks.
     * @param {MoodTrackDeleteManyArgs} args - Arguments to filter MoodTracks to delete.
     * @example
     * // Delete a few MoodTracks
     * const { count } = await prisma.moodTrack.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MoodTrackDeleteManyArgs>(args?: SelectSubset<T, MoodTrackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MoodTracks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodTrackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MoodTracks
     * const moodTrack = await prisma.moodTrack.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MoodTrackUpdateManyArgs>(args: SelectSubset<T, MoodTrackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MoodTracks and returns the data updated in the database.
     * @param {MoodTrackUpdateManyAndReturnArgs} args - Arguments to update many MoodTracks.
     * @example
     * // Update many MoodTracks
     * const moodTrack = await prisma.moodTrack.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MoodTracks and only return the `id`
     * const moodTrackWithIdOnly = await prisma.moodTrack.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MoodTrackUpdateManyAndReturnArgs>(args: SelectSubset<T, MoodTrackUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoodTrackPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MoodTrack.
     * @param {MoodTrackUpsertArgs} args - Arguments to update or create a MoodTrack.
     * @example
     * // Update or create a MoodTrack
     * const moodTrack = await prisma.moodTrack.upsert({
     *   create: {
     *     // ... data to create a MoodTrack
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MoodTrack we want to update
     *   }
     * })
     */
    upsert<T extends MoodTrackUpsertArgs>(args: SelectSubset<T, MoodTrackUpsertArgs<ExtArgs>>): Prisma__MoodTrackClient<$Result.GetResult<Prisma.$MoodTrackPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MoodTracks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodTrackCountArgs} args - Arguments to filter MoodTracks to count.
     * @example
     * // Count the number of MoodTracks
     * const count = await prisma.moodTrack.count({
     *   where: {
     *     // ... the filter for the MoodTracks we want to count
     *   }
     * })
    **/
    count<T extends MoodTrackCountArgs>(
      args?: Subset<T, MoodTrackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MoodTrackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MoodTrack.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodTrackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MoodTrackAggregateArgs>(args: Subset<T, MoodTrackAggregateArgs>): Prisma.PrismaPromise<GetMoodTrackAggregateType<T>>

    /**
     * Group by MoodTrack.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoodTrackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MoodTrackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MoodTrackGroupByArgs['orderBy'] }
        : { orderBy?: MoodTrackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MoodTrackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMoodTrackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MoodTrack model
   */
  readonly fields: MoodTrackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MoodTrack.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MoodTrackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MoodTrack model
   */
  interface MoodTrackFieldRefs {
    readonly id: FieldRef<"MoodTrack", 'String'>
    readonly userId: FieldRef<"MoodTrack", 'String'>
    readonly date: FieldRef<"MoodTrack", 'DateTime'>
    readonly mood: FieldRef<"MoodTrack", 'MoodType'>
    readonly energy: FieldRef<"MoodTrack", 'EnergyLevel'>
    readonly pain: FieldRef<"MoodTrack", 'PainLevel'>
    readonly stress: FieldRef<"MoodTrack", 'StressLevel'>
    readonly sleepQuality: FieldRef<"MoodTrack", 'SleepQuality'>
    readonly createdAt: FieldRef<"MoodTrack", 'DateTime'>
    readonly updatedAt: FieldRef<"MoodTrack", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MoodTrack findUnique
   */
  export type MoodTrackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodTrack
     */
    select?: MoodTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoodTrack
     */
    omit?: MoodTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodTrackInclude<ExtArgs> | null
    /**
     * Filter, which MoodTrack to fetch.
     */
    where: MoodTrackWhereUniqueInput
  }

  /**
   * MoodTrack findUniqueOrThrow
   */
  export type MoodTrackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodTrack
     */
    select?: MoodTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoodTrack
     */
    omit?: MoodTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodTrackInclude<ExtArgs> | null
    /**
     * Filter, which MoodTrack to fetch.
     */
    where: MoodTrackWhereUniqueInput
  }

  /**
   * MoodTrack findFirst
   */
  export type MoodTrackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodTrack
     */
    select?: MoodTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoodTrack
     */
    omit?: MoodTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodTrackInclude<ExtArgs> | null
    /**
     * Filter, which MoodTrack to fetch.
     */
    where?: MoodTrackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MoodTracks to fetch.
     */
    orderBy?: MoodTrackOrderByWithRelationInput | MoodTrackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MoodTracks.
     */
    cursor?: MoodTrackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MoodTracks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MoodTracks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MoodTracks.
     */
    distinct?: MoodTrackScalarFieldEnum | MoodTrackScalarFieldEnum[]
  }

  /**
   * MoodTrack findFirstOrThrow
   */
  export type MoodTrackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodTrack
     */
    select?: MoodTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoodTrack
     */
    omit?: MoodTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodTrackInclude<ExtArgs> | null
    /**
     * Filter, which MoodTrack to fetch.
     */
    where?: MoodTrackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MoodTracks to fetch.
     */
    orderBy?: MoodTrackOrderByWithRelationInput | MoodTrackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MoodTracks.
     */
    cursor?: MoodTrackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MoodTracks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MoodTracks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MoodTracks.
     */
    distinct?: MoodTrackScalarFieldEnum | MoodTrackScalarFieldEnum[]
  }

  /**
   * MoodTrack findMany
   */
  export type MoodTrackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodTrack
     */
    select?: MoodTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoodTrack
     */
    omit?: MoodTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodTrackInclude<ExtArgs> | null
    /**
     * Filter, which MoodTracks to fetch.
     */
    where?: MoodTrackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MoodTracks to fetch.
     */
    orderBy?: MoodTrackOrderByWithRelationInput | MoodTrackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MoodTracks.
     */
    cursor?: MoodTrackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MoodTracks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MoodTracks.
     */
    skip?: number
    distinct?: MoodTrackScalarFieldEnum | MoodTrackScalarFieldEnum[]
  }

  /**
   * MoodTrack create
   */
  export type MoodTrackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodTrack
     */
    select?: MoodTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoodTrack
     */
    omit?: MoodTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodTrackInclude<ExtArgs> | null
    /**
     * The data needed to create a MoodTrack.
     */
    data: XOR<MoodTrackCreateInput, MoodTrackUncheckedCreateInput>
  }

  /**
   * MoodTrack createMany
   */
  export type MoodTrackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MoodTracks.
     */
    data: MoodTrackCreateManyInput | MoodTrackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MoodTrack createManyAndReturn
   */
  export type MoodTrackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodTrack
     */
    select?: MoodTrackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MoodTrack
     */
    omit?: MoodTrackOmit<ExtArgs> | null
    /**
     * The data used to create many MoodTracks.
     */
    data: MoodTrackCreateManyInput | MoodTrackCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodTrackIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MoodTrack update
   */
  export type MoodTrackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodTrack
     */
    select?: MoodTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoodTrack
     */
    omit?: MoodTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodTrackInclude<ExtArgs> | null
    /**
     * The data needed to update a MoodTrack.
     */
    data: XOR<MoodTrackUpdateInput, MoodTrackUncheckedUpdateInput>
    /**
     * Choose, which MoodTrack to update.
     */
    where: MoodTrackWhereUniqueInput
  }

  /**
   * MoodTrack updateMany
   */
  export type MoodTrackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MoodTracks.
     */
    data: XOR<MoodTrackUpdateManyMutationInput, MoodTrackUncheckedUpdateManyInput>
    /**
     * Filter which MoodTracks to update
     */
    where?: MoodTrackWhereInput
    /**
     * Limit how many MoodTracks to update.
     */
    limit?: number
  }

  /**
   * MoodTrack updateManyAndReturn
   */
  export type MoodTrackUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodTrack
     */
    select?: MoodTrackSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MoodTrack
     */
    omit?: MoodTrackOmit<ExtArgs> | null
    /**
     * The data used to update MoodTracks.
     */
    data: XOR<MoodTrackUpdateManyMutationInput, MoodTrackUncheckedUpdateManyInput>
    /**
     * Filter which MoodTracks to update
     */
    where?: MoodTrackWhereInput
    /**
     * Limit how many MoodTracks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodTrackIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MoodTrack upsert
   */
  export type MoodTrackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodTrack
     */
    select?: MoodTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoodTrack
     */
    omit?: MoodTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodTrackInclude<ExtArgs> | null
    /**
     * The filter to search for the MoodTrack to update in case it exists.
     */
    where: MoodTrackWhereUniqueInput
    /**
     * In case the MoodTrack found by the `where` argument doesn't exist, create a new MoodTrack with this data.
     */
    create: XOR<MoodTrackCreateInput, MoodTrackUncheckedCreateInput>
    /**
     * In case the MoodTrack was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MoodTrackUpdateInput, MoodTrackUncheckedUpdateInput>
  }

  /**
   * MoodTrack delete
   */
  export type MoodTrackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodTrack
     */
    select?: MoodTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoodTrack
     */
    omit?: MoodTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodTrackInclude<ExtArgs> | null
    /**
     * Filter which MoodTrack to delete.
     */
    where: MoodTrackWhereUniqueInput
  }

  /**
   * MoodTrack deleteMany
   */
  export type MoodTrackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MoodTracks to delete
     */
    where?: MoodTrackWhereInput
    /**
     * Limit how many MoodTracks to delete.
     */
    limit?: number
  }

  /**
   * MoodTrack without action
   */
  export type MoodTrackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodTrack
     */
    select?: MoodTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoodTrack
     */
    omit?: MoodTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodTrackInclude<ExtArgs> | null
  }


  /**
   * Model SymptomLog
   */

  export type AggregateSymptomLog = {
    _count: SymptomLogCountAggregateOutputType | null
    _min: SymptomLogMinAggregateOutputType | null
    _max: SymptomLogMaxAggregateOutputType | null
  }

  export type SymptomLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    date: Date | null
    symptomType: $Enums.SymptomType | null
    value: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SymptomLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    date: Date | null
    symptomType: $Enums.SymptomType | null
    value: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SymptomLogCountAggregateOutputType = {
    id: number
    userId: number
    date: number
    symptomType: number
    value: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SymptomLogMinAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    symptomType?: true
    value?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SymptomLogMaxAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    symptomType?: true
    value?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SymptomLogCountAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    symptomType?: true
    value?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SymptomLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SymptomLog to aggregate.
     */
    where?: SymptomLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SymptomLogs to fetch.
     */
    orderBy?: SymptomLogOrderByWithRelationInput | SymptomLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SymptomLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SymptomLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SymptomLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SymptomLogs
    **/
    _count?: true | SymptomLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SymptomLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SymptomLogMaxAggregateInputType
  }

  export type GetSymptomLogAggregateType<T extends SymptomLogAggregateArgs> = {
        [P in keyof T & keyof AggregateSymptomLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSymptomLog[P]>
      : GetScalarType<T[P], AggregateSymptomLog[P]>
  }




  export type SymptomLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SymptomLogWhereInput
    orderBy?: SymptomLogOrderByWithAggregationInput | SymptomLogOrderByWithAggregationInput[]
    by: SymptomLogScalarFieldEnum[] | SymptomLogScalarFieldEnum
    having?: SymptomLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SymptomLogCountAggregateInputType | true
    _min?: SymptomLogMinAggregateInputType
    _max?: SymptomLogMaxAggregateInputType
  }

  export type SymptomLogGroupByOutputType = {
    id: string
    userId: string
    date: Date
    symptomType: $Enums.SymptomType
    value: string
    createdAt: Date
    updatedAt: Date
    _count: SymptomLogCountAggregateOutputType | null
    _min: SymptomLogMinAggregateOutputType | null
    _max: SymptomLogMaxAggregateOutputType | null
  }

  type GetSymptomLogGroupByPayload<T extends SymptomLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SymptomLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SymptomLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SymptomLogGroupByOutputType[P]>
            : GetScalarType<T[P], SymptomLogGroupByOutputType[P]>
        }
      >
    >


  export type SymptomLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    symptomType?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["symptomLog"]>

  export type SymptomLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    symptomType?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["symptomLog"]>

  export type SymptomLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    symptomType?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["symptomLog"]>

  export type SymptomLogSelectScalar = {
    id?: boolean
    userId?: boolean
    date?: boolean
    symptomType?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SymptomLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "date" | "symptomType" | "value" | "createdAt" | "updatedAt", ExtArgs["result"]["symptomLog"]>
  export type SymptomLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SymptomLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SymptomLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SymptomLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SymptomLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      date: Date
      symptomType: $Enums.SymptomType
      value: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["symptomLog"]>
    composites: {}
  }

  type SymptomLogGetPayload<S extends boolean | null | undefined | SymptomLogDefaultArgs> = $Result.GetResult<Prisma.$SymptomLogPayload, S>

  type SymptomLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SymptomLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SymptomLogCountAggregateInputType | true
    }

  export interface SymptomLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SymptomLog'], meta: { name: 'SymptomLog' } }
    /**
     * Find zero or one SymptomLog that matches the filter.
     * @param {SymptomLogFindUniqueArgs} args - Arguments to find a SymptomLog
     * @example
     * // Get one SymptomLog
     * const symptomLog = await prisma.symptomLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SymptomLogFindUniqueArgs>(args: SelectSubset<T, SymptomLogFindUniqueArgs<ExtArgs>>): Prisma__SymptomLogClient<$Result.GetResult<Prisma.$SymptomLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SymptomLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SymptomLogFindUniqueOrThrowArgs} args - Arguments to find a SymptomLog
     * @example
     * // Get one SymptomLog
     * const symptomLog = await prisma.symptomLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SymptomLogFindUniqueOrThrowArgs>(args: SelectSubset<T, SymptomLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SymptomLogClient<$Result.GetResult<Prisma.$SymptomLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SymptomLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymptomLogFindFirstArgs} args - Arguments to find a SymptomLog
     * @example
     * // Get one SymptomLog
     * const symptomLog = await prisma.symptomLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SymptomLogFindFirstArgs>(args?: SelectSubset<T, SymptomLogFindFirstArgs<ExtArgs>>): Prisma__SymptomLogClient<$Result.GetResult<Prisma.$SymptomLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SymptomLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymptomLogFindFirstOrThrowArgs} args - Arguments to find a SymptomLog
     * @example
     * // Get one SymptomLog
     * const symptomLog = await prisma.symptomLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SymptomLogFindFirstOrThrowArgs>(args?: SelectSubset<T, SymptomLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__SymptomLogClient<$Result.GetResult<Prisma.$SymptomLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SymptomLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymptomLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SymptomLogs
     * const symptomLogs = await prisma.symptomLog.findMany()
     * 
     * // Get first 10 SymptomLogs
     * const symptomLogs = await prisma.symptomLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const symptomLogWithIdOnly = await prisma.symptomLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SymptomLogFindManyArgs>(args?: SelectSubset<T, SymptomLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SymptomLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SymptomLog.
     * @param {SymptomLogCreateArgs} args - Arguments to create a SymptomLog.
     * @example
     * // Create one SymptomLog
     * const SymptomLog = await prisma.symptomLog.create({
     *   data: {
     *     // ... data to create a SymptomLog
     *   }
     * })
     * 
     */
    create<T extends SymptomLogCreateArgs>(args: SelectSubset<T, SymptomLogCreateArgs<ExtArgs>>): Prisma__SymptomLogClient<$Result.GetResult<Prisma.$SymptomLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SymptomLogs.
     * @param {SymptomLogCreateManyArgs} args - Arguments to create many SymptomLogs.
     * @example
     * // Create many SymptomLogs
     * const symptomLog = await prisma.symptomLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SymptomLogCreateManyArgs>(args?: SelectSubset<T, SymptomLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SymptomLogs and returns the data saved in the database.
     * @param {SymptomLogCreateManyAndReturnArgs} args - Arguments to create many SymptomLogs.
     * @example
     * // Create many SymptomLogs
     * const symptomLog = await prisma.symptomLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SymptomLogs and only return the `id`
     * const symptomLogWithIdOnly = await prisma.symptomLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SymptomLogCreateManyAndReturnArgs>(args?: SelectSubset<T, SymptomLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SymptomLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SymptomLog.
     * @param {SymptomLogDeleteArgs} args - Arguments to delete one SymptomLog.
     * @example
     * // Delete one SymptomLog
     * const SymptomLog = await prisma.symptomLog.delete({
     *   where: {
     *     // ... filter to delete one SymptomLog
     *   }
     * })
     * 
     */
    delete<T extends SymptomLogDeleteArgs>(args: SelectSubset<T, SymptomLogDeleteArgs<ExtArgs>>): Prisma__SymptomLogClient<$Result.GetResult<Prisma.$SymptomLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SymptomLog.
     * @param {SymptomLogUpdateArgs} args - Arguments to update one SymptomLog.
     * @example
     * // Update one SymptomLog
     * const symptomLog = await prisma.symptomLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SymptomLogUpdateArgs>(args: SelectSubset<T, SymptomLogUpdateArgs<ExtArgs>>): Prisma__SymptomLogClient<$Result.GetResult<Prisma.$SymptomLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SymptomLogs.
     * @param {SymptomLogDeleteManyArgs} args - Arguments to filter SymptomLogs to delete.
     * @example
     * // Delete a few SymptomLogs
     * const { count } = await prisma.symptomLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SymptomLogDeleteManyArgs>(args?: SelectSubset<T, SymptomLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SymptomLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymptomLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SymptomLogs
     * const symptomLog = await prisma.symptomLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SymptomLogUpdateManyArgs>(args: SelectSubset<T, SymptomLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SymptomLogs and returns the data updated in the database.
     * @param {SymptomLogUpdateManyAndReturnArgs} args - Arguments to update many SymptomLogs.
     * @example
     * // Update many SymptomLogs
     * const symptomLog = await prisma.symptomLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SymptomLogs and only return the `id`
     * const symptomLogWithIdOnly = await prisma.symptomLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SymptomLogUpdateManyAndReturnArgs>(args: SelectSubset<T, SymptomLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SymptomLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SymptomLog.
     * @param {SymptomLogUpsertArgs} args - Arguments to update or create a SymptomLog.
     * @example
     * // Update or create a SymptomLog
     * const symptomLog = await prisma.symptomLog.upsert({
     *   create: {
     *     // ... data to create a SymptomLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SymptomLog we want to update
     *   }
     * })
     */
    upsert<T extends SymptomLogUpsertArgs>(args: SelectSubset<T, SymptomLogUpsertArgs<ExtArgs>>): Prisma__SymptomLogClient<$Result.GetResult<Prisma.$SymptomLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SymptomLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymptomLogCountArgs} args - Arguments to filter SymptomLogs to count.
     * @example
     * // Count the number of SymptomLogs
     * const count = await prisma.symptomLog.count({
     *   where: {
     *     // ... the filter for the SymptomLogs we want to count
     *   }
     * })
    **/
    count<T extends SymptomLogCountArgs>(
      args?: Subset<T, SymptomLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SymptomLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SymptomLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymptomLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SymptomLogAggregateArgs>(args: Subset<T, SymptomLogAggregateArgs>): Prisma.PrismaPromise<GetSymptomLogAggregateType<T>>

    /**
     * Group by SymptomLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymptomLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SymptomLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SymptomLogGroupByArgs['orderBy'] }
        : { orderBy?: SymptomLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SymptomLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSymptomLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SymptomLog model
   */
  readonly fields: SymptomLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SymptomLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SymptomLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SymptomLog model
   */
  interface SymptomLogFieldRefs {
    readonly id: FieldRef<"SymptomLog", 'String'>
    readonly userId: FieldRef<"SymptomLog", 'String'>
    readonly date: FieldRef<"SymptomLog", 'DateTime'>
    readonly symptomType: FieldRef<"SymptomLog", 'SymptomType'>
    readonly value: FieldRef<"SymptomLog", 'String'>
    readonly createdAt: FieldRef<"SymptomLog", 'DateTime'>
    readonly updatedAt: FieldRef<"SymptomLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SymptomLog findUnique
   */
  export type SymptomLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SymptomLog
     */
    select?: SymptomLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SymptomLog
     */
    omit?: SymptomLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymptomLogInclude<ExtArgs> | null
    /**
     * Filter, which SymptomLog to fetch.
     */
    where: SymptomLogWhereUniqueInput
  }

  /**
   * SymptomLog findUniqueOrThrow
   */
  export type SymptomLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SymptomLog
     */
    select?: SymptomLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SymptomLog
     */
    omit?: SymptomLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymptomLogInclude<ExtArgs> | null
    /**
     * Filter, which SymptomLog to fetch.
     */
    where: SymptomLogWhereUniqueInput
  }

  /**
   * SymptomLog findFirst
   */
  export type SymptomLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SymptomLog
     */
    select?: SymptomLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SymptomLog
     */
    omit?: SymptomLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymptomLogInclude<ExtArgs> | null
    /**
     * Filter, which SymptomLog to fetch.
     */
    where?: SymptomLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SymptomLogs to fetch.
     */
    orderBy?: SymptomLogOrderByWithRelationInput | SymptomLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SymptomLogs.
     */
    cursor?: SymptomLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SymptomLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SymptomLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SymptomLogs.
     */
    distinct?: SymptomLogScalarFieldEnum | SymptomLogScalarFieldEnum[]
  }

  /**
   * SymptomLog findFirstOrThrow
   */
  export type SymptomLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SymptomLog
     */
    select?: SymptomLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SymptomLog
     */
    omit?: SymptomLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymptomLogInclude<ExtArgs> | null
    /**
     * Filter, which SymptomLog to fetch.
     */
    where?: SymptomLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SymptomLogs to fetch.
     */
    orderBy?: SymptomLogOrderByWithRelationInput | SymptomLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SymptomLogs.
     */
    cursor?: SymptomLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SymptomLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SymptomLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SymptomLogs.
     */
    distinct?: SymptomLogScalarFieldEnum | SymptomLogScalarFieldEnum[]
  }

  /**
   * SymptomLog findMany
   */
  export type SymptomLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SymptomLog
     */
    select?: SymptomLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SymptomLog
     */
    omit?: SymptomLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymptomLogInclude<ExtArgs> | null
    /**
     * Filter, which SymptomLogs to fetch.
     */
    where?: SymptomLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SymptomLogs to fetch.
     */
    orderBy?: SymptomLogOrderByWithRelationInput | SymptomLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SymptomLogs.
     */
    cursor?: SymptomLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SymptomLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SymptomLogs.
     */
    skip?: number
    distinct?: SymptomLogScalarFieldEnum | SymptomLogScalarFieldEnum[]
  }

  /**
   * SymptomLog create
   */
  export type SymptomLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SymptomLog
     */
    select?: SymptomLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SymptomLog
     */
    omit?: SymptomLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymptomLogInclude<ExtArgs> | null
    /**
     * The data needed to create a SymptomLog.
     */
    data: XOR<SymptomLogCreateInput, SymptomLogUncheckedCreateInput>
  }

  /**
   * SymptomLog createMany
   */
  export type SymptomLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SymptomLogs.
     */
    data: SymptomLogCreateManyInput | SymptomLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SymptomLog createManyAndReturn
   */
  export type SymptomLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SymptomLog
     */
    select?: SymptomLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SymptomLog
     */
    omit?: SymptomLogOmit<ExtArgs> | null
    /**
     * The data used to create many SymptomLogs.
     */
    data: SymptomLogCreateManyInput | SymptomLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymptomLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SymptomLog update
   */
  export type SymptomLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SymptomLog
     */
    select?: SymptomLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SymptomLog
     */
    omit?: SymptomLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymptomLogInclude<ExtArgs> | null
    /**
     * The data needed to update a SymptomLog.
     */
    data: XOR<SymptomLogUpdateInput, SymptomLogUncheckedUpdateInput>
    /**
     * Choose, which SymptomLog to update.
     */
    where: SymptomLogWhereUniqueInput
  }

  /**
   * SymptomLog updateMany
   */
  export type SymptomLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SymptomLogs.
     */
    data: XOR<SymptomLogUpdateManyMutationInput, SymptomLogUncheckedUpdateManyInput>
    /**
     * Filter which SymptomLogs to update
     */
    where?: SymptomLogWhereInput
    /**
     * Limit how many SymptomLogs to update.
     */
    limit?: number
  }

  /**
   * SymptomLog updateManyAndReturn
   */
  export type SymptomLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SymptomLog
     */
    select?: SymptomLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SymptomLog
     */
    omit?: SymptomLogOmit<ExtArgs> | null
    /**
     * The data used to update SymptomLogs.
     */
    data: XOR<SymptomLogUpdateManyMutationInput, SymptomLogUncheckedUpdateManyInput>
    /**
     * Filter which SymptomLogs to update
     */
    where?: SymptomLogWhereInput
    /**
     * Limit how many SymptomLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymptomLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SymptomLog upsert
   */
  export type SymptomLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SymptomLog
     */
    select?: SymptomLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SymptomLog
     */
    omit?: SymptomLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymptomLogInclude<ExtArgs> | null
    /**
     * The filter to search for the SymptomLog to update in case it exists.
     */
    where: SymptomLogWhereUniqueInput
    /**
     * In case the SymptomLog found by the `where` argument doesn't exist, create a new SymptomLog with this data.
     */
    create: XOR<SymptomLogCreateInput, SymptomLogUncheckedCreateInput>
    /**
     * In case the SymptomLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SymptomLogUpdateInput, SymptomLogUncheckedUpdateInput>
  }

  /**
   * SymptomLog delete
   */
  export type SymptomLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SymptomLog
     */
    select?: SymptomLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SymptomLog
     */
    omit?: SymptomLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymptomLogInclude<ExtArgs> | null
    /**
     * Filter which SymptomLog to delete.
     */
    where: SymptomLogWhereUniqueInput
  }

  /**
   * SymptomLog deleteMany
   */
  export type SymptomLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SymptomLogs to delete
     */
    where?: SymptomLogWhereInput
    /**
     * Limit how many SymptomLogs to delete.
     */
    limit?: number
  }

  /**
   * SymptomLog without action
   */
  export type SymptomLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SymptomLog
     */
    select?: SymptomLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SymptomLog
     */
    omit?: SymptomLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymptomLogInclude<ExtArgs> | null
  }


  /**
   * Model UserSettings
   */

  export type AggregateUserSettings = {
    _count: UserSettingsCountAggregateOutputType | null
    _min: UserSettingsMinAggregateOutputType | null
    _max: UserSettingsMaxAggregateOutputType | null
  }

  export type UserSettingsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    unitPreference: $Enums.UnitPreference | null
    notificationEnabled: boolean | null
    notificationTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSettingsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    unitPreference: $Enums.UnitPreference | null
    notificationEnabled: boolean | null
    notificationTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSettingsCountAggregateOutputType = {
    id: number
    userId: number
    unitPreference: number
    notificationEnabled: number
    notificationTime: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserSettingsMinAggregateInputType = {
    id?: true
    userId?: true
    unitPreference?: true
    notificationEnabled?: true
    notificationTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSettingsMaxAggregateInputType = {
    id?: true
    userId?: true
    unitPreference?: true
    notificationEnabled?: true
    notificationTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSettingsCountAggregateInputType = {
    id?: true
    userId?: true
    unitPreference?: true
    notificationEnabled?: true
    notificationTime?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSettings to aggregate.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSettings
    **/
    _count?: true | UserSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSettingsMaxAggregateInputType
  }

  export type GetUserSettingsAggregateType<T extends UserSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSettings[P]>
      : GetScalarType<T[P], AggregateUserSettings[P]>
  }




  export type UserSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSettingsWhereInput
    orderBy?: UserSettingsOrderByWithAggregationInput | UserSettingsOrderByWithAggregationInput[]
    by: UserSettingsScalarFieldEnum[] | UserSettingsScalarFieldEnum
    having?: UserSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSettingsCountAggregateInputType | true
    _min?: UserSettingsMinAggregateInputType
    _max?: UserSettingsMaxAggregateInputType
  }

  export type UserSettingsGroupByOutputType = {
    id: string
    userId: string
    unitPreference: $Enums.UnitPreference
    notificationEnabled: boolean
    notificationTime: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserSettingsCountAggregateOutputType | null
    _min: UserSettingsMinAggregateOutputType | null
    _max: UserSettingsMaxAggregateOutputType | null
  }

  type GetUserSettingsGroupByPayload<T extends UserSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], UserSettingsGroupByOutputType[P]>
        }
      >
    >


  export type UserSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    unitPreference?: boolean
    notificationEnabled?: boolean
    notificationTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>

  export type UserSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    unitPreference?: boolean
    notificationEnabled?: boolean
    notificationTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>

  export type UserSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    unitPreference?: boolean
    notificationEnabled?: boolean
    notificationTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>

  export type UserSettingsSelectScalar = {
    id?: boolean
    userId?: boolean
    unitPreference?: boolean
    notificationEnabled?: boolean
    notificationTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "unitPreference" | "notificationEnabled" | "notificationTime" | "createdAt" | "updatedAt", ExtArgs["result"]["userSettings"]>
  export type UserSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSettings"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      unitPreference: $Enums.UnitPreference
      notificationEnabled: boolean
      notificationTime: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userSettings"]>
    composites: {}
  }

  type UserSettingsGetPayload<S extends boolean | null | undefined | UserSettingsDefaultArgs> = $Result.GetResult<Prisma.$UserSettingsPayload, S>

  type UserSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSettingsCountAggregateInputType | true
    }

  export interface UserSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSettings'], meta: { name: 'UserSettings' } }
    /**
     * Find zero or one UserSettings that matches the filter.
     * @param {UserSettingsFindUniqueArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSettingsFindUniqueArgs>(args: SelectSubset<T, UserSettingsFindUniqueArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSettingsFindUniqueOrThrowArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindFirstArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSettingsFindFirstArgs>(args?: SelectSubset<T, UserSettingsFindFirstArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindFirstOrThrowArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSettings
     * const userSettings = await prisma.userSettings.findMany()
     * 
     * // Get first 10 UserSettings
     * const userSettings = await prisma.userSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSettingsWithIdOnly = await prisma.userSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSettingsFindManyArgs>(args?: SelectSubset<T, UserSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSettings.
     * @param {UserSettingsCreateArgs} args - Arguments to create a UserSettings.
     * @example
     * // Create one UserSettings
     * const UserSettings = await prisma.userSettings.create({
     *   data: {
     *     // ... data to create a UserSettings
     *   }
     * })
     * 
     */
    create<T extends UserSettingsCreateArgs>(args: SelectSubset<T, UserSettingsCreateArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSettings.
     * @param {UserSettingsCreateManyArgs} args - Arguments to create many UserSettings.
     * @example
     * // Create many UserSettings
     * const userSettings = await prisma.userSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSettingsCreateManyArgs>(args?: SelectSubset<T, UserSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSettings and returns the data saved in the database.
     * @param {UserSettingsCreateManyAndReturnArgs} args - Arguments to create many UserSettings.
     * @example
     * // Create many UserSettings
     * const userSettings = await prisma.userSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSettings and only return the `id`
     * const userSettingsWithIdOnly = await prisma.userSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSettings.
     * @param {UserSettingsDeleteArgs} args - Arguments to delete one UserSettings.
     * @example
     * // Delete one UserSettings
     * const UserSettings = await prisma.userSettings.delete({
     *   where: {
     *     // ... filter to delete one UserSettings
     *   }
     * })
     * 
     */
    delete<T extends UserSettingsDeleteArgs>(args: SelectSubset<T, UserSettingsDeleteArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSettings.
     * @param {UserSettingsUpdateArgs} args - Arguments to update one UserSettings.
     * @example
     * // Update one UserSettings
     * const userSettings = await prisma.userSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSettingsUpdateArgs>(args: SelectSubset<T, UserSettingsUpdateArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSettings.
     * @param {UserSettingsDeleteManyArgs} args - Arguments to filter UserSettings to delete.
     * @example
     * // Delete a few UserSettings
     * const { count } = await prisma.userSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSettingsDeleteManyArgs>(args?: SelectSubset<T, UserSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSettings
     * const userSettings = await prisma.userSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSettingsUpdateManyArgs>(args: SelectSubset<T, UserSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSettings and returns the data updated in the database.
     * @param {UserSettingsUpdateManyAndReturnArgs} args - Arguments to update many UserSettings.
     * @example
     * // Update many UserSettings
     * const userSettings = await prisma.userSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSettings and only return the `id`
     * const userSettingsWithIdOnly = await prisma.userSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSettings.
     * @param {UserSettingsUpsertArgs} args - Arguments to update or create a UserSettings.
     * @example
     * // Update or create a UserSettings
     * const userSettings = await prisma.userSettings.upsert({
     *   create: {
     *     // ... data to create a UserSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSettings we want to update
     *   }
     * })
     */
    upsert<T extends UserSettingsUpsertArgs>(args: SelectSubset<T, UserSettingsUpsertArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsCountArgs} args - Arguments to filter UserSettings to count.
     * @example
     * // Count the number of UserSettings
     * const count = await prisma.userSettings.count({
     *   where: {
     *     // ... the filter for the UserSettings we want to count
     *   }
     * })
    **/
    count<T extends UserSettingsCountArgs>(
      args?: Subset<T, UserSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSettingsAggregateArgs>(args: Subset<T, UserSettingsAggregateArgs>): Prisma.PrismaPromise<GetUserSettingsAggregateType<T>>

    /**
     * Group by UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSettingsGroupByArgs['orderBy'] }
        : { orderBy?: UserSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSettings model
   */
  readonly fields: UserSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSettings model
   */
  interface UserSettingsFieldRefs {
    readonly id: FieldRef<"UserSettings", 'String'>
    readonly userId: FieldRef<"UserSettings", 'String'>
    readonly unitPreference: FieldRef<"UserSettings", 'UnitPreference'>
    readonly notificationEnabled: FieldRef<"UserSettings", 'Boolean'>
    readonly notificationTime: FieldRef<"UserSettings", 'DateTime'>
    readonly createdAt: FieldRef<"UserSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"UserSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSettings findUnique
   */
  export type UserSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings findUniqueOrThrow
   */
  export type UserSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings findFirst
   */
  export type UserSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings findFirstOrThrow
   */
  export type UserSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings findMany
   */
  export type UserSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings create
   */
  export type UserSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSettings.
     */
    data: XOR<UserSettingsCreateInput, UserSettingsUncheckedCreateInput>
  }

  /**
   * UserSettings createMany
   */
  export type UserSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSettings.
     */
    data: UserSettingsCreateManyInput | UserSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSettings createManyAndReturn
   */
  export type UserSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many UserSettings.
     */
    data: UserSettingsCreateManyInput | UserSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSettings update
   */
  export type UserSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSettings.
     */
    data: XOR<UserSettingsUpdateInput, UserSettingsUncheckedUpdateInput>
    /**
     * Choose, which UserSettings to update.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings updateMany
   */
  export type UserSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSettings.
     */
    data: XOR<UserSettingsUpdateManyMutationInput, UserSettingsUncheckedUpdateManyInput>
    /**
     * Filter which UserSettings to update
     */
    where?: UserSettingsWhereInput
    /**
     * Limit how many UserSettings to update.
     */
    limit?: number
  }

  /**
   * UserSettings updateManyAndReturn
   */
  export type UserSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * The data used to update UserSettings.
     */
    data: XOR<UserSettingsUpdateManyMutationInput, UserSettingsUncheckedUpdateManyInput>
    /**
     * Filter which UserSettings to update
     */
    where?: UserSettingsWhereInput
    /**
     * Limit how many UserSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSettings upsert
   */
  export type UserSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSettings to update in case it exists.
     */
    where: UserSettingsWhereUniqueInput
    /**
     * In case the UserSettings found by the `where` argument doesn't exist, create a new UserSettings with this data.
     */
    create: XOR<UserSettingsCreateInput, UserSettingsUncheckedCreateInput>
    /**
     * In case the UserSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSettingsUpdateInput, UserSettingsUncheckedUpdateInput>
  }

  /**
   * UserSettings delete
   */
  export type UserSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter which UserSettings to delete.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings deleteMany
   */
  export type UserSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSettings to delete
     */
    where?: UserSettingsWhereInput
    /**
     * Limit how many UserSettings to delete.
     */
    limit?: number
  }

  /**
   * UserSettings without action
   */
  export type UserSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
  }


  /**
   * Model ReminderSettings
   */

  export type AggregateReminderSettings = {
    _count: ReminderSettingsCountAggregateOutputType | null
    _min: ReminderSettingsMinAggregateOutputType | null
    _max: ReminderSettingsMaxAggregateOutputType | null
  }

  export type ReminderSettingsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.ReminderType | null
    enabled: boolean | null
    time: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReminderSettingsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.ReminderType | null
    enabled: boolean | null
    time: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReminderSettingsCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    enabled: number
    time: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReminderSettingsMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    enabled?: true
    time?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReminderSettingsMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    enabled?: true
    time?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReminderSettingsCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    enabled?: true
    time?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReminderSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReminderSettings to aggregate.
     */
    where?: ReminderSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReminderSettings to fetch.
     */
    orderBy?: ReminderSettingsOrderByWithRelationInput | ReminderSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReminderSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReminderSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReminderSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReminderSettings
    **/
    _count?: true | ReminderSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReminderSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReminderSettingsMaxAggregateInputType
  }

  export type GetReminderSettingsAggregateType<T extends ReminderSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateReminderSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReminderSettings[P]>
      : GetScalarType<T[P], AggregateReminderSettings[P]>
  }




  export type ReminderSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReminderSettingsWhereInput
    orderBy?: ReminderSettingsOrderByWithAggregationInput | ReminderSettingsOrderByWithAggregationInput[]
    by: ReminderSettingsScalarFieldEnum[] | ReminderSettingsScalarFieldEnum
    having?: ReminderSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReminderSettingsCountAggregateInputType | true
    _min?: ReminderSettingsMinAggregateInputType
    _max?: ReminderSettingsMaxAggregateInputType
  }

  export type ReminderSettingsGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.ReminderType
    enabled: boolean
    time: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ReminderSettingsCountAggregateOutputType | null
    _min: ReminderSettingsMinAggregateOutputType | null
    _max: ReminderSettingsMaxAggregateOutputType | null
  }

  type GetReminderSettingsGroupByPayload<T extends ReminderSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReminderSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReminderSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReminderSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], ReminderSettingsGroupByOutputType[P]>
        }
      >
    >


  export type ReminderSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    enabled?: boolean
    time?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reminderSettings"]>

  export type ReminderSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    enabled?: boolean
    time?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reminderSettings"]>

  export type ReminderSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    enabled?: boolean
    time?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reminderSettings"]>

  export type ReminderSettingsSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    enabled?: boolean
    time?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReminderSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "enabled" | "time" | "createdAt" | "updatedAt", ExtArgs["result"]["reminderSettings"]>
  export type ReminderSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReminderSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReminderSettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReminderSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReminderSettings"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.ReminderType
      enabled: boolean
      time: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["reminderSettings"]>
    composites: {}
  }

  type ReminderSettingsGetPayload<S extends boolean | null | undefined | ReminderSettingsDefaultArgs> = $Result.GetResult<Prisma.$ReminderSettingsPayload, S>

  type ReminderSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReminderSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReminderSettingsCountAggregateInputType | true
    }

  export interface ReminderSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReminderSettings'], meta: { name: 'ReminderSettings' } }
    /**
     * Find zero or one ReminderSettings that matches the filter.
     * @param {ReminderSettingsFindUniqueArgs} args - Arguments to find a ReminderSettings
     * @example
     * // Get one ReminderSettings
     * const reminderSettings = await prisma.reminderSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReminderSettingsFindUniqueArgs>(args: SelectSubset<T, ReminderSettingsFindUniqueArgs<ExtArgs>>): Prisma__ReminderSettingsClient<$Result.GetResult<Prisma.$ReminderSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReminderSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReminderSettingsFindUniqueOrThrowArgs} args - Arguments to find a ReminderSettings
     * @example
     * // Get one ReminderSettings
     * const reminderSettings = await prisma.reminderSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReminderSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, ReminderSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReminderSettingsClient<$Result.GetResult<Prisma.$ReminderSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReminderSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReminderSettingsFindFirstArgs} args - Arguments to find a ReminderSettings
     * @example
     * // Get one ReminderSettings
     * const reminderSettings = await prisma.reminderSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReminderSettingsFindFirstArgs>(args?: SelectSubset<T, ReminderSettingsFindFirstArgs<ExtArgs>>): Prisma__ReminderSettingsClient<$Result.GetResult<Prisma.$ReminderSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReminderSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReminderSettingsFindFirstOrThrowArgs} args - Arguments to find a ReminderSettings
     * @example
     * // Get one ReminderSettings
     * const reminderSettings = await prisma.reminderSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReminderSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, ReminderSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReminderSettingsClient<$Result.GetResult<Prisma.$ReminderSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReminderSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReminderSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReminderSettings
     * const reminderSettings = await prisma.reminderSettings.findMany()
     * 
     * // Get first 10 ReminderSettings
     * const reminderSettings = await prisma.reminderSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reminderSettingsWithIdOnly = await prisma.reminderSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReminderSettingsFindManyArgs>(args?: SelectSubset<T, ReminderSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReminderSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReminderSettings.
     * @param {ReminderSettingsCreateArgs} args - Arguments to create a ReminderSettings.
     * @example
     * // Create one ReminderSettings
     * const ReminderSettings = await prisma.reminderSettings.create({
     *   data: {
     *     // ... data to create a ReminderSettings
     *   }
     * })
     * 
     */
    create<T extends ReminderSettingsCreateArgs>(args: SelectSubset<T, ReminderSettingsCreateArgs<ExtArgs>>): Prisma__ReminderSettingsClient<$Result.GetResult<Prisma.$ReminderSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReminderSettings.
     * @param {ReminderSettingsCreateManyArgs} args - Arguments to create many ReminderSettings.
     * @example
     * // Create many ReminderSettings
     * const reminderSettings = await prisma.reminderSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReminderSettingsCreateManyArgs>(args?: SelectSubset<T, ReminderSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReminderSettings and returns the data saved in the database.
     * @param {ReminderSettingsCreateManyAndReturnArgs} args - Arguments to create many ReminderSettings.
     * @example
     * // Create many ReminderSettings
     * const reminderSettings = await prisma.reminderSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReminderSettings and only return the `id`
     * const reminderSettingsWithIdOnly = await prisma.reminderSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReminderSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, ReminderSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReminderSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReminderSettings.
     * @param {ReminderSettingsDeleteArgs} args - Arguments to delete one ReminderSettings.
     * @example
     * // Delete one ReminderSettings
     * const ReminderSettings = await prisma.reminderSettings.delete({
     *   where: {
     *     // ... filter to delete one ReminderSettings
     *   }
     * })
     * 
     */
    delete<T extends ReminderSettingsDeleteArgs>(args: SelectSubset<T, ReminderSettingsDeleteArgs<ExtArgs>>): Prisma__ReminderSettingsClient<$Result.GetResult<Prisma.$ReminderSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReminderSettings.
     * @param {ReminderSettingsUpdateArgs} args - Arguments to update one ReminderSettings.
     * @example
     * // Update one ReminderSettings
     * const reminderSettings = await prisma.reminderSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReminderSettingsUpdateArgs>(args: SelectSubset<T, ReminderSettingsUpdateArgs<ExtArgs>>): Prisma__ReminderSettingsClient<$Result.GetResult<Prisma.$ReminderSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReminderSettings.
     * @param {ReminderSettingsDeleteManyArgs} args - Arguments to filter ReminderSettings to delete.
     * @example
     * // Delete a few ReminderSettings
     * const { count } = await prisma.reminderSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReminderSettingsDeleteManyArgs>(args?: SelectSubset<T, ReminderSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReminderSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReminderSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReminderSettings
     * const reminderSettings = await prisma.reminderSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReminderSettingsUpdateManyArgs>(args: SelectSubset<T, ReminderSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReminderSettings and returns the data updated in the database.
     * @param {ReminderSettingsUpdateManyAndReturnArgs} args - Arguments to update many ReminderSettings.
     * @example
     * // Update many ReminderSettings
     * const reminderSettings = await prisma.reminderSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReminderSettings and only return the `id`
     * const reminderSettingsWithIdOnly = await prisma.reminderSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReminderSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, ReminderSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReminderSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReminderSettings.
     * @param {ReminderSettingsUpsertArgs} args - Arguments to update or create a ReminderSettings.
     * @example
     * // Update or create a ReminderSettings
     * const reminderSettings = await prisma.reminderSettings.upsert({
     *   create: {
     *     // ... data to create a ReminderSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReminderSettings we want to update
     *   }
     * })
     */
    upsert<T extends ReminderSettingsUpsertArgs>(args: SelectSubset<T, ReminderSettingsUpsertArgs<ExtArgs>>): Prisma__ReminderSettingsClient<$Result.GetResult<Prisma.$ReminderSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReminderSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReminderSettingsCountArgs} args - Arguments to filter ReminderSettings to count.
     * @example
     * // Count the number of ReminderSettings
     * const count = await prisma.reminderSettings.count({
     *   where: {
     *     // ... the filter for the ReminderSettings we want to count
     *   }
     * })
    **/
    count<T extends ReminderSettingsCountArgs>(
      args?: Subset<T, ReminderSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReminderSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReminderSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReminderSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReminderSettingsAggregateArgs>(args: Subset<T, ReminderSettingsAggregateArgs>): Prisma.PrismaPromise<GetReminderSettingsAggregateType<T>>

    /**
     * Group by ReminderSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReminderSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReminderSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReminderSettingsGroupByArgs['orderBy'] }
        : { orderBy?: ReminderSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReminderSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReminderSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReminderSettings model
   */
  readonly fields: ReminderSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReminderSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReminderSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReminderSettings model
   */
  interface ReminderSettingsFieldRefs {
    readonly id: FieldRef<"ReminderSettings", 'String'>
    readonly userId: FieldRef<"ReminderSettings", 'String'>
    readonly type: FieldRef<"ReminderSettings", 'ReminderType'>
    readonly enabled: FieldRef<"ReminderSettings", 'Boolean'>
    readonly time: FieldRef<"ReminderSettings", 'DateTime'>
    readonly createdAt: FieldRef<"ReminderSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"ReminderSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReminderSettings findUnique
   */
  export type ReminderSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReminderSettings
     */
    select?: ReminderSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReminderSettings
     */
    omit?: ReminderSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderSettingsInclude<ExtArgs> | null
    /**
     * Filter, which ReminderSettings to fetch.
     */
    where: ReminderSettingsWhereUniqueInput
  }

  /**
   * ReminderSettings findUniqueOrThrow
   */
  export type ReminderSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReminderSettings
     */
    select?: ReminderSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReminderSettings
     */
    omit?: ReminderSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderSettingsInclude<ExtArgs> | null
    /**
     * Filter, which ReminderSettings to fetch.
     */
    where: ReminderSettingsWhereUniqueInput
  }

  /**
   * ReminderSettings findFirst
   */
  export type ReminderSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReminderSettings
     */
    select?: ReminderSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReminderSettings
     */
    omit?: ReminderSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderSettingsInclude<ExtArgs> | null
    /**
     * Filter, which ReminderSettings to fetch.
     */
    where?: ReminderSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReminderSettings to fetch.
     */
    orderBy?: ReminderSettingsOrderByWithRelationInput | ReminderSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReminderSettings.
     */
    cursor?: ReminderSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReminderSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReminderSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReminderSettings.
     */
    distinct?: ReminderSettingsScalarFieldEnum | ReminderSettingsScalarFieldEnum[]
  }

  /**
   * ReminderSettings findFirstOrThrow
   */
  export type ReminderSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReminderSettings
     */
    select?: ReminderSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReminderSettings
     */
    omit?: ReminderSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderSettingsInclude<ExtArgs> | null
    /**
     * Filter, which ReminderSettings to fetch.
     */
    where?: ReminderSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReminderSettings to fetch.
     */
    orderBy?: ReminderSettingsOrderByWithRelationInput | ReminderSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReminderSettings.
     */
    cursor?: ReminderSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReminderSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReminderSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReminderSettings.
     */
    distinct?: ReminderSettingsScalarFieldEnum | ReminderSettingsScalarFieldEnum[]
  }

  /**
   * ReminderSettings findMany
   */
  export type ReminderSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReminderSettings
     */
    select?: ReminderSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReminderSettings
     */
    omit?: ReminderSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderSettingsInclude<ExtArgs> | null
    /**
     * Filter, which ReminderSettings to fetch.
     */
    where?: ReminderSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReminderSettings to fetch.
     */
    orderBy?: ReminderSettingsOrderByWithRelationInput | ReminderSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReminderSettings.
     */
    cursor?: ReminderSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReminderSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReminderSettings.
     */
    skip?: number
    distinct?: ReminderSettingsScalarFieldEnum | ReminderSettingsScalarFieldEnum[]
  }

  /**
   * ReminderSettings create
   */
  export type ReminderSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReminderSettings
     */
    select?: ReminderSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReminderSettings
     */
    omit?: ReminderSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a ReminderSettings.
     */
    data: XOR<ReminderSettingsCreateInput, ReminderSettingsUncheckedCreateInput>
  }

  /**
   * ReminderSettings createMany
   */
  export type ReminderSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReminderSettings.
     */
    data: ReminderSettingsCreateManyInput | ReminderSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReminderSettings createManyAndReturn
   */
  export type ReminderSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReminderSettings
     */
    select?: ReminderSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReminderSettings
     */
    omit?: ReminderSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many ReminderSettings.
     */
    data: ReminderSettingsCreateManyInput | ReminderSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReminderSettings update
   */
  export type ReminderSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReminderSettings
     */
    select?: ReminderSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReminderSettings
     */
    omit?: ReminderSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a ReminderSettings.
     */
    data: XOR<ReminderSettingsUpdateInput, ReminderSettingsUncheckedUpdateInput>
    /**
     * Choose, which ReminderSettings to update.
     */
    where: ReminderSettingsWhereUniqueInput
  }

  /**
   * ReminderSettings updateMany
   */
  export type ReminderSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReminderSettings.
     */
    data: XOR<ReminderSettingsUpdateManyMutationInput, ReminderSettingsUncheckedUpdateManyInput>
    /**
     * Filter which ReminderSettings to update
     */
    where?: ReminderSettingsWhereInput
    /**
     * Limit how many ReminderSettings to update.
     */
    limit?: number
  }

  /**
   * ReminderSettings updateManyAndReturn
   */
  export type ReminderSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReminderSettings
     */
    select?: ReminderSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReminderSettings
     */
    omit?: ReminderSettingsOmit<ExtArgs> | null
    /**
     * The data used to update ReminderSettings.
     */
    data: XOR<ReminderSettingsUpdateManyMutationInput, ReminderSettingsUncheckedUpdateManyInput>
    /**
     * Filter which ReminderSettings to update
     */
    where?: ReminderSettingsWhereInput
    /**
     * Limit how many ReminderSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderSettingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReminderSettings upsert
   */
  export type ReminderSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReminderSettings
     */
    select?: ReminderSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReminderSettings
     */
    omit?: ReminderSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the ReminderSettings to update in case it exists.
     */
    where: ReminderSettingsWhereUniqueInput
    /**
     * In case the ReminderSettings found by the `where` argument doesn't exist, create a new ReminderSettings with this data.
     */
    create: XOR<ReminderSettingsCreateInput, ReminderSettingsUncheckedCreateInput>
    /**
     * In case the ReminderSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReminderSettingsUpdateInput, ReminderSettingsUncheckedUpdateInput>
  }

  /**
   * ReminderSettings delete
   */
  export type ReminderSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReminderSettings
     */
    select?: ReminderSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReminderSettings
     */
    omit?: ReminderSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderSettingsInclude<ExtArgs> | null
    /**
     * Filter which ReminderSettings to delete.
     */
    where: ReminderSettingsWhereUniqueInput
  }

  /**
   * ReminderSettings deleteMany
   */
  export type ReminderSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReminderSettings to delete
     */
    where?: ReminderSettingsWhereInput
    /**
     * Limit how many ReminderSettings to delete.
     */
    limit?: number
  }

  /**
   * ReminderSettings without action
   */
  export type ReminderSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReminderSettings
     */
    select?: ReminderSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReminderSettings
     */
    omit?: ReminderSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderSettingsInclude<ExtArgs> | null
  }


  /**
   * Model UserFeatureFlag
   */

  export type AggregateUserFeatureFlag = {
    _count: UserFeatureFlagCountAggregateOutputType | null
    _min: UserFeatureFlagMinAggregateOutputType | null
    _max: UserFeatureFlagMaxAggregateOutputType | null
  }

  export type UserFeatureFlagMinAggregateOutputType = {
    id: string | null
    userId: string | null
    feature: string | null
    isEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserFeatureFlagMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    feature: string | null
    isEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserFeatureFlagCountAggregateOutputType = {
    id: number
    userId: number
    feature: number
    isEnabled: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserFeatureFlagMinAggregateInputType = {
    id?: true
    userId?: true
    feature?: true
    isEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserFeatureFlagMaxAggregateInputType = {
    id?: true
    userId?: true
    feature?: true
    isEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserFeatureFlagCountAggregateInputType = {
    id?: true
    userId?: true
    feature?: true
    isEnabled?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserFeatureFlagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFeatureFlag to aggregate.
     */
    where?: UserFeatureFlagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFeatureFlags to fetch.
     */
    orderBy?: UserFeatureFlagOrderByWithRelationInput | UserFeatureFlagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserFeatureFlagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFeatureFlags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFeatureFlags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserFeatureFlags
    **/
    _count?: true | UserFeatureFlagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserFeatureFlagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserFeatureFlagMaxAggregateInputType
  }

  export type GetUserFeatureFlagAggregateType<T extends UserFeatureFlagAggregateArgs> = {
        [P in keyof T & keyof AggregateUserFeatureFlag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserFeatureFlag[P]>
      : GetScalarType<T[P], AggregateUserFeatureFlag[P]>
  }




  export type UserFeatureFlagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFeatureFlagWhereInput
    orderBy?: UserFeatureFlagOrderByWithAggregationInput | UserFeatureFlagOrderByWithAggregationInput[]
    by: UserFeatureFlagScalarFieldEnum[] | UserFeatureFlagScalarFieldEnum
    having?: UserFeatureFlagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserFeatureFlagCountAggregateInputType | true
    _min?: UserFeatureFlagMinAggregateInputType
    _max?: UserFeatureFlagMaxAggregateInputType
  }

  export type UserFeatureFlagGroupByOutputType = {
    id: string
    userId: string
    feature: string
    isEnabled: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserFeatureFlagCountAggregateOutputType | null
    _min: UserFeatureFlagMinAggregateOutputType | null
    _max: UserFeatureFlagMaxAggregateOutputType | null
  }

  type GetUserFeatureFlagGroupByPayload<T extends UserFeatureFlagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserFeatureFlagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserFeatureFlagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserFeatureFlagGroupByOutputType[P]>
            : GetScalarType<T[P], UserFeatureFlagGroupByOutputType[P]>
        }
      >
    >


  export type UserFeatureFlagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    feature?: boolean
    isEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFeatureFlag"]>

  export type UserFeatureFlagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    feature?: boolean
    isEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFeatureFlag"]>

  export type UserFeatureFlagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    feature?: boolean
    isEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFeatureFlag"]>

  export type UserFeatureFlagSelectScalar = {
    id?: boolean
    userId?: boolean
    feature?: boolean
    isEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserFeatureFlagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "feature" | "isEnabled" | "createdAt" | "updatedAt", ExtArgs["result"]["userFeatureFlag"]>
  export type UserFeatureFlagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserFeatureFlagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserFeatureFlagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserFeatureFlagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserFeatureFlag"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      feature: string
      isEnabled: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userFeatureFlag"]>
    composites: {}
  }

  type UserFeatureFlagGetPayload<S extends boolean | null | undefined | UserFeatureFlagDefaultArgs> = $Result.GetResult<Prisma.$UserFeatureFlagPayload, S>

  type UserFeatureFlagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFeatureFlagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserFeatureFlagCountAggregateInputType | true
    }

  export interface UserFeatureFlagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserFeatureFlag'], meta: { name: 'UserFeatureFlag' } }
    /**
     * Find zero or one UserFeatureFlag that matches the filter.
     * @param {UserFeatureFlagFindUniqueArgs} args - Arguments to find a UserFeatureFlag
     * @example
     * // Get one UserFeatureFlag
     * const userFeatureFlag = await prisma.userFeatureFlag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFeatureFlagFindUniqueArgs>(args: SelectSubset<T, UserFeatureFlagFindUniqueArgs<ExtArgs>>): Prisma__UserFeatureFlagClient<$Result.GetResult<Prisma.$UserFeatureFlagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserFeatureFlag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFeatureFlagFindUniqueOrThrowArgs} args - Arguments to find a UserFeatureFlag
     * @example
     * // Get one UserFeatureFlag
     * const userFeatureFlag = await prisma.userFeatureFlag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFeatureFlagFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFeatureFlagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserFeatureFlagClient<$Result.GetResult<Prisma.$UserFeatureFlagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFeatureFlag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeatureFlagFindFirstArgs} args - Arguments to find a UserFeatureFlag
     * @example
     * // Get one UserFeatureFlag
     * const userFeatureFlag = await prisma.userFeatureFlag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFeatureFlagFindFirstArgs>(args?: SelectSubset<T, UserFeatureFlagFindFirstArgs<ExtArgs>>): Prisma__UserFeatureFlagClient<$Result.GetResult<Prisma.$UserFeatureFlagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFeatureFlag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeatureFlagFindFirstOrThrowArgs} args - Arguments to find a UserFeatureFlag
     * @example
     * // Get one UserFeatureFlag
     * const userFeatureFlag = await prisma.userFeatureFlag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFeatureFlagFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFeatureFlagFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserFeatureFlagClient<$Result.GetResult<Prisma.$UserFeatureFlagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserFeatureFlags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeatureFlagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserFeatureFlags
     * const userFeatureFlags = await prisma.userFeatureFlag.findMany()
     * 
     * // Get first 10 UserFeatureFlags
     * const userFeatureFlags = await prisma.userFeatureFlag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userFeatureFlagWithIdOnly = await prisma.userFeatureFlag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFeatureFlagFindManyArgs>(args?: SelectSubset<T, UserFeatureFlagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFeatureFlagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserFeatureFlag.
     * @param {UserFeatureFlagCreateArgs} args - Arguments to create a UserFeatureFlag.
     * @example
     * // Create one UserFeatureFlag
     * const UserFeatureFlag = await prisma.userFeatureFlag.create({
     *   data: {
     *     // ... data to create a UserFeatureFlag
     *   }
     * })
     * 
     */
    create<T extends UserFeatureFlagCreateArgs>(args: SelectSubset<T, UserFeatureFlagCreateArgs<ExtArgs>>): Prisma__UserFeatureFlagClient<$Result.GetResult<Prisma.$UserFeatureFlagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserFeatureFlags.
     * @param {UserFeatureFlagCreateManyArgs} args - Arguments to create many UserFeatureFlags.
     * @example
     * // Create many UserFeatureFlags
     * const userFeatureFlag = await prisma.userFeatureFlag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserFeatureFlagCreateManyArgs>(args?: SelectSubset<T, UserFeatureFlagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserFeatureFlags and returns the data saved in the database.
     * @param {UserFeatureFlagCreateManyAndReturnArgs} args - Arguments to create many UserFeatureFlags.
     * @example
     * // Create many UserFeatureFlags
     * const userFeatureFlag = await prisma.userFeatureFlag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserFeatureFlags and only return the `id`
     * const userFeatureFlagWithIdOnly = await prisma.userFeatureFlag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserFeatureFlagCreateManyAndReturnArgs>(args?: SelectSubset<T, UserFeatureFlagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFeatureFlagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserFeatureFlag.
     * @param {UserFeatureFlagDeleteArgs} args - Arguments to delete one UserFeatureFlag.
     * @example
     * // Delete one UserFeatureFlag
     * const UserFeatureFlag = await prisma.userFeatureFlag.delete({
     *   where: {
     *     // ... filter to delete one UserFeatureFlag
     *   }
     * })
     * 
     */
    delete<T extends UserFeatureFlagDeleteArgs>(args: SelectSubset<T, UserFeatureFlagDeleteArgs<ExtArgs>>): Prisma__UserFeatureFlagClient<$Result.GetResult<Prisma.$UserFeatureFlagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserFeatureFlag.
     * @param {UserFeatureFlagUpdateArgs} args - Arguments to update one UserFeatureFlag.
     * @example
     * // Update one UserFeatureFlag
     * const userFeatureFlag = await prisma.userFeatureFlag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserFeatureFlagUpdateArgs>(args: SelectSubset<T, UserFeatureFlagUpdateArgs<ExtArgs>>): Prisma__UserFeatureFlagClient<$Result.GetResult<Prisma.$UserFeatureFlagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserFeatureFlags.
     * @param {UserFeatureFlagDeleteManyArgs} args - Arguments to filter UserFeatureFlags to delete.
     * @example
     * // Delete a few UserFeatureFlags
     * const { count } = await prisma.userFeatureFlag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserFeatureFlagDeleteManyArgs>(args?: SelectSubset<T, UserFeatureFlagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFeatureFlags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeatureFlagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserFeatureFlags
     * const userFeatureFlag = await prisma.userFeatureFlag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserFeatureFlagUpdateManyArgs>(args: SelectSubset<T, UserFeatureFlagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFeatureFlags and returns the data updated in the database.
     * @param {UserFeatureFlagUpdateManyAndReturnArgs} args - Arguments to update many UserFeatureFlags.
     * @example
     * // Update many UserFeatureFlags
     * const userFeatureFlag = await prisma.userFeatureFlag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserFeatureFlags and only return the `id`
     * const userFeatureFlagWithIdOnly = await prisma.userFeatureFlag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserFeatureFlagUpdateManyAndReturnArgs>(args: SelectSubset<T, UserFeatureFlagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFeatureFlagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserFeatureFlag.
     * @param {UserFeatureFlagUpsertArgs} args - Arguments to update or create a UserFeatureFlag.
     * @example
     * // Update or create a UserFeatureFlag
     * const userFeatureFlag = await prisma.userFeatureFlag.upsert({
     *   create: {
     *     // ... data to create a UserFeatureFlag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserFeatureFlag we want to update
     *   }
     * })
     */
    upsert<T extends UserFeatureFlagUpsertArgs>(args: SelectSubset<T, UserFeatureFlagUpsertArgs<ExtArgs>>): Prisma__UserFeatureFlagClient<$Result.GetResult<Prisma.$UserFeatureFlagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserFeatureFlags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeatureFlagCountArgs} args - Arguments to filter UserFeatureFlags to count.
     * @example
     * // Count the number of UserFeatureFlags
     * const count = await prisma.userFeatureFlag.count({
     *   where: {
     *     // ... the filter for the UserFeatureFlags we want to count
     *   }
     * })
    **/
    count<T extends UserFeatureFlagCountArgs>(
      args?: Subset<T, UserFeatureFlagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserFeatureFlagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserFeatureFlag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeatureFlagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserFeatureFlagAggregateArgs>(args: Subset<T, UserFeatureFlagAggregateArgs>): Prisma.PrismaPromise<GetUserFeatureFlagAggregateType<T>>

    /**
     * Group by UserFeatureFlag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFeatureFlagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserFeatureFlagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserFeatureFlagGroupByArgs['orderBy'] }
        : { orderBy?: UserFeatureFlagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserFeatureFlagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserFeatureFlagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserFeatureFlag model
   */
  readonly fields: UserFeatureFlagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserFeatureFlag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserFeatureFlagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserFeatureFlag model
   */
  interface UserFeatureFlagFieldRefs {
    readonly id: FieldRef<"UserFeatureFlag", 'String'>
    readonly userId: FieldRef<"UserFeatureFlag", 'String'>
    readonly feature: FieldRef<"UserFeatureFlag", 'String'>
    readonly isEnabled: FieldRef<"UserFeatureFlag", 'Boolean'>
    readonly createdAt: FieldRef<"UserFeatureFlag", 'DateTime'>
    readonly updatedAt: FieldRef<"UserFeatureFlag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserFeatureFlag findUnique
   */
  export type UserFeatureFlagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeatureFlag
     */
    select?: UserFeatureFlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeatureFlag
     */
    omit?: UserFeatureFlagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureFlagInclude<ExtArgs> | null
    /**
     * Filter, which UserFeatureFlag to fetch.
     */
    where: UserFeatureFlagWhereUniqueInput
  }

  /**
   * UserFeatureFlag findUniqueOrThrow
   */
  export type UserFeatureFlagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeatureFlag
     */
    select?: UserFeatureFlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeatureFlag
     */
    omit?: UserFeatureFlagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureFlagInclude<ExtArgs> | null
    /**
     * Filter, which UserFeatureFlag to fetch.
     */
    where: UserFeatureFlagWhereUniqueInput
  }

  /**
   * UserFeatureFlag findFirst
   */
  export type UserFeatureFlagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeatureFlag
     */
    select?: UserFeatureFlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeatureFlag
     */
    omit?: UserFeatureFlagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureFlagInclude<ExtArgs> | null
    /**
     * Filter, which UserFeatureFlag to fetch.
     */
    where?: UserFeatureFlagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFeatureFlags to fetch.
     */
    orderBy?: UserFeatureFlagOrderByWithRelationInput | UserFeatureFlagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFeatureFlags.
     */
    cursor?: UserFeatureFlagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFeatureFlags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFeatureFlags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFeatureFlags.
     */
    distinct?: UserFeatureFlagScalarFieldEnum | UserFeatureFlagScalarFieldEnum[]
  }

  /**
   * UserFeatureFlag findFirstOrThrow
   */
  export type UserFeatureFlagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeatureFlag
     */
    select?: UserFeatureFlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeatureFlag
     */
    omit?: UserFeatureFlagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureFlagInclude<ExtArgs> | null
    /**
     * Filter, which UserFeatureFlag to fetch.
     */
    where?: UserFeatureFlagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFeatureFlags to fetch.
     */
    orderBy?: UserFeatureFlagOrderByWithRelationInput | UserFeatureFlagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFeatureFlags.
     */
    cursor?: UserFeatureFlagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFeatureFlags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFeatureFlags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFeatureFlags.
     */
    distinct?: UserFeatureFlagScalarFieldEnum | UserFeatureFlagScalarFieldEnum[]
  }

  /**
   * UserFeatureFlag findMany
   */
  export type UserFeatureFlagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeatureFlag
     */
    select?: UserFeatureFlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeatureFlag
     */
    omit?: UserFeatureFlagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureFlagInclude<ExtArgs> | null
    /**
     * Filter, which UserFeatureFlags to fetch.
     */
    where?: UserFeatureFlagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFeatureFlags to fetch.
     */
    orderBy?: UserFeatureFlagOrderByWithRelationInput | UserFeatureFlagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserFeatureFlags.
     */
    cursor?: UserFeatureFlagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFeatureFlags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFeatureFlags.
     */
    skip?: number
    distinct?: UserFeatureFlagScalarFieldEnum | UserFeatureFlagScalarFieldEnum[]
  }

  /**
   * UserFeatureFlag create
   */
  export type UserFeatureFlagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeatureFlag
     */
    select?: UserFeatureFlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeatureFlag
     */
    omit?: UserFeatureFlagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureFlagInclude<ExtArgs> | null
    /**
     * The data needed to create a UserFeatureFlag.
     */
    data: XOR<UserFeatureFlagCreateInput, UserFeatureFlagUncheckedCreateInput>
  }

  /**
   * UserFeatureFlag createMany
   */
  export type UserFeatureFlagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserFeatureFlags.
     */
    data: UserFeatureFlagCreateManyInput | UserFeatureFlagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserFeatureFlag createManyAndReturn
   */
  export type UserFeatureFlagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeatureFlag
     */
    select?: UserFeatureFlagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeatureFlag
     */
    omit?: UserFeatureFlagOmit<ExtArgs> | null
    /**
     * The data used to create many UserFeatureFlags.
     */
    data: UserFeatureFlagCreateManyInput | UserFeatureFlagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureFlagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserFeatureFlag update
   */
  export type UserFeatureFlagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeatureFlag
     */
    select?: UserFeatureFlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeatureFlag
     */
    omit?: UserFeatureFlagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureFlagInclude<ExtArgs> | null
    /**
     * The data needed to update a UserFeatureFlag.
     */
    data: XOR<UserFeatureFlagUpdateInput, UserFeatureFlagUncheckedUpdateInput>
    /**
     * Choose, which UserFeatureFlag to update.
     */
    where: UserFeatureFlagWhereUniqueInput
  }

  /**
   * UserFeatureFlag updateMany
   */
  export type UserFeatureFlagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserFeatureFlags.
     */
    data: XOR<UserFeatureFlagUpdateManyMutationInput, UserFeatureFlagUncheckedUpdateManyInput>
    /**
     * Filter which UserFeatureFlags to update
     */
    where?: UserFeatureFlagWhereInput
    /**
     * Limit how many UserFeatureFlags to update.
     */
    limit?: number
  }

  /**
   * UserFeatureFlag updateManyAndReturn
   */
  export type UserFeatureFlagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeatureFlag
     */
    select?: UserFeatureFlagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeatureFlag
     */
    omit?: UserFeatureFlagOmit<ExtArgs> | null
    /**
     * The data used to update UserFeatureFlags.
     */
    data: XOR<UserFeatureFlagUpdateManyMutationInput, UserFeatureFlagUncheckedUpdateManyInput>
    /**
     * Filter which UserFeatureFlags to update
     */
    where?: UserFeatureFlagWhereInput
    /**
     * Limit how many UserFeatureFlags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureFlagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserFeatureFlag upsert
   */
  export type UserFeatureFlagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeatureFlag
     */
    select?: UserFeatureFlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeatureFlag
     */
    omit?: UserFeatureFlagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureFlagInclude<ExtArgs> | null
    /**
     * The filter to search for the UserFeatureFlag to update in case it exists.
     */
    where: UserFeatureFlagWhereUniqueInput
    /**
     * In case the UserFeatureFlag found by the `where` argument doesn't exist, create a new UserFeatureFlag with this data.
     */
    create: XOR<UserFeatureFlagCreateInput, UserFeatureFlagUncheckedCreateInput>
    /**
     * In case the UserFeatureFlag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserFeatureFlagUpdateInput, UserFeatureFlagUncheckedUpdateInput>
  }

  /**
   * UserFeatureFlag delete
   */
  export type UserFeatureFlagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeatureFlag
     */
    select?: UserFeatureFlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeatureFlag
     */
    omit?: UserFeatureFlagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureFlagInclude<ExtArgs> | null
    /**
     * Filter which UserFeatureFlag to delete.
     */
    where: UserFeatureFlagWhereUniqueInput
  }

  /**
   * UserFeatureFlag deleteMany
   */
  export type UserFeatureFlagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFeatureFlags to delete
     */
    where?: UserFeatureFlagWhereInput
    /**
     * Limit how many UserFeatureFlags to delete.
     */
    limit?: number
  }

  /**
   * UserFeatureFlag without action
   */
  export type UserFeatureFlagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeatureFlag
     */
    select?: UserFeatureFlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeatureFlag
     */
    omit?: UserFeatureFlagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureFlagInclude<ExtArgs> | null
  }


  /**
   * Model UserObjective
   */

  export type AggregateUserObjective = {
    _count: UserObjectiveCountAggregateOutputType | null
    _min: UserObjectiveMinAggregateOutputType | null
    _max: UserObjectiveMaxAggregateOutputType | null
  }

  export type UserObjectiveMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.ObjectiveType | null
    note: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserObjectiveMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.ObjectiveType | null
    note: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserObjectiveCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    note: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserObjectiveMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    note?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserObjectiveMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    note?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserObjectiveCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    note?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserObjectiveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserObjective to aggregate.
     */
    where?: UserObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserObjectives to fetch.
     */
    orderBy?: UserObjectiveOrderByWithRelationInput | UserObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserObjectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserObjectives
    **/
    _count?: true | UserObjectiveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserObjectiveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserObjectiveMaxAggregateInputType
  }

  export type GetUserObjectiveAggregateType<T extends UserObjectiveAggregateArgs> = {
        [P in keyof T & keyof AggregateUserObjective]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserObjective[P]>
      : GetScalarType<T[P], AggregateUserObjective[P]>
  }




  export type UserObjectiveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserObjectiveWhereInput
    orderBy?: UserObjectiveOrderByWithAggregationInput | UserObjectiveOrderByWithAggregationInput[]
    by: UserObjectiveScalarFieldEnum[] | UserObjectiveScalarFieldEnum
    having?: UserObjectiveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserObjectiveCountAggregateInputType | true
    _min?: UserObjectiveMinAggregateInputType
    _max?: UserObjectiveMaxAggregateInputType
  }

  export type UserObjectiveGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.ObjectiveType
    note: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserObjectiveCountAggregateOutputType | null
    _min: UserObjectiveMinAggregateOutputType | null
    _max: UserObjectiveMaxAggregateOutputType | null
  }

  type GetUserObjectiveGroupByPayload<T extends UserObjectiveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserObjectiveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserObjectiveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserObjectiveGroupByOutputType[P]>
            : GetScalarType<T[P], UserObjectiveGroupByOutputType[P]>
        }
      >
    >


  export type UserObjectiveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userObjective"]>

  export type UserObjectiveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userObjective"]>

  export type UserObjectiveSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userObjective"]>

  export type UserObjectiveSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserObjectiveOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "note" | "createdAt" | "updatedAt", ExtArgs["result"]["userObjective"]>
  export type UserObjectiveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserObjectiveIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserObjectiveIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserObjectivePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserObjective"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.ObjectiveType
      note: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userObjective"]>
    composites: {}
  }

  type UserObjectiveGetPayload<S extends boolean | null | undefined | UserObjectiveDefaultArgs> = $Result.GetResult<Prisma.$UserObjectivePayload, S>

  type UserObjectiveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserObjectiveFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserObjectiveCountAggregateInputType | true
    }

  export interface UserObjectiveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserObjective'], meta: { name: 'UserObjective' } }
    /**
     * Find zero or one UserObjective that matches the filter.
     * @param {UserObjectiveFindUniqueArgs} args - Arguments to find a UserObjective
     * @example
     * // Get one UserObjective
     * const userObjective = await prisma.userObjective.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserObjectiveFindUniqueArgs>(args: SelectSubset<T, UserObjectiveFindUniqueArgs<ExtArgs>>): Prisma__UserObjectiveClient<$Result.GetResult<Prisma.$UserObjectivePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserObjective that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserObjectiveFindUniqueOrThrowArgs} args - Arguments to find a UserObjective
     * @example
     * // Get one UserObjective
     * const userObjective = await prisma.userObjective.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserObjectiveFindUniqueOrThrowArgs>(args: SelectSubset<T, UserObjectiveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserObjectiveClient<$Result.GetResult<Prisma.$UserObjectivePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserObjective that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserObjectiveFindFirstArgs} args - Arguments to find a UserObjective
     * @example
     * // Get one UserObjective
     * const userObjective = await prisma.userObjective.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserObjectiveFindFirstArgs>(args?: SelectSubset<T, UserObjectiveFindFirstArgs<ExtArgs>>): Prisma__UserObjectiveClient<$Result.GetResult<Prisma.$UserObjectivePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserObjective that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserObjectiveFindFirstOrThrowArgs} args - Arguments to find a UserObjective
     * @example
     * // Get one UserObjective
     * const userObjective = await prisma.userObjective.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserObjectiveFindFirstOrThrowArgs>(args?: SelectSubset<T, UserObjectiveFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserObjectiveClient<$Result.GetResult<Prisma.$UserObjectivePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserObjectives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserObjectiveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserObjectives
     * const userObjectives = await prisma.userObjective.findMany()
     * 
     * // Get first 10 UserObjectives
     * const userObjectives = await prisma.userObjective.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userObjectiveWithIdOnly = await prisma.userObjective.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserObjectiveFindManyArgs>(args?: SelectSubset<T, UserObjectiveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserObjectivePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserObjective.
     * @param {UserObjectiveCreateArgs} args - Arguments to create a UserObjective.
     * @example
     * // Create one UserObjective
     * const UserObjective = await prisma.userObjective.create({
     *   data: {
     *     // ... data to create a UserObjective
     *   }
     * })
     * 
     */
    create<T extends UserObjectiveCreateArgs>(args: SelectSubset<T, UserObjectiveCreateArgs<ExtArgs>>): Prisma__UserObjectiveClient<$Result.GetResult<Prisma.$UserObjectivePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserObjectives.
     * @param {UserObjectiveCreateManyArgs} args - Arguments to create many UserObjectives.
     * @example
     * // Create many UserObjectives
     * const userObjective = await prisma.userObjective.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserObjectiveCreateManyArgs>(args?: SelectSubset<T, UserObjectiveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserObjectives and returns the data saved in the database.
     * @param {UserObjectiveCreateManyAndReturnArgs} args - Arguments to create many UserObjectives.
     * @example
     * // Create many UserObjectives
     * const userObjective = await prisma.userObjective.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserObjectives and only return the `id`
     * const userObjectiveWithIdOnly = await prisma.userObjective.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserObjectiveCreateManyAndReturnArgs>(args?: SelectSubset<T, UserObjectiveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserObjectivePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserObjective.
     * @param {UserObjectiveDeleteArgs} args - Arguments to delete one UserObjective.
     * @example
     * // Delete one UserObjective
     * const UserObjective = await prisma.userObjective.delete({
     *   where: {
     *     // ... filter to delete one UserObjective
     *   }
     * })
     * 
     */
    delete<T extends UserObjectiveDeleteArgs>(args: SelectSubset<T, UserObjectiveDeleteArgs<ExtArgs>>): Prisma__UserObjectiveClient<$Result.GetResult<Prisma.$UserObjectivePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserObjective.
     * @param {UserObjectiveUpdateArgs} args - Arguments to update one UserObjective.
     * @example
     * // Update one UserObjective
     * const userObjective = await prisma.userObjective.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserObjectiveUpdateArgs>(args: SelectSubset<T, UserObjectiveUpdateArgs<ExtArgs>>): Prisma__UserObjectiveClient<$Result.GetResult<Prisma.$UserObjectivePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserObjectives.
     * @param {UserObjectiveDeleteManyArgs} args - Arguments to filter UserObjectives to delete.
     * @example
     * // Delete a few UserObjectives
     * const { count } = await prisma.userObjective.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserObjectiveDeleteManyArgs>(args?: SelectSubset<T, UserObjectiveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserObjectives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserObjectiveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserObjectives
     * const userObjective = await prisma.userObjective.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserObjectiveUpdateManyArgs>(args: SelectSubset<T, UserObjectiveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserObjectives and returns the data updated in the database.
     * @param {UserObjectiveUpdateManyAndReturnArgs} args - Arguments to update many UserObjectives.
     * @example
     * // Update many UserObjectives
     * const userObjective = await prisma.userObjective.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserObjectives and only return the `id`
     * const userObjectiveWithIdOnly = await prisma.userObjective.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserObjectiveUpdateManyAndReturnArgs>(args: SelectSubset<T, UserObjectiveUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserObjectivePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserObjective.
     * @param {UserObjectiveUpsertArgs} args - Arguments to update or create a UserObjective.
     * @example
     * // Update or create a UserObjective
     * const userObjective = await prisma.userObjective.upsert({
     *   create: {
     *     // ... data to create a UserObjective
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserObjective we want to update
     *   }
     * })
     */
    upsert<T extends UserObjectiveUpsertArgs>(args: SelectSubset<T, UserObjectiveUpsertArgs<ExtArgs>>): Prisma__UserObjectiveClient<$Result.GetResult<Prisma.$UserObjectivePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserObjectives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserObjectiveCountArgs} args - Arguments to filter UserObjectives to count.
     * @example
     * // Count the number of UserObjectives
     * const count = await prisma.userObjective.count({
     *   where: {
     *     // ... the filter for the UserObjectives we want to count
     *   }
     * })
    **/
    count<T extends UserObjectiveCountArgs>(
      args?: Subset<T, UserObjectiveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserObjectiveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserObjective.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserObjectiveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserObjectiveAggregateArgs>(args: Subset<T, UserObjectiveAggregateArgs>): Prisma.PrismaPromise<GetUserObjectiveAggregateType<T>>

    /**
     * Group by UserObjective.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserObjectiveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserObjectiveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserObjectiveGroupByArgs['orderBy'] }
        : { orderBy?: UserObjectiveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserObjectiveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserObjectiveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserObjective model
   */
  readonly fields: UserObjectiveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserObjective.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserObjectiveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserObjective model
   */
  interface UserObjectiveFieldRefs {
    readonly id: FieldRef<"UserObjective", 'String'>
    readonly userId: FieldRef<"UserObjective", 'String'>
    readonly type: FieldRef<"UserObjective", 'ObjectiveType'>
    readonly note: FieldRef<"UserObjective", 'String'>
    readonly createdAt: FieldRef<"UserObjective", 'DateTime'>
    readonly updatedAt: FieldRef<"UserObjective", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserObjective findUnique
   */
  export type UserObjectiveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserObjective
     */
    select?: UserObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserObjective
     */
    omit?: UserObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which UserObjective to fetch.
     */
    where: UserObjectiveWhereUniqueInput
  }

  /**
   * UserObjective findUniqueOrThrow
   */
  export type UserObjectiveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserObjective
     */
    select?: UserObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserObjective
     */
    omit?: UserObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which UserObjective to fetch.
     */
    where: UserObjectiveWhereUniqueInput
  }

  /**
   * UserObjective findFirst
   */
  export type UserObjectiveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserObjective
     */
    select?: UserObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserObjective
     */
    omit?: UserObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which UserObjective to fetch.
     */
    where?: UserObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserObjectives to fetch.
     */
    orderBy?: UserObjectiveOrderByWithRelationInput | UserObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserObjectives.
     */
    cursor?: UserObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserObjectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserObjectives.
     */
    distinct?: UserObjectiveScalarFieldEnum | UserObjectiveScalarFieldEnum[]
  }

  /**
   * UserObjective findFirstOrThrow
   */
  export type UserObjectiveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserObjective
     */
    select?: UserObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserObjective
     */
    omit?: UserObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which UserObjective to fetch.
     */
    where?: UserObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserObjectives to fetch.
     */
    orderBy?: UserObjectiveOrderByWithRelationInput | UserObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserObjectives.
     */
    cursor?: UserObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserObjectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserObjectives.
     */
    distinct?: UserObjectiveScalarFieldEnum | UserObjectiveScalarFieldEnum[]
  }

  /**
   * UserObjective findMany
   */
  export type UserObjectiveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserObjective
     */
    select?: UserObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserObjective
     */
    omit?: UserObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which UserObjectives to fetch.
     */
    where?: UserObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserObjectives to fetch.
     */
    orderBy?: UserObjectiveOrderByWithRelationInput | UserObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserObjectives.
     */
    cursor?: UserObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserObjectives.
     */
    skip?: number
    distinct?: UserObjectiveScalarFieldEnum | UserObjectiveScalarFieldEnum[]
  }

  /**
   * UserObjective create
   */
  export type UserObjectiveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserObjective
     */
    select?: UserObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserObjective
     */
    omit?: UserObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserObjectiveInclude<ExtArgs> | null
    /**
     * The data needed to create a UserObjective.
     */
    data: XOR<UserObjectiveCreateInput, UserObjectiveUncheckedCreateInput>
  }

  /**
   * UserObjective createMany
   */
  export type UserObjectiveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserObjectives.
     */
    data: UserObjectiveCreateManyInput | UserObjectiveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserObjective createManyAndReturn
   */
  export type UserObjectiveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserObjective
     */
    select?: UserObjectiveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserObjective
     */
    omit?: UserObjectiveOmit<ExtArgs> | null
    /**
     * The data used to create many UserObjectives.
     */
    data: UserObjectiveCreateManyInput | UserObjectiveCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserObjectiveIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserObjective update
   */
  export type UserObjectiveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserObjective
     */
    select?: UserObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserObjective
     */
    omit?: UserObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserObjectiveInclude<ExtArgs> | null
    /**
     * The data needed to update a UserObjective.
     */
    data: XOR<UserObjectiveUpdateInput, UserObjectiveUncheckedUpdateInput>
    /**
     * Choose, which UserObjective to update.
     */
    where: UserObjectiveWhereUniqueInput
  }

  /**
   * UserObjective updateMany
   */
  export type UserObjectiveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserObjectives.
     */
    data: XOR<UserObjectiveUpdateManyMutationInput, UserObjectiveUncheckedUpdateManyInput>
    /**
     * Filter which UserObjectives to update
     */
    where?: UserObjectiveWhereInput
    /**
     * Limit how many UserObjectives to update.
     */
    limit?: number
  }

  /**
   * UserObjective updateManyAndReturn
   */
  export type UserObjectiveUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserObjective
     */
    select?: UserObjectiveSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserObjective
     */
    omit?: UserObjectiveOmit<ExtArgs> | null
    /**
     * The data used to update UserObjectives.
     */
    data: XOR<UserObjectiveUpdateManyMutationInput, UserObjectiveUncheckedUpdateManyInput>
    /**
     * Filter which UserObjectives to update
     */
    where?: UserObjectiveWhereInput
    /**
     * Limit how many UserObjectives to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserObjectiveIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserObjective upsert
   */
  export type UserObjectiveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserObjective
     */
    select?: UserObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserObjective
     */
    omit?: UserObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserObjectiveInclude<ExtArgs> | null
    /**
     * The filter to search for the UserObjective to update in case it exists.
     */
    where: UserObjectiveWhereUniqueInput
    /**
     * In case the UserObjective found by the `where` argument doesn't exist, create a new UserObjective with this data.
     */
    create: XOR<UserObjectiveCreateInput, UserObjectiveUncheckedCreateInput>
    /**
     * In case the UserObjective was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserObjectiveUpdateInput, UserObjectiveUncheckedUpdateInput>
  }

  /**
   * UserObjective delete
   */
  export type UserObjectiveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserObjective
     */
    select?: UserObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserObjective
     */
    omit?: UserObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserObjectiveInclude<ExtArgs> | null
    /**
     * Filter which UserObjective to delete.
     */
    where: UserObjectiveWhereUniqueInput
  }

  /**
   * UserObjective deleteMany
   */
  export type UserObjectiveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserObjectives to delete
     */
    where?: UserObjectiveWhereInput
    /**
     * Limit how many UserObjectives to delete.
     */
    limit?: number
  }

  /**
   * UserObjective without action
   */
  export type UserObjectiveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserObjective
     */
    select?: UserObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserObjective
     */
    omit?: UserObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserObjectiveInclude<ExtArgs> | null
  }


  /**
   * Model ProfileChangeLog
   */

  export type AggregateProfileChangeLog = {
    _count: ProfileChangeLogCountAggregateOutputType | null
    _min: ProfileChangeLogMinAggregateOutputType | null
    _max: ProfileChangeLogMaxAggregateOutputType | null
  }

  export type ProfileChangeLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    changeType: $Enums.ChangeType | null
    details: string | null
    changedAt: Date | null
  }

  export type ProfileChangeLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    changeType: $Enums.ChangeType | null
    details: string | null
    changedAt: Date | null
  }

  export type ProfileChangeLogCountAggregateOutputType = {
    id: number
    userId: number
    changeType: number
    details: number
    changedAt: number
    _all: number
  }


  export type ProfileChangeLogMinAggregateInputType = {
    id?: true
    userId?: true
    changeType?: true
    details?: true
    changedAt?: true
  }

  export type ProfileChangeLogMaxAggregateInputType = {
    id?: true
    userId?: true
    changeType?: true
    details?: true
    changedAt?: true
  }

  export type ProfileChangeLogCountAggregateInputType = {
    id?: true
    userId?: true
    changeType?: true
    details?: true
    changedAt?: true
    _all?: true
  }

  export type ProfileChangeLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileChangeLog to aggregate.
     */
    where?: ProfileChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileChangeLogs to fetch.
     */
    orderBy?: ProfileChangeLogOrderByWithRelationInput | ProfileChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProfileChangeLogs
    **/
    _count?: true | ProfileChangeLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileChangeLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileChangeLogMaxAggregateInputType
  }

  export type GetProfileChangeLogAggregateType<T extends ProfileChangeLogAggregateArgs> = {
        [P in keyof T & keyof AggregateProfileChangeLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfileChangeLog[P]>
      : GetScalarType<T[P], AggregateProfileChangeLog[P]>
  }




  export type ProfileChangeLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileChangeLogWhereInput
    orderBy?: ProfileChangeLogOrderByWithAggregationInput | ProfileChangeLogOrderByWithAggregationInput[]
    by: ProfileChangeLogScalarFieldEnum[] | ProfileChangeLogScalarFieldEnum
    having?: ProfileChangeLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileChangeLogCountAggregateInputType | true
    _min?: ProfileChangeLogMinAggregateInputType
    _max?: ProfileChangeLogMaxAggregateInputType
  }

  export type ProfileChangeLogGroupByOutputType = {
    id: string
    userId: string
    changeType: $Enums.ChangeType
    details: string | null
    changedAt: Date
    _count: ProfileChangeLogCountAggregateOutputType | null
    _min: ProfileChangeLogMinAggregateOutputType | null
    _max: ProfileChangeLogMaxAggregateOutputType | null
  }

  type GetProfileChangeLogGroupByPayload<T extends ProfileChangeLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileChangeLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileChangeLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileChangeLogGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileChangeLogGroupByOutputType[P]>
        }
      >
    >


  export type ProfileChangeLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    changeType?: boolean
    details?: boolean
    changedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileChangeLog"]>

  export type ProfileChangeLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    changeType?: boolean
    details?: boolean
    changedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileChangeLog"]>

  export type ProfileChangeLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    changeType?: boolean
    details?: boolean
    changedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileChangeLog"]>

  export type ProfileChangeLogSelectScalar = {
    id?: boolean
    userId?: boolean
    changeType?: boolean
    details?: boolean
    changedAt?: boolean
  }

  export type ProfileChangeLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "changeType" | "details" | "changedAt", ExtArgs["result"]["profileChangeLog"]>
  export type ProfileChangeLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProfileChangeLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProfileChangeLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProfileChangeLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProfileChangeLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      changeType: $Enums.ChangeType
      details: string | null
      changedAt: Date
    }, ExtArgs["result"]["profileChangeLog"]>
    composites: {}
  }

  type ProfileChangeLogGetPayload<S extends boolean | null | undefined | ProfileChangeLogDefaultArgs> = $Result.GetResult<Prisma.$ProfileChangeLogPayload, S>

  type ProfileChangeLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProfileChangeLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfileChangeLogCountAggregateInputType | true
    }

  export interface ProfileChangeLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProfileChangeLog'], meta: { name: 'ProfileChangeLog' } }
    /**
     * Find zero or one ProfileChangeLog that matches the filter.
     * @param {ProfileChangeLogFindUniqueArgs} args - Arguments to find a ProfileChangeLog
     * @example
     * // Get one ProfileChangeLog
     * const profileChangeLog = await prisma.profileChangeLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileChangeLogFindUniqueArgs>(args: SelectSubset<T, ProfileChangeLogFindUniqueArgs<ExtArgs>>): Prisma__ProfileChangeLogClient<$Result.GetResult<Prisma.$ProfileChangeLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProfileChangeLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProfileChangeLogFindUniqueOrThrowArgs} args - Arguments to find a ProfileChangeLog
     * @example
     * // Get one ProfileChangeLog
     * const profileChangeLog = await prisma.profileChangeLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileChangeLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileChangeLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileChangeLogClient<$Result.GetResult<Prisma.$ProfileChangeLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProfileChangeLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileChangeLogFindFirstArgs} args - Arguments to find a ProfileChangeLog
     * @example
     * // Get one ProfileChangeLog
     * const profileChangeLog = await prisma.profileChangeLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileChangeLogFindFirstArgs>(args?: SelectSubset<T, ProfileChangeLogFindFirstArgs<ExtArgs>>): Prisma__ProfileChangeLogClient<$Result.GetResult<Prisma.$ProfileChangeLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProfileChangeLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileChangeLogFindFirstOrThrowArgs} args - Arguments to find a ProfileChangeLog
     * @example
     * // Get one ProfileChangeLog
     * const profileChangeLog = await prisma.profileChangeLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileChangeLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileChangeLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileChangeLogClient<$Result.GetResult<Prisma.$ProfileChangeLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProfileChangeLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileChangeLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProfileChangeLogs
     * const profileChangeLogs = await prisma.profileChangeLog.findMany()
     * 
     * // Get first 10 ProfileChangeLogs
     * const profileChangeLogs = await prisma.profileChangeLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileChangeLogWithIdOnly = await prisma.profileChangeLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileChangeLogFindManyArgs>(args?: SelectSubset<T, ProfileChangeLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileChangeLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProfileChangeLog.
     * @param {ProfileChangeLogCreateArgs} args - Arguments to create a ProfileChangeLog.
     * @example
     * // Create one ProfileChangeLog
     * const ProfileChangeLog = await prisma.profileChangeLog.create({
     *   data: {
     *     // ... data to create a ProfileChangeLog
     *   }
     * })
     * 
     */
    create<T extends ProfileChangeLogCreateArgs>(args: SelectSubset<T, ProfileChangeLogCreateArgs<ExtArgs>>): Prisma__ProfileChangeLogClient<$Result.GetResult<Prisma.$ProfileChangeLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProfileChangeLogs.
     * @param {ProfileChangeLogCreateManyArgs} args - Arguments to create many ProfileChangeLogs.
     * @example
     * // Create many ProfileChangeLogs
     * const profileChangeLog = await prisma.profileChangeLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileChangeLogCreateManyArgs>(args?: SelectSubset<T, ProfileChangeLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProfileChangeLogs and returns the data saved in the database.
     * @param {ProfileChangeLogCreateManyAndReturnArgs} args - Arguments to create many ProfileChangeLogs.
     * @example
     * // Create many ProfileChangeLogs
     * const profileChangeLog = await prisma.profileChangeLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProfileChangeLogs and only return the `id`
     * const profileChangeLogWithIdOnly = await prisma.profileChangeLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileChangeLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileChangeLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileChangeLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProfileChangeLog.
     * @param {ProfileChangeLogDeleteArgs} args - Arguments to delete one ProfileChangeLog.
     * @example
     * // Delete one ProfileChangeLog
     * const ProfileChangeLog = await prisma.profileChangeLog.delete({
     *   where: {
     *     // ... filter to delete one ProfileChangeLog
     *   }
     * })
     * 
     */
    delete<T extends ProfileChangeLogDeleteArgs>(args: SelectSubset<T, ProfileChangeLogDeleteArgs<ExtArgs>>): Prisma__ProfileChangeLogClient<$Result.GetResult<Prisma.$ProfileChangeLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProfileChangeLog.
     * @param {ProfileChangeLogUpdateArgs} args - Arguments to update one ProfileChangeLog.
     * @example
     * // Update one ProfileChangeLog
     * const profileChangeLog = await prisma.profileChangeLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileChangeLogUpdateArgs>(args: SelectSubset<T, ProfileChangeLogUpdateArgs<ExtArgs>>): Prisma__ProfileChangeLogClient<$Result.GetResult<Prisma.$ProfileChangeLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProfileChangeLogs.
     * @param {ProfileChangeLogDeleteManyArgs} args - Arguments to filter ProfileChangeLogs to delete.
     * @example
     * // Delete a few ProfileChangeLogs
     * const { count } = await prisma.profileChangeLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileChangeLogDeleteManyArgs>(args?: SelectSubset<T, ProfileChangeLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfileChangeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileChangeLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProfileChangeLogs
     * const profileChangeLog = await prisma.profileChangeLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileChangeLogUpdateManyArgs>(args: SelectSubset<T, ProfileChangeLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfileChangeLogs and returns the data updated in the database.
     * @param {ProfileChangeLogUpdateManyAndReturnArgs} args - Arguments to update many ProfileChangeLogs.
     * @example
     * // Update many ProfileChangeLogs
     * const profileChangeLog = await prisma.profileChangeLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProfileChangeLogs and only return the `id`
     * const profileChangeLogWithIdOnly = await prisma.profileChangeLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProfileChangeLogUpdateManyAndReturnArgs>(args: SelectSubset<T, ProfileChangeLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileChangeLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProfileChangeLog.
     * @param {ProfileChangeLogUpsertArgs} args - Arguments to update or create a ProfileChangeLog.
     * @example
     * // Update or create a ProfileChangeLog
     * const profileChangeLog = await prisma.profileChangeLog.upsert({
     *   create: {
     *     // ... data to create a ProfileChangeLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProfileChangeLog we want to update
     *   }
     * })
     */
    upsert<T extends ProfileChangeLogUpsertArgs>(args: SelectSubset<T, ProfileChangeLogUpsertArgs<ExtArgs>>): Prisma__ProfileChangeLogClient<$Result.GetResult<Prisma.$ProfileChangeLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProfileChangeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileChangeLogCountArgs} args - Arguments to filter ProfileChangeLogs to count.
     * @example
     * // Count the number of ProfileChangeLogs
     * const count = await prisma.profileChangeLog.count({
     *   where: {
     *     // ... the filter for the ProfileChangeLogs we want to count
     *   }
     * })
    **/
    count<T extends ProfileChangeLogCountArgs>(
      args?: Subset<T, ProfileChangeLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileChangeLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProfileChangeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileChangeLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileChangeLogAggregateArgs>(args: Subset<T, ProfileChangeLogAggregateArgs>): Prisma.PrismaPromise<GetProfileChangeLogAggregateType<T>>

    /**
     * Group by ProfileChangeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileChangeLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileChangeLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileChangeLogGroupByArgs['orderBy'] }
        : { orderBy?: ProfileChangeLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileChangeLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileChangeLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProfileChangeLog model
   */
  readonly fields: ProfileChangeLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProfileChangeLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileChangeLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProfileChangeLog model
   */
  interface ProfileChangeLogFieldRefs {
    readonly id: FieldRef<"ProfileChangeLog", 'String'>
    readonly userId: FieldRef<"ProfileChangeLog", 'String'>
    readonly changeType: FieldRef<"ProfileChangeLog", 'ChangeType'>
    readonly details: FieldRef<"ProfileChangeLog", 'String'>
    readonly changedAt: FieldRef<"ProfileChangeLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProfileChangeLog findUnique
   */
  export type ProfileChangeLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileChangeLog
     */
    select?: ProfileChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileChangeLog
     */
    omit?: ProfileChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which ProfileChangeLog to fetch.
     */
    where: ProfileChangeLogWhereUniqueInput
  }

  /**
   * ProfileChangeLog findUniqueOrThrow
   */
  export type ProfileChangeLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileChangeLog
     */
    select?: ProfileChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileChangeLog
     */
    omit?: ProfileChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which ProfileChangeLog to fetch.
     */
    where: ProfileChangeLogWhereUniqueInput
  }

  /**
   * ProfileChangeLog findFirst
   */
  export type ProfileChangeLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileChangeLog
     */
    select?: ProfileChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileChangeLog
     */
    omit?: ProfileChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which ProfileChangeLog to fetch.
     */
    where?: ProfileChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileChangeLogs to fetch.
     */
    orderBy?: ProfileChangeLogOrderByWithRelationInput | ProfileChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileChangeLogs.
     */
    cursor?: ProfileChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileChangeLogs.
     */
    distinct?: ProfileChangeLogScalarFieldEnum | ProfileChangeLogScalarFieldEnum[]
  }

  /**
   * ProfileChangeLog findFirstOrThrow
   */
  export type ProfileChangeLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileChangeLog
     */
    select?: ProfileChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileChangeLog
     */
    omit?: ProfileChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which ProfileChangeLog to fetch.
     */
    where?: ProfileChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileChangeLogs to fetch.
     */
    orderBy?: ProfileChangeLogOrderByWithRelationInput | ProfileChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileChangeLogs.
     */
    cursor?: ProfileChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileChangeLogs.
     */
    distinct?: ProfileChangeLogScalarFieldEnum | ProfileChangeLogScalarFieldEnum[]
  }

  /**
   * ProfileChangeLog findMany
   */
  export type ProfileChangeLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileChangeLog
     */
    select?: ProfileChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileChangeLog
     */
    omit?: ProfileChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which ProfileChangeLogs to fetch.
     */
    where?: ProfileChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileChangeLogs to fetch.
     */
    orderBy?: ProfileChangeLogOrderByWithRelationInput | ProfileChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProfileChangeLogs.
     */
    cursor?: ProfileChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileChangeLogs.
     */
    skip?: number
    distinct?: ProfileChangeLogScalarFieldEnum | ProfileChangeLogScalarFieldEnum[]
  }

  /**
   * ProfileChangeLog create
   */
  export type ProfileChangeLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileChangeLog
     */
    select?: ProfileChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileChangeLog
     */
    omit?: ProfileChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileChangeLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ProfileChangeLog.
     */
    data: XOR<ProfileChangeLogCreateInput, ProfileChangeLogUncheckedCreateInput>
  }

  /**
   * ProfileChangeLog createMany
   */
  export type ProfileChangeLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProfileChangeLogs.
     */
    data: ProfileChangeLogCreateManyInput | ProfileChangeLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProfileChangeLog createManyAndReturn
   */
  export type ProfileChangeLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileChangeLog
     */
    select?: ProfileChangeLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileChangeLog
     */
    omit?: ProfileChangeLogOmit<ExtArgs> | null
    /**
     * The data used to create many ProfileChangeLogs.
     */
    data: ProfileChangeLogCreateManyInput | ProfileChangeLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileChangeLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProfileChangeLog update
   */
  export type ProfileChangeLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileChangeLog
     */
    select?: ProfileChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileChangeLog
     */
    omit?: ProfileChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileChangeLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ProfileChangeLog.
     */
    data: XOR<ProfileChangeLogUpdateInput, ProfileChangeLogUncheckedUpdateInput>
    /**
     * Choose, which ProfileChangeLog to update.
     */
    where: ProfileChangeLogWhereUniqueInput
  }

  /**
   * ProfileChangeLog updateMany
   */
  export type ProfileChangeLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProfileChangeLogs.
     */
    data: XOR<ProfileChangeLogUpdateManyMutationInput, ProfileChangeLogUncheckedUpdateManyInput>
    /**
     * Filter which ProfileChangeLogs to update
     */
    where?: ProfileChangeLogWhereInput
    /**
     * Limit how many ProfileChangeLogs to update.
     */
    limit?: number
  }

  /**
   * ProfileChangeLog updateManyAndReturn
   */
  export type ProfileChangeLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileChangeLog
     */
    select?: ProfileChangeLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileChangeLog
     */
    omit?: ProfileChangeLogOmit<ExtArgs> | null
    /**
     * The data used to update ProfileChangeLogs.
     */
    data: XOR<ProfileChangeLogUpdateManyMutationInput, ProfileChangeLogUncheckedUpdateManyInput>
    /**
     * Filter which ProfileChangeLogs to update
     */
    where?: ProfileChangeLogWhereInput
    /**
     * Limit how many ProfileChangeLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileChangeLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProfileChangeLog upsert
   */
  export type ProfileChangeLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileChangeLog
     */
    select?: ProfileChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileChangeLog
     */
    omit?: ProfileChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileChangeLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ProfileChangeLog to update in case it exists.
     */
    where: ProfileChangeLogWhereUniqueInput
    /**
     * In case the ProfileChangeLog found by the `where` argument doesn't exist, create a new ProfileChangeLog with this data.
     */
    create: XOR<ProfileChangeLogCreateInput, ProfileChangeLogUncheckedCreateInput>
    /**
     * In case the ProfileChangeLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileChangeLogUpdateInput, ProfileChangeLogUncheckedUpdateInput>
  }

  /**
   * ProfileChangeLog delete
   */
  export type ProfileChangeLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileChangeLog
     */
    select?: ProfileChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileChangeLog
     */
    omit?: ProfileChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileChangeLogInclude<ExtArgs> | null
    /**
     * Filter which ProfileChangeLog to delete.
     */
    where: ProfileChangeLogWhereUniqueInput
  }

  /**
   * ProfileChangeLog deleteMany
   */
  export type ProfileChangeLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileChangeLogs to delete
     */
    where?: ProfileChangeLogWhereInput
    /**
     * Limit how many ProfileChangeLogs to delete.
     */
    limit?: number
  }

  /**
   * ProfileChangeLog without action
   */
  export type ProfileChangeLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileChangeLog
     */
    select?: ProfileChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileChangeLog
     */
    omit?: ProfileChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileChangeLogInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    birthDate: Date | null
    isMenopausal: boolean | null
    objective: string | null
    sportFrequency: $Enums.SportFrequency | null
    profileType: $Enums.ProfileType | null
    contextType: $Enums.ContextType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    birthDate: Date | null
    isMenopausal: boolean | null
    objective: string | null
    sportFrequency: $Enums.SportFrequency | null
    profileType: $Enums.ProfileType | null
    contextType: $Enums.ContextType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    firstName: number
    birthDate: number
    isMenopausal: number
    objective: number
    sportFrequency: number
    profileType: number
    contextType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    birthDate?: true
    isMenopausal?: true
    objective?: true
    sportFrequency?: true
    profileType?: true
    contextType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    birthDate?: true
    isMenopausal?: true
    objective?: true
    sportFrequency?: true
    profileType?: true
    contextType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    birthDate?: true
    isMenopausal?: true
    objective?: true
    sportFrequency?: true
    profileType?: true
    contextType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    firstName: string | null
    birthDate: Date | null
    isMenopausal: boolean
    objective: string | null
    sportFrequency: $Enums.SportFrequency | null
    profileType: $Enums.ProfileType
    contextType: $Enums.ContextType
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    birthDate?: boolean
    isMenopausal?: boolean
    objective?: boolean
    sportFrequency?: boolean
    profileType?: boolean
    contextType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cycles?: boolean | User$cyclesArgs<ExtArgs>
    programs?: boolean | User$programsArgs<ExtArgs>
    moodTracks?: boolean | User$moodTracksArgs<ExtArgs>
    userSettings?: boolean | User$userSettingsArgs<ExtArgs>
    reminderSettings?: boolean | User$reminderSettingsArgs<ExtArgs>
    userFeatureFlags?: boolean | User$userFeatureFlagsArgs<ExtArgs>
    userObjectives?: boolean | User$userObjectivesArgs<ExtArgs>
    profileChangeLogs?: boolean | User$profileChangeLogsArgs<ExtArgs>
    cycleProfileConfig?: boolean | User$cycleProfileConfigArgs<ExtArgs>
    symptomLogs?: boolean | User$symptomLogsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    externalSyncs?: boolean | User$externalSyncsArgs<ExtArgs>
    journalEntries?: boolean | User$journalEntriesArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    logs?: boolean | User$logsArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    authSessions?: boolean | User$authSessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    birthDate?: boolean
    isMenopausal?: boolean
    objective?: boolean
    sportFrequency?: boolean
    profileType?: boolean
    contextType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    birthDate?: boolean
    isMenopausal?: boolean
    objective?: boolean
    sportFrequency?: boolean
    profileType?: boolean
    contextType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    birthDate?: boolean
    isMenopausal?: boolean
    objective?: boolean
    sportFrequency?: boolean
    profileType?: boolean
    contextType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "passwordHash" | "firstName" | "birthDate" | "isMenopausal" | "objective" | "sportFrequency" | "profileType" | "contextType" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cycles?: boolean | User$cyclesArgs<ExtArgs>
    programs?: boolean | User$programsArgs<ExtArgs>
    moodTracks?: boolean | User$moodTracksArgs<ExtArgs>
    userSettings?: boolean | User$userSettingsArgs<ExtArgs>
    reminderSettings?: boolean | User$reminderSettingsArgs<ExtArgs>
    userFeatureFlags?: boolean | User$userFeatureFlagsArgs<ExtArgs>
    userObjectives?: boolean | User$userObjectivesArgs<ExtArgs>
    profileChangeLogs?: boolean | User$profileChangeLogsArgs<ExtArgs>
    cycleProfileConfig?: boolean | User$cycleProfileConfigArgs<ExtArgs>
    symptomLogs?: boolean | User$symptomLogsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    externalSyncs?: boolean | User$externalSyncsArgs<ExtArgs>
    journalEntries?: boolean | User$journalEntriesArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    logs?: boolean | User$logsArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    authSessions?: boolean | User$authSessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      cycles: Prisma.$CyclePayload<ExtArgs>[]
      programs: Prisma.$ProgramPayload<ExtArgs>[]
      moodTracks: Prisma.$MoodTrackPayload<ExtArgs>[]
      userSettings: Prisma.$UserSettingsPayload<ExtArgs> | null
      reminderSettings: Prisma.$ReminderSettingsPayload<ExtArgs>[]
      userFeatureFlags: Prisma.$UserFeatureFlagPayload<ExtArgs>[]
      userObjectives: Prisma.$UserObjectivePayload<ExtArgs>[]
      profileChangeLogs: Prisma.$ProfileChangeLogPayload<ExtArgs>[]
      cycleProfileConfig: Prisma.$CycleProfileConfigPayload<ExtArgs> | null
      symptomLogs: Prisma.$SymptomLogPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      externalSyncs: Prisma.$ExternalSyncPayload<ExtArgs>[]
      journalEntries: Prisma.$JournalEntryPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      logs: Prisma.$LogPayload<ExtArgs>[]
      refreshTokens: Prisma.$RefreshTokenPayload<ExtArgs>[]
      authSessions: Prisma.$AuthSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      firstName: string | null
      birthDate: Date | null
      isMenopausal: boolean
      objective: string | null
      sportFrequency: $Enums.SportFrequency | null
      profileType: $Enums.ProfileType
      contextType: $Enums.ContextType
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cycles<T extends User$cyclesArgs<ExtArgs> = {}>(args?: Subset<T, User$cyclesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CyclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    programs<T extends User$programsArgs<ExtArgs> = {}>(args?: Subset<T, User$programsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    moodTracks<T extends User$moodTracksArgs<ExtArgs> = {}>(args?: Subset<T, User$moodTracksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoodTrackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userSettings<T extends User$userSettingsArgs<ExtArgs> = {}>(args?: Subset<T, User$userSettingsArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reminderSettings<T extends User$reminderSettingsArgs<ExtArgs> = {}>(args?: Subset<T, User$reminderSettingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReminderSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userFeatureFlags<T extends User$userFeatureFlagsArgs<ExtArgs> = {}>(args?: Subset<T, User$userFeatureFlagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFeatureFlagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userObjectives<T extends User$userObjectivesArgs<ExtArgs> = {}>(args?: Subset<T, User$userObjectivesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserObjectivePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    profileChangeLogs<T extends User$profileChangeLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$profileChangeLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileChangeLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cycleProfileConfig<T extends User$cycleProfileConfigArgs<ExtArgs> = {}>(args?: Subset<T, User$cycleProfileConfigArgs<ExtArgs>>): Prisma__CycleProfileConfigClient<$Result.GetResult<Prisma.$CycleProfileConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    symptomLogs<T extends User$symptomLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$symptomLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SymptomLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    externalSyncs<T extends User$externalSyncsArgs<ExtArgs> = {}>(args?: Subset<T, User$externalSyncsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExternalSyncPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    journalEntries<T extends User$journalEntriesArgs<ExtArgs> = {}>(args?: Subset<T, User$journalEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    logs<T extends User$logsArgs<ExtArgs> = {}>(args?: Subset<T, User$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    refreshTokens<T extends User$refreshTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$refreshTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    authSessions<T extends User$authSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$authSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly birthDate: FieldRef<"User", 'DateTime'>
    readonly isMenopausal: FieldRef<"User", 'Boolean'>
    readonly objective: FieldRef<"User", 'String'>
    readonly sportFrequency: FieldRef<"User", 'SportFrequency'>
    readonly profileType: FieldRef<"User", 'ProfileType'>
    readonly contextType: FieldRef<"User", 'ContextType'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.cycles
   */
  export type User$cyclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cycle
     */
    select?: CycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cycle
     */
    omit?: CycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CycleInclude<ExtArgs> | null
    where?: CycleWhereInput
    orderBy?: CycleOrderByWithRelationInput | CycleOrderByWithRelationInput[]
    cursor?: CycleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CycleScalarFieldEnum | CycleScalarFieldEnum[]
  }

  /**
   * User.programs
   */
  export type User$programsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    where?: ProgramWhereInput
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    cursor?: ProgramWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * User.moodTracks
   */
  export type User$moodTracksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoodTrack
     */
    select?: MoodTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoodTrack
     */
    omit?: MoodTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoodTrackInclude<ExtArgs> | null
    where?: MoodTrackWhereInput
    orderBy?: MoodTrackOrderByWithRelationInput | MoodTrackOrderByWithRelationInput[]
    cursor?: MoodTrackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MoodTrackScalarFieldEnum | MoodTrackScalarFieldEnum[]
  }

  /**
   * User.userSettings
   */
  export type User$userSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    where?: UserSettingsWhereInput
  }

  /**
   * User.reminderSettings
   */
  export type User$reminderSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReminderSettings
     */
    select?: ReminderSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReminderSettings
     */
    omit?: ReminderSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderSettingsInclude<ExtArgs> | null
    where?: ReminderSettingsWhereInput
    orderBy?: ReminderSettingsOrderByWithRelationInput | ReminderSettingsOrderByWithRelationInput[]
    cursor?: ReminderSettingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReminderSettingsScalarFieldEnum | ReminderSettingsScalarFieldEnum[]
  }

  /**
   * User.userFeatureFlags
   */
  export type User$userFeatureFlagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFeatureFlag
     */
    select?: UserFeatureFlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFeatureFlag
     */
    omit?: UserFeatureFlagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFeatureFlagInclude<ExtArgs> | null
    where?: UserFeatureFlagWhereInput
    orderBy?: UserFeatureFlagOrderByWithRelationInput | UserFeatureFlagOrderByWithRelationInput[]
    cursor?: UserFeatureFlagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserFeatureFlagScalarFieldEnum | UserFeatureFlagScalarFieldEnum[]
  }

  /**
   * User.userObjectives
   */
  export type User$userObjectivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserObjective
     */
    select?: UserObjectiveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserObjective
     */
    omit?: UserObjectiveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserObjectiveInclude<ExtArgs> | null
    where?: UserObjectiveWhereInput
    orderBy?: UserObjectiveOrderByWithRelationInput | UserObjectiveOrderByWithRelationInput[]
    cursor?: UserObjectiveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserObjectiveScalarFieldEnum | UserObjectiveScalarFieldEnum[]
  }

  /**
   * User.profileChangeLogs
   */
  export type User$profileChangeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileChangeLog
     */
    select?: ProfileChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileChangeLog
     */
    omit?: ProfileChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileChangeLogInclude<ExtArgs> | null
    where?: ProfileChangeLogWhereInput
    orderBy?: ProfileChangeLogOrderByWithRelationInput | ProfileChangeLogOrderByWithRelationInput[]
    cursor?: ProfileChangeLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileChangeLogScalarFieldEnum | ProfileChangeLogScalarFieldEnum[]
  }

  /**
   * User.cycleProfileConfig
   */
  export type User$cycleProfileConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CycleProfileConfig
     */
    select?: CycleProfileConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CycleProfileConfig
     */
    omit?: CycleProfileConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CycleProfileConfigInclude<ExtArgs> | null
    where?: CycleProfileConfigWhereInput
  }

  /**
   * User.symptomLogs
   */
  export type User$symptomLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SymptomLog
     */
    select?: SymptomLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SymptomLog
     */
    omit?: SymptomLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymptomLogInclude<ExtArgs> | null
    where?: SymptomLogWhereInput
    orderBy?: SymptomLogOrderByWithRelationInput | SymptomLogOrderByWithRelationInput[]
    cursor?: SymptomLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SymptomLogScalarFieldEnum | SymptomLogScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.externalSyncs
   */
  export type User$externalSyncsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalSync
     */
    select?: ExternalSyncSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalSync
     */
    omit?: ExternalSyncOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalSyncInclude<ExtArgs> | null
    where?: ExternalSyncWhereInput
    orderBy?: ExternalSyncOrderByWithRelationInput | ExternalSyncOrderByWithRelationInput[]
    cursor?: ExternalSyncWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExternalSyncScalarFieldEnum | ExternalSyncScalarFieldEnum[]
  }

  /**
   * User.journalEntries
   */
  export type User$journalEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalEntry
     */
    select?: JournalEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the JournalEntry
     */
    omit?: JournalEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalEntryInclude<ExtArgs> | null
    where?: JournalEntryWhereInput
    orderBy?: JournalEntryOrderByWithRelationInput | JournalEntryOrderByWithRelationInput[]
    cursor?: JournalEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JournalEntryScalarFieldEnum | JournalEntryScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.logs
   */
  export type User$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    where?: LogWhereInput
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    cursor?: LogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * User.refreshTokens
   */
  export type User$refreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * User.authSessions
   */
  export type User$authSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthSession
     */
    select?: AuthSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuthSession
     */
    omit?: AuthSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthSessionInclude<ExtArgs> | null
    where?: AuthSessionWhereInput
    orderBy?: AuthSessionOrderByWithRelationInput | AuthSessionOrderByWithRelationInput[]
    cursor?: AuthSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuthSessionScalarFieldEnum | AuthSessionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CycleScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    startDate: 'startDate',
    cycleLength: 'cycleLength',
    periodLength: 'periodLength',
    isRegular: 'isRegular',
    providerId: 'providerId',
    externalCycleId: 'externalCycleId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CycleScalarFieldEnum = (typeof CycleScalarFieldEnum)[keyof typeof CycleScalarFieldEnum]


  export const CycleProfileConfigScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    isCycleTrackingEnabled: 'isCycleTrackingEnabled',
    usesExternalProvider: 'usesExternalProvider',
    useMenopauseMode: 'useMenopauseMode',
    averageCycleLength: 'averageCycleLength',
    averagePeriodLength: 'averagePeriodLength',
    prefersManualInput: 'prefersManualInput',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CycleProfileConfigScalarFieldEnum = (typeof CycleProfileConfigScalarFieldEnum)[keyof typeof CycleProfileConfigScalarFieldEnum]


  export const CycleProviderScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CycleProviderScalarFieldEnum = (typeof CycleProviderScalarFieldEnum)[keyof typeof CycleProviderScalarFieldEnum]


  export const PhaseScalarFieldEnum: {
    id: 'id',
    cycleId: 'cycleId',
    name: 'name',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PhaseScalarFieldEnum = (typeof PhaseScalarFieldEnum)[keyof typeof PhaseScalarFieldEnum]


  export const ExerciseScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    imageUrl: 'imageUrl',
    durationMinutes: 'durationMinutes',
    intensity: 'intensity',
    muscleZone: 'muscleZone',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExerciseScalarFieldEnum = (typeof ExerciseScalarFieldEnum)[keyof typeof ExerciseScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const ExerciseTagScalarFieldEnum: {
    id: 'id',
    exerciseId: 'exerciseId',
    tagId: 'tagId',
    createdAt: 'createdAt'
  };

  export type ExerciseTagScalarFieldEnum = (typeof ExerciseTagScalarFieldEnum)[keyof typeof ExerciseTagScalarFieldEnum]


  export const PhaseExerciseScalarFieldEnum: {
    id: 'id',
    phaseName: 'phaseName',
    exerciseId: 'exerciseId',
    createdAt: 'createdAt'
  };

  export type PhaseExerciseScalarFieldEnum = (typeof PhaseExerciseScalarFieldEnum)[keyof typeof PhaseExerciseScalarFieldEnum]


  export const ProgramScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    goal: 'goal',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProgramScalarFieldEnum = (typeof ProgramScalarFieldEnum)[keyof typeof ProgramScalarFieldEnum]


  export const ProgramExerciseScalarFieldEnum: {
    id: 'id',
    programId: 'programId',
    exerciseId: 'exerciseId',
    day: 'day',
    order: 'order',
    createdAt: 'createdAt'
  };

  export type ProgramExerciseScalarFieldEnum = (typeof ProgramExerciseScalarFieldEnum)[keyof typeof ProgramExerciseScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    message: 'message',
    date: 'date',
    relatedPhase: 'relatedPhase',
    relatedProgramId: 'relatedProgramId',
    isRead: 'isRead',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const ExternalSyncScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    provider: 'provider',
    entitySynced: 'entitySynced',
    externalId: 'externalId',
    status: 'status',
    message: 'message',
    syncedAt: 'syncedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExternalSyncScalarFieldEnum = (typeof ExternalSyncScalarFieldEnum)[keyof typeof ExternalSyncScalarFieldEnum]


  export const JournalEntryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    date: 'date',
    category: 'category',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type JournalEntryScalarFieldEnum = (typeof JournalEntryScalarFieldEnum)[keyof typeof JournalEntryScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    entity: 'entity',
    entityId: 'entityId',
    oldData: 'oldData',
    newData: 'newData',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const LogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    eventType: 'eventType',
    description: 'description',
    timestamp: 'timestamp',
    metadata: 'metadata'
  };

  export type LogScalarFieldEnum = (typeof LogScalarFieldEnum)[keyof typeof LogScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tokenHash: 'tokenHash',
    expiresAt: 'expiresAt',
    revoked: 'revoked',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const AuthSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    userAgent: 'userAgent',
    ipAddress: 'ipAddress',
    lastSeen: 'lastSeen',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AuthSessionScalarFieldEnum = (typeof AuthSessionScalarFieldEnum)[keyof typeof AuthSessionScalarFieldEnum]


  export const MoodTrackScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    date: 'date',
    mood: 'mood',
    energy: 'energy',
    pain: 'pain',
    stress: 'stress',
    sleepQuality: 'sleepQuality',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MoodTrackScalarFieldEnum = (typeof MoodTrackScalarFieldEnum)[keyof typeof MoodTrackScalarFieldEnum]


  export const SymptomLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    date: 'date',
    symptomType: 'symptomType',
    value: 'value',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SymptomLogScalarFieldEnum = (typeof SymptomLogScalarFieldEnum)[keyof typeof SymptomLogScalarFieldEnum]


  export const UserSettingsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    unitPreference: 'unitPreference',
    notificationEnabled: 'notificationEnabled',
    notificationTime: 'notificationTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserSettingsScalarFieldEnum = (typeof UserSettingsScalarFieldEnum)[keyof typeof UserSettingsScalarFieldEnum]


  export const ReminderSettingsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    enabled: 'enabled',
    time: 'time',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReminderSettingsScalarFieldEnum = (typeof ReminderSettingsScalarFieldEnum)[keyof typeof ReminderSettingsScalarFieldEnum]


  export const UserFeatureFlagScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    feature: 'feature',
    isEnabled: 'isEnabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserFeatureFlagScalarFieldEnum = (typeof UserFeatureFlagScalarFieldEnum)[keyof typeof UserFeatureFlagScalarFieldEnum]


  export const UserObjectiveScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    note: 'note',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserObjectiveScalarFieldEnum = (typeof UserObjectiveScalarFieldEnum)[keyof typeof UserObjectiveScalarFieldEnum]


  export const ProfileChangeLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    changeType: 'changeType',
    details: 'details',
    changedAt: 'changedAt'
  };

  export type ProfileChangeLogScalarFieldEnum = (typeof ProfileChangeLogScalarFieldEnum)[keyof typeof ProfileChangeLogScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    firstName: 'firstName',
    birthDate: 'birthDate',
    isMenopausal: 'isMenopausal',
    objective: 'objective',
    sportFrequency: 'sportFrequency',
    profileType: 'profileType',
    contextType: 'contextType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'CyclePhase'
   */
  export type EnumCyclePhaseFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CyclePhase'>
    


  /**
   * Reference to a field of type 'CyclePhase[]'
   */
  export type ListEnumCyclePhaseFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CyclePhase[]'>
    


  /**
   * Reference to a field of type 'Intensity'
   */
  export type EnumIntensityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Intensity'>
    


  /**
   * Reference to a field of type 'Intensity[]'
   */
  export type ListEnumIntensityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Intensity[]'>
    


  /**
   * Reference to a field of type 'MuscleZone'
   */
  export type EnumMuscleZoneFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MuscleZone'>
    


  /**
   * Reference to a field of type 'MuscleZone[]'
   */
  export type ListEnumMuscleZoneFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MuscleZone[]'>
    


  /**
   * Reference to a field of type 'TagType'
   */
  export type EnumTagTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TagType'>
    


  /**
   * Reference to a field of type 'TagType[]'
   */
  export type ListEnumTagTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TagType[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'ExternalProvider'
   */
  export type EnumExternalProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExternalProvider'>
    


  /**
   * Reference to a field of type 'ExternalProvider[]'
   */
  export type ListEnumExternalProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExternalProvider[]'>
    


  /**
   * Reference to a field of type 'ExternalSyncStatus'
   */
  export type EnumExternalSyncStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExternalSyncStatus'>
    


  /**
   * Reference to a field of type 'ExternalSyncStatus[]'
   */
  export type ListEnumExternalSyncStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExternalSyncStatus[]'>
    


  /**
   * Reference to a field of type 'JournalCategory'
   */
  export type EnumJournalCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JournalCategory'>
    


  /**
   * Reference to a field of type 'JournalCategory[]'
   */
  export type ListEnumJournalCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JournalCategory[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'EventType'
   */
  export type EnumEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventType'>
    


  /**
   * Reference to a field of type 'EventType[]'
   */
  export type ListEnumEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventType[]'>
    


  /**
   * Reference to a field of type 'MoodType'
   */
  export type EnumMoodTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MoodType'>
    


  /**
   * Reference to a field of type 'MoodType[]'
   */
  export type ListEnumMoodTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MoodType[]'>
    


  /**
   * Reference to a field of type 'EnergyLevel'
   */
  export type EnumEnergyLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnergyLevel'>
    


  /**
   * Reference to a field of type 'EnergyLevel[]'
   */
  export type ListEnumEnergyLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EnergyLevel[]'>
    


  /**
   * Reference to a field of type 'PainLevel'
   */
  export type EnumPainLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PainLevel'>
    


  /**
   * Reference to a field of type 'PainLevel[]'
   */
  export type ListEnumPainLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PainLevel[]'>
    


  /**
   * Reference to a field of type 'StressLevel'
   */
  export type EnumStressLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StressLevel'>
    


  /**
   * Reference to a field of type 'StressLevel[]'
   */
  export type ListEnumStressLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StressLevel[]'>
    


  /**
   * Reference to a field of type 'SleepQuality'
   */
  export type EnumSleepQualityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SleepQuality'>
    


  /**
   * Reference to a field of type 'SleepQuality[]'
   */
  export type ListEnumSleepQualityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SleepQuality[]'>
    


  /**
   * Reference to a field of type 'SymptomType'
   */
  export type EnumSymptomTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SymptomType'>
    


  /**
   * Reference to a field of type 'SymptomType[]'
   */
  export type ListEnumSymptomTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SymptomType[]'>
    


  /**
   * Reference to a field of type 'UnitPreference'
   */
  export type EnumUnitPreferenceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UnitPreference'>
    


  /**
   * Reference to a field of type 'UnitPreference[]'
   */
  export type ListEnumUnitPreferenceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UnitPreference[]'>
    


  /**
   * Reference to a field of type 'ReminderType'
   */
  export type EnumReminderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReminderType'>
    


  /**
   * Reference to a field of type 'ReminderType[]'
   */
  export type ListEnumReminderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReminderType[]'>
    


  /**
   * Reference to a field of type 'ObjectiveType'
   */
  export type EnumObjectiveTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ObjectiveType'>
    


  /**
   * Reference to a field of type 'ObjectiveType[]'
   */
  export type ListEnumObjectiveTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ObjectiveType[]'>
    


  /**
   * Reference to a field of type 'ChangeType'
   */
  export type EnumChangeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChangeType'>
    


  /**
   * Reference to a field of type 'ChangeType[]'
   */
  export type ListEnumChangeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChangeType[]'>
    


  /**
   * Reference to a field of type 'SportFrequency'
   */
  export type EnumSportFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SportFrequency'>
    


  /**
   * Reference to a field of type 'SportFrequency[]'
   */
  export type ListEnumSportFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SportFrequency[]'>
    


  /**
   * Reference to a field of type 'ProfileType'
   */
  export type EnumProfileTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProfileType'>
    


  /**
   * Reference to a field of type 'ProfileType[]'
   */
  export type ListEnumProfileTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProfileType[]'>
    


  /**
   * Reference to a field of type 'ContextType'
   */
  export type EnumContextTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContextType'>
    


  /**
   * Reference to a field of type 'ContextType[]'
   */
  export type ListEnumContextTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContextType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type CycleWhereInput = {
    AND?: CycleWhereInput | CycleWhereInput[]
    OR?: CycleWhereInput[]
    NOT?: CycleWhereInput | CycleWhereInput[]
    id?: StringFilter<"Cycle"> | string
    userId?: StringFilter<"Cycle"> | string
    startDate?: DateTimeFilter<"Cycle"> | Date | string
    cycleLength?: IntNullableFilter<"Cycle"> | number | null
    periodLength?: IntNullableFilter<"Cycle"> | number | null
    isRegular?: BoolFilter<"Cycle"> | boolean
    providerId?: StringNullableFilter<"Cycle"> | string | null
    externalCycleId?: StringNullableFilter<"Cycle"> | string | null
    createdAt?: DateTimeFilter<"Cycle"> | Date | string
    updatedAt?: DateTimeFilter<"Cycle"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    provider?: XOR<CycleProviderNullableScalarRelationFilter, CycleProviderWhereInput> | null
    phases?: PhaseListRelationFilter
  }

  export type CycleOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    startDate?: SortOrder
    cycleLength?: SortOrderInput | SortOrder
    periodLength?: SortOrderInput | SortOrder
    isRegular?: SortOrder
    providerId?: SortOrderInput | SortOrder
    externalCycleId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    provider?: CycleProviderOrderByWithRelationInput
    phases?: PhaseOrderByRelationAggregateInput
  }

  export type CycleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CycleWhereInput | CycleWhereInput[]
    OR?: CycleWhereInput[]
    NOT?: CycleWhereInput | CycleWhereInput[]
    userId?: StringFilter<"Cycle"> | string
    startDate?: DateTimeFilter<"Cycle"> | Date | string
    cycleLength?: IntNullableFilter<"Cycle"> | number | null
    periodLength?: IntNullableFilter<"Cycle"> | number | null
    isRegular?: BoolFilter<"Cycle"> | boolean
    providerId?: StringNullableFilter<"Cycle"> | string | null
    externalCycleId?: StringNullableFilter<"Cycle"> | string | null
    createdAt?: DateTimeFilter<"Cycle"> | Date | string
    updatedAt?: DateTimeFilter<"Cycle"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    provider?: XOR<CycleProviderNullableScalarRelationFilter, CycleProviderWhereInput> | null
    phases?: PhaseListRelationFilter
  }, "id">

  export type CycleOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    startDate?: SortOrder
    cycleLength?: SortOrderInput | SortOrder
    periodLength?: SortOrderInput | SortOrder
    isRegular?: SortOrder
    providerId?: SortOrderInput | SortOrder
    externalCycleId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CycleCountOrderByAggregateInput
    _avg?: CycleAvgOrderByAggregateInput
    _max?: CycleMaxOrderByAggregateInput
    _min?: CycleMinOrderByAggregateInput
    _sum?: CycleSumOrderByAggregateInput
  }

  export type CycleScalarWhereWithAggregatesInput = {
    AND?: CycleScalarWhereWithAggregatesInput | CycleScalarWhereWithAggregatesInput[]
    OR?: CycleScalarWhereWithAggregatesInput[]
    NOT?: CycleScalarWhereWithAggregatesInput | CycleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Cycle"> | string
    userId?: StringWithAggregatesFilter<"Cycle"> | string
    startDate?: DateTimeWithAggregatesFilter<"Cycle"> | Date | string
    cycleLength?: IntNullableWithAggregatesFilter<"Cycle"> | number | null
    periodLength?: IntNullableWithAggregatesFilter<"Cycle"> | number | null
    isRegular?: BoolWithAggregatesFilter<"Cycle"> | boolean
    providerId?: StringNullableWithAggregatesFilter<"Cycle"> | string | null
    externalCycleId?: StringNullableWithAggregatesFilter<"Cycle"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Cycle"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Cycle"> | Date | string
  }

  export type CycleProfileConfigWhereInput = {
    AND?: CycleProfileConfigWhereInput | CycleProfileConfigWhereInput[]
    OR?: CycleProfileConfigWhereInput[]
    NOT?: CycleProfileConfigWhereInput | CycleProfileConfigWhereInput[]
    id?: StringFilter<"CycleProfileConfig"> | string
    userId?: StringFilter<"CycleProfileConfig"> | string
    isCycleTrackingEnabled?: BoolFilter<"CycleProfileConfig"> | boolean
    usesExternalProvider?: BoolFilter<"CycleProfileConfig"> | boolean
    useMenopauseMode?: BoolFilter<"CycleProfileConfig"> | boolean
    averageCycleLength?: IntNullableFilter<"CycleProfileConfig"> | number | null
    averagePeriodLength?: IntNullableFilter<"CycleProfileConfig"> | number | null
    prefersManualInput?: BoolFilter<"CycleProfileConfig"> | boolean
    createdAt?: DateTimeFilter<"CycleProfileConfig"> | Date | string
    updatedAt?: DateTimeFilter<"CycleProfileConfig"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CycleProfileConfigOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    isCycleTrackingEnabled?: SortOrder
    usesExternalProvider?: SortOrder
    useMenopauseMode?: SortOrder
    averageCycleLength?: SortOrderInput | SortOrder
    averagePeriodLength?: SortOrderInput | SortOrder
    prefersManualInput?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type CycleProfileConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: CycleProfileConfigWhereInput | CycleProfileConfigWhereInput[]
    OR?: CycleProfileConfigWhereInput[]
    NOT?: CycleProfileConfigWhereInput | CycleProfileConfigWhereInput[]
    isCycleTrackingEnabled?: BoolFilter<"CycleProfileConfig"> | boolean
    usesExternalProvider?: BoolFilter<"CycleProfileConfig"> | boolean
    useMenopauseMode?: BoolFilter<"CycleProfileConfig"> | boolean
    averageCycleLength?: IntNullableFilter<"CycleProfileConfig"> | number | null
    averagePeriodLength?: IntNullableFilter<"CycleProfileConfig"> | number | null
    prefersManualInput?: BoolFilter<"CycleProfileConfig"> | boolean
    createdAt?: DateTimeFilter<"CycleProfileConfig"> | Date | string
    updatedAt?: DateTimeFilter<"CycleProfileConfig"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type CycleProfileConfigOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    isCycleTrackingEnabled?: SortOrder
    usesExternalProvider?: SortOrder
    useMenopauseMode?: SortOrder
    averageCycleLength?: SortOrderInput | SortOrder
    averagePeriodLength?: SortOrderInput | SortOrder
    prefersManualInput?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CycleProfileConfigCountOrderByAggregateInput
    _avg?: CycleProfileConfigAvgOrderByAggregateInput
    _max?: CycleProfileConfigMaxOrderByAggregateInput
    _min?: CycleProfileConfigMinOrderByAggregateInput
    _sum?: CycleProfileConfigSumOrderByAggregateInput
  }

  export type CycleProfileConfigScalarWhereWithAggregatesInput = {
    AND?: CycleProfileConfigScalarWhereWithAggregatesInput | CycleProfileConfigScalarWhereWithAggregatesInput[]
    OR?: CycleProfileConfigScalarWhereWithAggregatesInput[]
    NOT?: CycleProfileConfigScalarWhereWithAggregatesInput | CycleProfileConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CycleProfileConfig"> | string
    userId?: StringWithAggregatesFilter<"CycleProfileConfig"> | string
    isCycleTrackingEnabled?: BoolWithAggregatesFilter<"CycleProfileConfig"> | boolean
    usesExternalProvider?: BoolWithAggregatesFilter<"CycleProfileConfig"> | boolean
    useMenopauseMode?: BoolWithAggregatesFilter<"CycleProfileConfig"> | boolean
    averageCycleLength?: IntNullableWithAggregatesFilter<"CycleProfileConfig"> | number | null
    averagePeriodLength?: IntNullableWithAggregatesFilter<"CycleProfileConfig"> | number | null
    prefersManualInput?: BoolWithAggregatesFilter<"CycleProfileConfig"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CycleProfileConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CycleProfileConfig"> | Date | string
  }

  export type CycleProviderWhereInput = {
    AND?: CycleProviderWhereInput | CycleProviderWhereInput[]
    OR?: CycleProviderWhereInput[]
    NOT?: CycleProviderWhereInput | CycleProviderWhereInput[]
    id?: StringFilter<"CycleProvider"> | string
    name?: StringFilter<"CycleProvider"> | string
    description?: StringNullableFilter<"CycleProvider"> | string | null
    createdAt?: DateTimeFilter<"CycleProvider"> | Date | string
    updatedAt?: DateTimeFilter<"CycleProvider"> | Date | string
    cycles?: CycleListRelationFilter
  }

  export type CycleProviderOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cycles?: CycleOrderByRelationAggregateInput
  }

  export type CycleProviderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: CycleProviderWhereInput | CycleProviderWhereInput[]
    OR?: CycleProviderWhereInput[]
    NOT?: CycleProviderWhereInput | CycleProviderWhereInput[]
    description?: StringNullableFilter<"CycleProvider"> | string | null
    createdAt?: DateTimeFilter<"CycleProvider"> | Date | string
    updatedAt?: DateTimeFilter<"CycleProvider"> | Date | string
    cycles?: CycleListRelationFilter
  }, "id" | "name">

  export type CycleProviderOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CycleProviderCountOrderByAggregateInput
    _max?: CycleProviderMaxOrderByAggregateInput
    _min?: CycleProviderMinOrderByAggregateInput
  }

  export type CycleProviderScalarWhereWithAggregatesInput = {
    AND?: CycleProviderScalarWhereWithAggregatesInput | CycleProviderScalarWhereWithAggregatesInput[]
    OR?: CycleProviderScalarWhereWithAggregatesInput[]
    NOT?: CycleProviderScalarWhereWithAggregatesInput | CycleProviderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CycleProvider"> | string
    name?: StringWithAggregatesFilter<"CycleProvider"> | string
    description?: StringNullableWithAggregatesFilter<"CycleProvider"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CycleProvider"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CycleProvider"> | Date | string
  }

  export type PhaseWhereInput = {
    AND?: PhaseWhereInput | PhaseWhereInput[]
    OR?: PhaseWhereInput[]
    NOT?: PhaseWhereInput | PhaseWhereInput[]
    id?: StringFilter<"Phase"> | string
    cycleId?: StringFilter<"Phase"> | string
    name?: EnumCyclePhaseFilter<"Phase"> | $Enums.CyclePhase
    startDate?: DateTimeFilter<"Phase"> | Date | string
    endDate?: DateTimeFilter<"Phase"> | Date | string
    createdAt?: DateTimeFilter<"Phase"> | Date | string
    updatedAt?: DateTimeFilter<"Phase"> | Date | string
    cycle?: XOR<CycleScalarRelationFilter, CycleWhereInput>
  }

  export type PhaseOrderByWithRelationInput = {
    id?: SortOrder
    cycleId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cycle?: CycleOrderByWithRelationInput
  }

  export type PhaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PhaseWhereInput | PhaseWhereInput[]
    OR?: PhaseWhereInput[]
    NOT?: PhaseWhereInput | PhaseWhereInput[]
    cycleId?: StringFilter<"Phase"> | string
    name?: EnumCyclePhaseFilter<"Phase"> | $Enums.CyclePhase
    startDate?: DateTimeFilter<"Phase"> | Date | string
    endDate?: DateTimeFilter<"Phase"> | Date | string
    createdAt?: DateTimeFilter<"Phase"> | Date | string
    updatedAt?: DateTimeFilter<"Phase"> | Date | string
    cycle?: XOR<CycleScalarRelationFilter, CycleWhereInput>
  }, "id">

  export type PhaseOrderByWithAggregationInput = {
    id?: SortOrder
    cycleId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PhaseCountOrderByAggregateInput
    _max?: PhaseMaxOrderByAggregateInput
    _min?: PhaseMinOrderByAggregateInput
  }

  export type PhaseScalarWhereWithAggregatesInput = {
    AND?: PhaseScalarWhereWithAggregatesInput | PhaseScalarWhereWithAggregatesInput[]
    OR?: PhaseScalarWhereWithAggregatesInput[]
    NOT?: PhaseScalarWhereWithAggregatesInput | PhaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Phase"> | string
    cycleId?: StringWithAggregatesFilter<"Phase"> | string
    name?: EnumCyclePhaseWithAggregatesFilter<"Phase"> | $Enums.CyclePhase
    startDate?: DateTimeWithAggregatesFilter<"Phase"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Phase"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Phase"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Phase"> | Date | string
  }

  export type ExerciseWhereInput = {
    AND?: ExerciseWhereInput | ExerciseWhereInput[]
    OR?: ExerciseWhereInput[]
    NOT?: ExerciseWhereInput | ExerciseWhereInput[]
    id?: StringFilter<"Exercise"> | string
    title?: StringFilter<"Exercise"> | string
    description?: StringNullableFilter<"Exercise"> | string | null
    imageUrl?: StringNullableFilter<"Exercise"> | string | null
    durationMinutes?: IntNullableFilter<"Exercise"> | number | null
    intensity?: EnumIntensityNullableFilter<"Exercise"> | $Enums.Intensity | null
    muscleZone?: EnumMuscleZoneNullableFilter<"Exercise"> | $Enums.MuscleZone | null
    createdAt?: DateTimeFilter<"Exercise"> | Date | string
    updatedAt?: DateTimeFilter<"Exercise"> | Date | string
    exerciseTags?: ExerciseTagListRelationFilter
    phaseExercises?: PhaseExerciseListRelationFilter
    programExercises?: ProgramExerciseListRelationFilter
  }

  export type ExerciseOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    durationMinutes?: SortOrderInput | SortOrder
    intensity?: SortOrderInput | SortOrder
    muscleZone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    exerciseTags?: ExerciseTagOrderByRelationAggregateInput
    phaseExercises?: PhaseExerciseOrderByRelationAggregateInput
    programExercises?: ProgramExerciseOrderByRelationAggregateInput
  }

  export type ExerciseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExerciseWhereInput | ExerciseWhereInput[]
    OR?: ExerciseWhereInput[]
    NOT?: ExerciseWhereInput | ExerciseWhereInput[]
    title?: StringFilter<"Exercise"> | string
    description?: StringNullableFilter<"Exercise"> | string | null
    imageUrl?: StringNullableFilter<"Exercise"> | string | null
    durationMinutes?: IntNullableFilter<"Exercise"> | number | null
    intensity?: EnumIntensityNullableFilter<"Exercise"> | $Enums.Intensity | null
    muscleZone?: EnumMuscleZoneNullableFilter<"Exercise"> | $Enums.MuscleZone | null
    createdAt?: DateTimeFilter<"Exercise"> | Date | string
    updatedAt?: DateTimeFilter<"Exercise"> | Date | string
    exerciseTags?: ExerciseTagListRelationFilter
    phaseExercises?: PhaseExerciseListRelationFilter
    programExercises?: ProgramExerciseListRelationFilter
  }, "id">

  export type ExerciseOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    durationMinutes?: SortOrderInput | SortOrder
    intensity?: SortOrderInput | SortOrder
    muscleZone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExerciseCountOrderByAggregateInput
    _avg?: ExerciseAvgOrderByAggregateInput
    _max?: ExerciseMaxOrderByAggregateInput
    _min?: ExerciseMinOrderByAggregateInput
    _sum?: ExerciseSumOrderByAggregateInput
  }

  export type ExerciseScalarWhereWithAggregatesInput = {
    AND?: ExerciseScalarWhereWithAggregatesInput | ExerciseScalarWhereWithAggregatesInput[]
    OR?: ExerciseScalarWhereWithAggregatesInput[]
    NOT?: ExerciseScalarWhereWithAggregatesInput | ExerciseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Exercise"> | string
    title?: StringWithAggregatesFilter<"Exercise"> | string
    description?: StringNullableWithAggregatesFilter<"Exercise"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Exercise"> | string | null
    durationMinutes?: IntNullableWithAggregatesFilter<"Exercise"> | number | null
    intensity?: EnumIntensityNullableWithAggregatesFilter<"Exercise"> | $Enums.Intensity | null
    muscleZone?: EnumMuscleZoneNullableWithAggregatesFilter<"Exercise"> | $Enums.MuscleZone | null
    createdAt?: DateTimeWithAggregatesFilter<"Exercise"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Exercise"> | Date | string
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    type?: EnumTagTypeFilter<"Tag"> | $Enums.TagType
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    exerciseTags?: ExerciseTagListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    exerciseTags?: ExerciseTagOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    type?: EnumTagTypeFilter<"Tag"> | $Enums.TagType
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    exerciseTags?: ExerciseTagListRelationFilter
  }, "id" | "name">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tag"> | string
    name?: StringWithAggregatesFilter<"Tag"> | string
    type?: EnumTagTypeWithAggregatesFilter<"Tag"> | $Enums.TagType
    createdAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
  }

  export type ExerciseTagWhereInput = {
    AND?: ExerciseTagWhereInput | ExerciseTagWhereInput[]
    OR?: ExerciseTagWhereInput[]
    NOT?: ExerciseTagWhereInput | ExerciseTagWhereInput[]
    id?: StringFilter<"ExerciseTag"> | string
    exerciseId?: StringFilter<"ExerciseTag"> | string
    tagId?: StringFilter<"ExerciseTag"> | string
    createdAt?: DateTimeFilter<"ExerciseTag"> | Date | string
    exercise?: XOR<ExerciseScalarRelationFilter, ExerciseWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type ExerciseTagOrderByWithRelationInput = {
    id?: SortOrder
    exerciseId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
    exercise?: ExerciseOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type ExerciseTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    exerciseId_tagId?: ExerciseTagExerciseIdTagIdCompoundUniqueInput
    AND?: ExerciseTagWhereInput | ExerciseTagWhereInput[]
    OR?: ExerciseTagWhereInput[]
    NOT?: ExerciseTagWhereInput | ExerciseTagWhereInput[]
    exerciseId?: StringFilter<"ExerciseTag"> | string
    tagId?: StringFilter<"ExerciseTag"> | string
    createdAt?: DateTimeFilter<"ExerciseTag"> | Date | string
    exercise?: XOR<ExerciseScalarRelationFilter, ExerciseWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "id" | "exerciseId_tagId">

  export type ExerciseTagOrderByWithAggregationInput = {
    id?: SortOrder
    exerciseId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
    _count?: ExerciseTagCountOrderByAggregateInput
    _max?: ExerciseTagMaxOrderByAggregateInput
    _min?: ExerciseTagMinOrderByAggregateInput
  }

  export type ExerciseTagScalarWhereWithAggregatesInput = {
    AND?: ExerciseTagScalarWhereWithAggregatesInput | ExerciseTagScalarWhereWithAggregatesInput[]
    OR?: ExerciseTagScalarWhereWithAggregatesInput[]
    NOT?: ExerciseTagScalarWhereWithAggregatesInput | ExerciseTagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExerciseTag"> | string
    exerciseId?: StringWithAggregatesFilter<"ExerciseTag"> | string
    tagId?: StringWithAggregatesFilter<"ExerciseTag"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ExerciseTag"> | Date | string
  }

  export type PhaseExerciseWhereInput = {
    AND?: PhaseExerciseWhereInput | PhaseExerciseWhereInput[]
    OR?: PhaseExerciseWhereInput[]
    NOT?: PhaseExerciseWhereInput | PhaseExerciseWhereInput[]
    id?: StringFilter<"PhaseExercise"> | string
    phaseName?: EnumCyclePhaseFilter<"PhaseExercise"> | $Enums.CyclePhase
    exerciseId?: StringFilter<"PhaseExercise"> | string
    createdAt?: DateTimeFilter<"PhaseExercise"> | Date | string
    exercise?: XOR<ExerciseScalarRelationFilter, ExerciseWhereInput>
  }

  export type PhaseExerciseOrderByWithRelationInput = {
    id?: SortOrder
    phaseName?: SortOrder
    exerciseId?: SortOrder
    createdAt?: SortOrder
    exercise?: ExerciseOrderByWithRelationInput
  }

  export type PhaseExerciseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PhaseExerciseWhereInput | PhaseExerciseWhereInput[]
    OR?: PhaseExerciseWhereInput[]
    NOT?: PhaseExerciseWhereInput | PhaseExerciseWhereInput[]
    phaseName?: EnumCyclePhaseFilter<"PhaseExercise"> | $Enums.CyclePhase
    exerciseId?: StringFilter<"PhaseExercise"> | string
    createdAt?: DateTimeFilter<"PhaseExercise"> | Date | string
    exercise?: XOR<ExerciseScalarRelationFilter, ExerciseWhereInput>
  }, "id">

  export type PhaseExerciseOrderByWithAggregationInput = {
    id?: SortOrder
    phaseName?: SortOrder
    exerciseId?: SortOrder
    createdAt?: SortOrder
    _count?: PhaseExerciseCountOrderByAggregateInput
    _max?: PhaseExerciseMaxOrderByAggregateInput
    _min?: PhaseExerciseMinOrderByAggregateInput
  }

  export type PhaseExerciseScalarWhereWithAggregatesInput = {
    AND?: PhaseExerciseScalarWhereWithAggregatesInput | PhaseExerciseScalarWhereWithAggregatesInput[]
    OR?: PhaseExerciseScalarWhereWithAggregatesInput[]
    NOT?: PhaseExerciseScalarWhereWithAggregatesInput | PhaseExerciseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PhaseExercise"> | string
    phaseName?: EnumCyclePhaseWithAggregatesFilter<"PhaseExercise"> | $Enums.CyclePhase
    exerciseId?: StringWithAggregatesFilter<"PhaseExercise"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PhaseExercise"> | Date | string
  }

  export type ProgramWhereInput = {
    AND?: ProgramWhereInput | ProgramWhereInput[]
    OR?: ProgramWhereInput[]
    NOT?: ProgramWhereInput | ProgramWhereInput[]
    id?: StringFilter<"Program"> | string
    userId?: StringFilter<"Program"> | string
    title?: StringFilter<"Program"> | string
    goal?: StringNullableFilter<"Program"> | string | null
    startDate?: DateTimeFilter<"Program"> | Date | string
    endDate?: DateTimeNullableFilter<"Program"> | Date | string | null
    createdAt?: DateTimeFilter<"Program"> | Date | string
    updatedAt?: DateTimeFilter<"Program"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    programExercises?: ProgramExerciseListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type ProgramOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    goal?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    programExercises?: ProgramExerciseOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type ProgramWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProgramWhereInput | ProgramWhereInput[]
    OR?: ProgramWhereInput[]
    NOT?: ProgramWhereInput | ProgramWhereInput[]
    userId?: StringFilter<"Program"> | string
    title?: StringFilter<"Program"> | string
    goal?: StringNullableFilter<"Program"> | string | null
    startDate?: DateTimeFilter<"Program"> | Date | string
    endDate?: DateTimeNullableFilter<"Program"> | Date | string | null
    createdAt?: DateTimeFilter<"Program"> | Date | string
    updatedAt?: DateTimeFilter<"Program"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    programExercises?: ProgramExerciseListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id">

  export type ProgramOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    goal?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProgramCountOrderByAggregateInput
    _max?: ProgramMaxOrderByAggregateInput
    _min?: ProgramMinOrderByAggregateInput
  }

  export type ProgramScalarWhereWithAggregatesInput = {
    AND?: ProgramScalarWhereWithAggregatesInput | ProgramScalarWhereWithAggregatesInput[]
    OR?: ProgramScalarWhereWithAggregatesInput[]
    NOT?: ProgramScalarWhereWithAggregatesInput | ProgramScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Program"> | string
    userId?: StringWithAggregatesFilter<"Program"> | string
    title?: StringWithAggregatesFilter<"Program"> | string
    goal?: StringNullableWithAggregatesFilter<"Program"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"Program"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Program"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Program"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Program"> | Date | string
  }

  export type ProgramExerciseWhereInput = {
    AND?: ProgramExerciseWhereInput | ProgramExerciseWhereInput[]
    OR?: ProgramExerciseWhereInput[]
    NOT?: ProgramExerciseWhereInput | ProgramExerciseWhereInput[]
    id?: StringFilter<"ProgramExercise"> | string
    programId?: StringFilter<"ProgramExercise"> | string
    exerciseId?: StringFilter<"ProgramExercise"> | string
    day?: IntFilter<"ProgramExercise"> | number
    order?: IntFilter<"ProgramExercise"> | number
    createdAt?: DateTimeFilter<"ProgramExercise"> | Date | string
    program?: XOR<ProgramScalarRelationFilter, ProgramWhereInput>
    exercise?: XOR<ExerciseScalarRelationFilter, ExerciseWhereInput>
  }

  export type ProgramExerciseOrderByWithRelationInput = {
    id?: SortOrder
    programId?: SortOrder
    exerciseId?: SortOrder
    day?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    program?: ProgramOrderByWithRelationInput
    exercise?: ExerciseOrderByWithRelationInput
  }

  export type ProgramExerciseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProgramExerciseWhereInput | ProgramExerciseWhereInput[]
    OR?: ProgramExerciseWhereInput[]
    NOT?: ProgramExerciseWhereInput | ProgramExerciseWhereInput[]
    programId?: StringFilter<"ProgramExercise"> | string
    exerciseId?: StringFilter<"ProgramExercise"> | string
    day?: IntFilter<"ProgramExercise"> | number
    order?: IntFilter<"ProgramExercise"> | number
    createdAt?: DateTimeFilter<"ProgramExercise"> | Date | string
    program?: XOR<ProgramScalarRelationFilter, ProgramWhereInput>
    exercise?: XOR<ExerciseScalarRelationFilter, ExerciseWhereInput>
  }, "id">

  export type ProgramExerciseOrderByWithAggregationInput = {
    id?: SortOrder
    programId?: SortOrder
    exerciseId?: SortOrder
    day?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    _count?: ProgramExerciseCountOrderByAggregateInput
    _avg?: ProgramExerciseAvgOrderByAggregateInput
    _max?: ProgramExerciseMaxOrderByAggregateInput
    _min?: ProgramExerciseMinOrderByAggregateInput
    _sum?: ProgramExerciseSumOrderByAggregateInput
  }

  export type ProgramExerciseScalarWhereWithAggregatesInput = {
    AND?: ProgramExerciseScalarWhereWithAggregatesInput | ProgramExerciseScalarWhereWithAggregatesInput[]
    OR?: ProgramExerciseScalarWhereWithAggregatesInput[]
    NOT?: ProgramExerciseScalarWhereWithAggregatesInput | ProgramExerciseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProgramExercise"> | string
    programId?: StringWithAggregatesFilter<"ProgramExercise"> | string
    exerciseId?: StringWithAggregatesFilter<"ProgramExercise"> | string
    day?: IntWithAggregatesFilter<"ProgramExercise"> | number
    order?: IntWithAggregatesFilter<"ProgramExercise"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ProgramExercise"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    message?: StringFilter<"Notification"> | string
    date?: DateTimeFilter<"Notification"> | Date | string
    relatedPhase?: StringNullableFilter<"Notification"> | string | null
    relatedProgramId?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    relatedProgram?: XOR<ProgramNullableScalarRelationFilter, ProgramWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    date?: SortOrder
    relatedPhase?: SortOrderInput | SortOrder
    relatedProgramId?: SortOrderInput | SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    relatedProgram?: ProgramOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    message?: StringFilter<"Notification"> | string
    date?: DateTimeFilter<"Notification"> | Date | string
    relatedPhase?: StringNullableFilter<"Notification"> | string | null
    relatedProgramId?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    relatedProgram?: XOR<ProgramNullableScalarRelationFilter, ProgramWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    date?: SortOrder
    relatedPhase?: SortOrderInput | SortOrder
    relatedProgramId?: SortOrderInput | SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    message?: StringWithAggregatesFilter<"Notification"> | string
    date?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    relatedPhase?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    relatedProgramId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type ExternalSyncWhereInput = {
    AND?: ExternalSyncWhereInput | ExternalSyncWhereInput[]
    OR?: ExternalSyncWhereInput[]
    NOT?: ExternalSyncWhereInput | ExternalSyncWhereInput[]
    id?: StringFilter<"ExternalSync"> | string
    userId?: StringFilter<"ExternalSync"> | string
    provider?: EnumExternalProviderFilter<"ExternalSync"> | $Enums.ExternalProvider
    entitySynced?: StringFilter<"ExternalSync"> | string
    externalId?: StringFilter<"ExternalSync"> | string
    status?: EnumExternalSyncStatusFilter<"ExternalSync"> | $Enums.ExternalSyncStatus
    message?: StringNullableFilter<"ExternalSync"> | string | null
    syncedAt?: DateTimeFilter<"ExternalSync"> | Date | string
    createdAt?: DateTimeFilter<"ExternalSync"> | Date | string
    updatedAt?: DateTimeFilter<"ExternalSync"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ExternalSyncOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    entitySynced?: SortOrder
    externalId?: SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    syncedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ExternalSyncWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExternalSyncWhereInput | ExternalSyncWhereInput[]
    OR?: ExternalSyncWhereInput[]
    NOT?: ExternalSyncWhereInput | ExternalSyncWhereInput[]
    userId?: StringFilter<"ExternalSync"> | string
    provider?: EnumExternalProviderFilter<"ExternalSync"> | $Enums.ExternalProvider
    entitySynced?: StringFilter<"ExternalSync"> | string
    externalId?: StringFilter<"ExternalSync"> | string
    status?: EnumExternalSyncStatusFilter<"ExternalSync"> | $Enums.ExternalSyncStatus
    message?: StringNullableFilter<"ExternalSync"> | string | null
    syncedAt?: DateTimeFilter<"ExternalSync"> | Date | string
    createdAt?: DateTimeFilter<"ExternalSync"> | Date | string
    updatedAt?: DateTimeFilter<"ExternalSync"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ExternalSyncOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    entitySynced?: SortOrder
    externalId?: SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    syncedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExternalSyncCountOrderByAggregateInput
    _max?: ExternalSyncMaxOrderByAggregateInput
    _min?: ExternalSyncMinOrderByAggregateInput
  }

  export type ExternalSyncScalarWhereWithAggregatesInput = {
    AND?: ExternalSyncScalarWhereWithAggregatesInput | ExternalSyncScalarWhereWithAggregatesInput[]
    OR?: ExternalSyncScalarWhereWithAggregatesInput[]
    NOT?: ExternalSyncScalarWhereWithAggregatesInput | ExternalSyncScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExternalSync"> | string
    userId?: StringWithAggregatesFilter<"ExternalSync"> | string
    provider?: EnumExternalProviderWithAggregatesFilter<"ExternalSync"> | $Enums.ExternalProvider
    entitySynced?: StringWithAggregatesFilter<"ExternalSync"> | string
    externalId?: StringWithAggregatesFilter<"ExternalSync"> | string
    status?: EnumExternalSyncStatusWithAggregatesFilter<"ExternalSync"> | $Enums.ExternalSyncStatus
    message?: StringNullableWithAggregatesFilter<"ExternalSync"> | string | null
    syncedAt?: DateTimeWithAggregatesFilter<"ExternalSync"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"ExternalSync"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExternalSync"> | Date | string
  }

  export type JournalEntryWhereInput = {
    AND?: JournalEntryWhereInput | JournalEntryWhereInput[]
    OR?: JournalEntryWhereInput[]
    NOT?: JournalEntryWhereInput | JournalEntryWhereInput[]
    id?: StringFilter<"JournalEntry"> | string
    userId?: StringFilter<"JournalEntry"> | string
    date?: DateTimeFilter<"JournalEntry"> | Date | string
    category?: EnumJournalCategoryFilter<"JournalEntry"> | $Enums.JournalCategory
    content?: StringFilter<"JournalEntry"> | string
    createdAt?: DateTimeFilter<"JournalEntry"> | Date | string
    updatedAt?: DateTimeFilter<"JournalEntry"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type JournalEntryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    category?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type JournalEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JournalEntryWhereInput | JournalEntryWhereInput[]
    OR?: JournalEntryWhereInput[]
    NOT?: JournalEntryWhereInput | JournalEntryWhereInput[]
    userId?: StringFilter<"JournalEntry"> | string
    date?: DateTimeFilter<"JournalEntry"> | Date | string
    category?: EnumJournalCategoryFilter<"JournalEntry"> | $Enums.JournalCategory
    content?: StringFilter<"JournalEntry"> | string
    createdAt?: DateTimeFilter<"JournalEntry"> | Date | string
    updatedAt?: DateTimeFilter<"JournalEntry"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type JournalEntryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    category?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: JournalEntryCountOrderByAggregateInput
    _max?: JournalEntryMaxOrderByAggregateInput
    _min?: JournalEntryMinOrderByAggregateInput
  }

  export type JournalEntryScalarWhereWithAggregatesInput = {
    AND?: JournalEntryScalarWhereWithAggregatesInput | JournalEntryScalarWhereWithAggregatesInput[]
    OR?: JournalEntryScalarWhereWithAggregatesInput[]
    NOT?: JournalEntryScalarWhereWithAggregatesInput | JournalEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JournalEntry"> | string
    userId?: StringWithAggregatesFilter<"JournalEntry"> | string
    date?: DateTimeWithAggregatesFilter<"JournalEntry"> | Date | string
    category?: EnumJournalCategoryWithAggregatesFilter<"JournalEntry"> | $Enums.JournalCategory
    content?: StringWithAggregatesFilter<"JournalEntry"> | string
    createdAt?: DateTimeWithAggregatesFilter<"JournalEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"JournalEntry"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    oldData?: JsonNullableFilter<"AuditLog">
    newData?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrderInput | SortOrder
    oldData?: SortOrderInput | SortOrder
    newData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    oldData?: JsonNullableFilter<"AuditLog">
    newData?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrderInput | SortOrder
    oldData?: SortOrderInput | SortOrder
    newData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entity?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    oldData?: JsonNullableWithAggregatesFilter<"AuditLog">
    newData?: JsonNullableWithAggregatesFilter<"AuditLog">
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type LogWhereInput = {
    AND?: LogWhereInput | LogWhereInput[]
    OR?: LogWhereInput[]
    NOT?: LogWhereInput | LogWhereInput[]
    id?: StringFilter<"Log"> | string
    userId?: StringNullableFilter<"Log"> | string | null
    eventType?: EnumEventTypeFilter<"Log"> | $Enums.EventType
    description?: StringNullableFilter<"Log"> | string | null
    timestamp?: DateTimeFilter<"Log"> | Date | string
    metadata?: JsonNullableFilter<"Log">
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type LogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    description?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    metadata?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type LogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LogWhereInput | LogWhereInput[]
    OR?: LogWhereInput[]
    NOT?: LogWhereInput | LogWhereInput[]
    userId?: StringNullableFilter<"Log"> | string | null
    eventType?: EnumEventTypeFilter<"Log"> | $Enums.EventType
    description?: StringNullableFilter<"Log"> | string | null
    timestamp?: DateTimeFilter<"Log"> | Date | string
    metadata?: JsonNullableFilter<"Log">
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type LogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    description?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: LogCountOrderByAggregateInput
    _max?: LogMaxOrderByAggregateInput
    _min?: LogMinOrderByAggregateInput
  }

  export type LogScalarWhereWithAggregatesInput = {
    AND?: LogScalarWhereWithAggregatesInput | LogScalarWhereWithAggregatesInput[]
    OR?: LogScalarWhereWithAggregatesInput[]
    NOT?: LogScalarWhereWithAggregatesInput | LogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Log"> | string
    userId?: StringNullableWithAggregatesFilter<"Log"> | string | null
    eventType?: EnumEventTypeWithAggregatesFilter<"Log"> | $Enums.EventType
    description?: StringNullableWithAggregatesFilter<"Log"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"Log"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"Log">
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    tokenHash?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revoked?: BoolFilter<"RefreshToken"> | boolean
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tokenHash?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revoked?: BoolFilter<"RefreshToken"> | boolean
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "tokenHash">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RefreshToken"> | string
    userId?: StringWithAggregatesFilter<"RefreshToken"> | string
    tokenHash?: StringWithAggregatesFilter<"RefreshToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    revoked?: BoolWithAggregatesFilter<"RefreshToken"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
  }

  export type AuthSessionWhereInput = {
    AND?: AuthSessionWhereInput | AuthSessionWhereInput[]
    OR?: AuthSessionWhereInput[]
    NOT?: AuthSessionWhereInput | AuthSessionWhereInput[]
    id?: StringFilter<"AuthSession"> | string
    userId?: StringFilter<"AuthSession"> | string
    userAgent?: StringNullableFilter<"AuthSession"> | string | null
    ipAddress?: StringNullableFilter<"AuthSession"> | string | null
    lastSeen?: DateTimeFilter<"AuthSession"> | Date | string
    isActive?: BoolFilter<"AuthSession"> | boolean
    createdAt?: DateTimeFilter<"AuthSession"> | Date | string
    updatedAt?: DateTimeFilter<"AuthSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuthSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    lastSeen?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuthSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuthSessionWhereInput | AuthSessionWhereInput[]
    OR?: AuthSessionWhereInput[]
    NOT?: AuthSessionWhereInput | AuthSessionWhereInput[]
    userId?: StringFilter<"AuthSession"> | string
    userAgent?: StringNullableFilter<"AuthSession"> | string | null
    ipAddress?: StringNullableFilter<"AuthSession"> | string | null
    lastSeen?: DateTimeFilter<"AuthSession"> | Date | string
    isActive?: BoolFilter<"AuthSession"> | boolean
    createdAt?: DateTimeFilter<"AuthSession"> | Date | string
    updatedAt?: DateTimeFilter<"AuthSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AuthSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    lastSeen?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AuthSessionCountOrderByAggregateInput
    _max?: AuthSessionMaxOrderByAggregateInput
    _min?: AuthSessionMinOrderByAggregateInput
  }

  export type AuthSessionScalarWhereWithAggregatesInput = {
    AND?: AuthSessionScalarWhereWithAggregatesInput | AuthSessionScalarWhereWithAggregatesInput[]
    OR?: AuthSessionScalarWhereWithAggregatesInput[]
    NOT?: AuthSessionScalarWhereWithAggregatesInput | AuthSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuthSession"> | string
    userId?: StringWithAggregatesFilter<"AuthSession"> | string
    userAgent?: StringNullableWithAggregatesFilter<"AuthSession"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"AuthSession"> | string | null
    lastSeen?: DateTimeWithAggregatesFilter<"AuthSession"> | Date | string
    isActive?: BoolWithAggregatesFilter<"AuthSession"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AuthSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AuthSession"> | Date | string
  }

  export type MoodTrackWhereInput = {
    AND?: MoodTrackWhereInput | MoodTrackWhereInput[]
    OR?: MoodTrackWhereInput[]
    NOT?: MoodTrackWhereInput | MoodTrackWhereInput[]
    id?: StringFilter<"MoodTrack"> | string
    userId?: StringFilter<"MoodTrack"> | string
    date?: DateTimeFilter<"MoodTrack"> | Date | string
    mood?: EnumMoodTypeNullableFilter<"MoodTrack"> | $Enums.MoodType | null
    energy?: EnumEnergyLevelNullableFilter<"MoodTrack"> | $Enums.EnergyLevel | null
    pain?: EnumPainLevelNullableFilter<"MoodTrack"> | $Enums.PainLevel | null
    stress?: EnumStressLevelNullableFilter<"MoodTrack"> | $Enums.StressLevel | null
    sleepQuality?: EnumSleepQualityNullableFilter<"MoodTrack"> | $Enums.SleepQuality | null
    createdAt?: DateTimeFilter<"MoodTrack"> | Date | string
    updatedAt?: DateTimeFilter<"MoodTrack"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MoodTrackOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    mood?: SortOrderInput | SortOrder
    energy?: SortOrderInput | SortOrder
    pain?: SortOrderInput | SortOrder
    stress?: SortOrderInput | SortOrder
    sleepQuality?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type MoodTrackWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_date?: MoodTrackUserIdDateCompoundUniqueInput
    AND?: MoodTrackWhereInput | MoodTrackWhereInput[]
    OR?: MoodTrackWhereInput[]
    NOT?: MoodTrackWhereInput | MoodTrackWhereInput[]
    userId?: StringFilter<"MoodTrack"> | string
    date?: DateTimeFilter<"MoodTrack"> | Date | string
    mood?: EnumMoodTypeNullableFilter<"MoodTrack"> | $Enums.MoodType | null
    energy?: EnumEnergyLevelNullableFilter<"MoodTrack"> | $Enums.EnergyLevel | null
    pain?: EnumPainLevelNullableFilter<"MoodTrack"> | $Enums.PainLevel | null
    stress?: EnumStressLevelNullableFilter<"MoodTrack"> | $Enums.StressLevel | null
    sleepQuality?: EnumSleepQualityNullableFilter<"MoodTrack"> | $Enums.SleepQuality | null
    createdAt?: DateTimeFilter<"MoodTrack"> | Date | string
    updatedAt?: DateTimeFilter<"MoodTrack"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_date">

  export type MoodTrackOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    mood?: SortOrderInput | SortOrder
    energy?: SortOrderInput | SortOrder
    pain?: SortOrderInput | SortOrder
    stress?: SortOrderInput | SortOrder
    sleepQuality?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MoodTrackCountOrderByAggregateInput
    _max?: MoodTrackMaxOrderByAggregateInput
    _min?: MoodTrackMinOrderByAggregateInput
  }

  export type MoodTrackScalarWhereWithAggregatesInput = {
    AND?: MoodTrackScalarWhereWithAggregatesInput | MoodTrackScalarWhereWithAggregatesInput[]
    OR?: MoodTrackScalarWhereWithAggregatesInput[]
    NOT?: MoodTrackScalarWhereWithAggregatesInput | MoodTrackScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MoodTrack"> | string
    userId?: StringWithAggregatesFilter<"MoodTrack"> | string
    date?: DateTimeWithAggregatesFilter<"MoodTrack"> | Date | string
    mood?: EnumMoodTypeNullableWithAggregatesFilter<"MoodTrack"> | $Enums.MoodType | null
    energy?: EnumEnergyLevelNullableWithAggregatesFilter<"MoodTrack"> | $Enums.EnergyLevel | null
    pain?: EnumPainLevelNullableWithAggregatesFilter<"MoodTrack"> | $Enums.PainLevel | null
    stress?: EnumStressLevelNullableWithAggregatesFilter<"MoodTrack"> | $Enums.StressLevel | null
    sleepQuality?: EnumSleepQualityNullableWithAggregatesFilter<"MoodTrack"> | $Enums.SleepQuality | null
    createdAt?: DateTimeWithAggregatesFilter<"MoodTrack"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MoodTrack"> | Date | string
  }

  export type SymptomLogWhereInput = {
    AND?: SymptomLogWhereInput | SymptomLogWhereInput[]
    OR?: SymptomLogWhereInput[]
    NOT?: SymptomLogWhereInput | SymptomLogWhereInput[]
    id?: StringFilter<"SymptomLog"> | string
    userId?: StringFilter<"SymptomLog"> | string
    date?: DateTimeFilter<"SymptomLog"> | Date | string
    symptomType?: EnumSymptomTypeFilter<"SymptomLog"> | $Enums.SymptomType
    value?: StringFilter<"SymptomLog"> | string
    createdAt?: DateTimeFilter<"SymptomLog"> | Date | string
    updatedAt?: DateTimeFilter<"SymptomLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SymptomLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    symptomType?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SymptomLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SymptomLogWhereInput | SymptomLogWhereInput[]
    OR?: SymptomLogWhereInput[]
    NOT?: SymptomLogWhereInput | SymptomLogWhereInput[]
    userId?: StringFilter<"SymptomLog"> | string
    date?: DateTimeFilter<"SymptomLog"> | Date | string
    symptomType?: EnumSymptomTypeFilter<"SymptomLog"> | $Enums.SymptomType
    value?: StringFilter<"SymptomLog"> | string
    createdAt?: DateTimeFilter<"SymptomLog"> | Date | string
    updatedAt?: DateTimeFilter<"SymptomLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SymptomLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    symptomType?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SymptomLogCountOrderByAggregateInput
    _max?: SymptomLogMaxOrderByAggregateInput
    _min?: SymptomLogMinOrderByAggregateInput
  }

  export type SymptomLogScalarWhereWithAggregatesInput = {
    AND?: SymptomLogScalarWhereWithAggregatesInput | SymptomLogScalarWhereWithAggregatesInput[]
    OR?: SymptomLogScalarWhereWithAggregatesInput[]
    NOT?: SymptomLogScalarWhereWithAggregatesInput | SymptomLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SymptomLog"> | string
    userId?: StringWithAggregatesFilter<"SymptomLog"> | string
    date?: DateTimeWithAggregatesFilter<"SymptomLog"> | Date | string
    symptomType?: EnumSymptomTypeWithAggregatesFilter<"SymptomLog"> | $Enums.SymptomType
    value?: StringWithAggregatesFilter<"SymptomLog"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SymptomLog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SymptomLog"> | Date | string
  }

  export type UserSettingsWhereInput = {
    AND?: UserSettingsWhereInput | UserSettingsWhereInput[]
    OR?: UserSettingsWhereInput[]
    NOT?: UserSettingsWhereInput | UserSettingsWhereInput[]
    id?: StringFilter<"UserSettings"> | string
    userId?: StringFilter<"UserSettings"> | string
    unitPreference?: EnumUnitPreferenceFilter<"UserSettings"> | $Enums.UnitPreference
    notificationEnabled?: BoolFilter<"UserSettings"> | boolean
    notificationTime?: DateTimeNullableFilter<"UserSettings"> | Date | string | null
    createdAt?: DateTimeFilter<"UserSettings"> | Date | string
    updatedAt?: DateTimeFilter<"UserSettings"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserSettingsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    unitPreference?: SortOrder
    notificationEnabled?: SortOrder
    notificationTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserSettingsWhereInput | UserSettingsWhereInput[]
    OR?: UserSettingsWhereInput[]
    NOT?: UserSettingsWhereInput | UserSettingsWhereInput[]
    unitPreference?: EnumUnitPreferenceFilter<"UserSettings"> | $Enums.UnitPreference
    notificationEnabled?: BoolFilter<"UserSettings"> | boolean
    notificationTime?: DateTimeNullableFilter<"UserSettings"> | Date | string | null
    createdAt?: DateTimeFilter<"UserSettings"> | Date | string
    updatedAt?: DateTimeFilter<"UserSettings"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    unitPreference?: SortOrder
    notificationEnabled?: SortOrder
    notificationTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserSettingsCountOrderByAggregateInput
    _max?: UserSettingsMaxOrderByAggregateInput
    _min?: UserSettingsMinOrderByAggregateInput
  }

  export type UserSettingsScalarWhereWithAggregatesInput = {
    AND?: UserSettingsScalarWhereWithAggregatesInput | UserSettingsScalarWhereWithAggregatesInput[]
    OR?: UserSettingsScalarWhereWithAggregatesInput[]
    NOT?: UserSettingsScalarWhereWithAggregatesInput | UserSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSettings"> | string
    userId?: StringWithAggregatesFilter<"UserSettings"> | string
    unitPreference?: EnumUnitPreferenceWithAggregatesFilter<"UserSettings"> | $Enums.UnitPreference
    notificationEnabled?: BoolWithAggregatesFilter<"UserSettings"> | boolean
    notificationTime?: DateTimeNullableWithAggregatesFilter<"UserSettings"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserSettings"> | Date | string
  }

  export type ReminderSettingsWhereInput = {
    AND?: ReminderSettingsWhereInput | ReminderSettingsWhereInput[]
    OR?: ReminderSettingsWhereInput[]
    NOT?: ReminderSettingsWhereInput | ReminderSettingsWhereInput[]
    id?: StringFilter<"ReminderSettings"> | string
    userId?: StringFilter<"ReminderSettings"> | string
    type?: EnumReminderTypeFilter<"ReminderSettings"> | $Enums.ReminderType
    enabled?: BoolFilter<"ReminderSettings"> | boolean
    time?: DateTimeNullableFilter<"ReminderSettings"> | Date | string | null
    createdAt?: DateTimeFilter<"ReminderSettings"> | Date | string
    updatedAt?: DateTimeFilter<"ReminderSettings"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ReminderSettingsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    enabled?: SortOrder
    time?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ReminderSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReminderSettingsWhereInput | ReminderSettingsWhereInput[]
    OR?: ReminderSettingsWhereInput[]
    NOT?: ReminderSettingsWhereInput | ReminderSettingsWhereInput[]
    userId?: StringFilter<"ReminderSettings"> | string
    type?: EnumReminderTypeFilter<"ReminderSettings"> | $Enums.ReminderType
    enabled?: BoolFilter<"ReminderSettings"> | boolean
    time?: DateTimeNullableFilter<"ReminderSettings"> | Date | string | null
    createdAt?: DateTimeFilter<"ReminderSettings"> | Date | string
    updatedAt?: DateTimeFilter<"ReminderSettings"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ReminderSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    enabled?: SortOrder
    time?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReminderSettingsCountOrderByAggregateInput
    _max?: ReminderSettingsMaxOrderByAggregateInput
    _min?: ReminderSettingsMinOrderByAggregateInput
  }

  export type ReminderSettingsScalarWhereWithAggregatesInput = {
    AND?: ReminderSettingsScalarWhereWithAggregatesInput | ReminderSettingsScalarWhereWithAggregatesInput[]
    OR?: ReminderSettingsScalarWhereWithAggregatesInput[]
    NOT?: ReminderSettingsScalarWhereWithAggregatesInput | ReminderSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReminderSettings"> | string
    userId?: StringWithAggregatesFilter<"ReminderSettings"> | string
    type?: EnumReminderTypeWithAggregatesFilter<"ReminderSettings"> | $Enums.ReminderType
    enabled?: BoolWithAggregatesFilter<"ReminderSettings"> | boolean
    time?: DateTimeNullableWithAggregatesFilter<"ReminderSettings"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ReminderSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ReminderSettings"> | Date | string
  }

  export type UserFeatureFlagWhereInput = {
    AND?: UserFeatureFlagWhereInput | UserFeatureFlagWhereInput[]
    OR?: UserFeatureFlagWhereInput[]
    NOT?: UserFeatureFlagWhereInput | UserFeatureFlagWhereInput[]
    id?: StringFilter<"UserFeatureFlag"> | string
    userId?: StringFilter<"UserFeatureFlag"> | string
    feature?: StringFilter<"UserFeatureFlag"> | string
    isEnabled?: BoolFilter<"UserFeatureFlag"> | boolean
    createdAt?: DateTimeFilter<"UserFeatureFlag"> | Date | string
    updatedAt?: DateTimeFilter<"UserFeatureFlag"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserFeatureFlagOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    feature?: SortOrder
    isEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserFeatureFlagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_feature?: UserFeatureFlagUserIdFeatureCompoundUniqueInput
    AND?: UserFeatureFlagWhereInput | UserFeatureFlagWhereInput[]
    OR?: UserFeatureFlagWhereInput[]
    NOT?: UserFeatureFlagWhereInput | UserFeatureFlagWhereInput[]
    userId?: StringFilter<"UserFeatureFlag"> | string
    feature?: StringFilter<"UserFeatureFlag"> | string
    isEnabled?: BoolFilter<"UserFeatureFlag"> | boolean
    createdAt?: DateTimeFilter<"UserFeatureFlag"> | Date | string
    updatedAt?: DateTimeFilter<"UserFeatureFlag"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_feature">

  export type UserFeatureFlagOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    feature?: SortOrder
    isEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserFeatureFlagCountOrderByAggregateInput
    _max?: UserFeatureFlagMaxOrderByAggregateInput
    _min?: UserFeatureFlagMinOrderByAggregateInput
  }

  export type UserFeatureFlagScalarWhereWithAggregatesInput = {
    AND?: UserFeatureFlagScalarWhereWithAggregatesInput | UserFeatureFlagScalarWhereWithAggregatesInput[]
    OR?: UserFeatureFlagScalarWhereWithAggregatesInput[]
    NOT?: UserFeatureFlagScalarWhereWithAggregatesInput | UserFeatureFlagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserFeatureFlag"> | string
    userId?: StringWithAggregatesFilter<"UserFeatureFlag"> | string
    feature?: StringWithAggregatesFilter<"UserFeatureFlag"> | string
    isEnabled?: BoolWithAggregatesFilter<"UserFeatureFlag"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserFeatureFlag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserFeatureFlag"> | Date | string
  }

  export type UserObjectiveWhereInput = {
    AND?: UserObjectiveWhereInput | UserObjectiveWhereInput[]
    OR?: UserObjectiveWhereInput[]
    NOT?: UserObjectiveWhereInput | UserObjectiveWhereInput[]
    id?: StringFilter<"UserObjective"> | string
    userId?: StringFilter<"UserObjective"> | string
    type?: EnumObjectiveTypeFilter<"UserObjective"> | $Enums.ObjectiveType
    note?: StringNullableFilter<"UserObjective"> | string | null
    createdAt?: DateTimeFilter<"UserObjective"> | Date | string
    updatedAt?: DateTimeFilter<"UserObjective"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserObjectiveOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserObjectiveWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserObjectiveWhereInput | UserObjectiveWhereInput[]
    OR?: UserObjectiveWhereInput[]
    NOT?: UserObjectiveWhereInput | UserObjectiveWhereInput[]
    userId?: StringFilter<"UserObjective"> | string
    type?: EnumObjectiveTypeFilter<"UserObjective"> | $Enums.ObjectiveType
    note?: StringNullableFilter<"UserObjective"> | string | null
    createdAt?: DateTimeFilter<"UserObjective"> | Date | string
    updatedAt?: DateTimeFilter<"UserObjective"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserObjectiveOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserObjectiveCountOrderByAggregateInput
    _max?: UserObjectiveMaxOrderByAggregateInput
    _min?: UserObjectiveMinOrderByAggregateInput
  }

  export type UserObjectiveScalarWhereWithAggregatesInput = {
    AND?: UserObjectiveScalarWhereWithAggregatesInput | UserObjectiveScalarWhereWithAggregatesInput[]
    OR?: UserObjectiveScalarWhereWithAggregatesInput[]
    NOT?: UserObjectiveScalarWhereWithAggregatesInput | UserObjectiveScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserObjective"> | string
    userId?: StringWithAggregatesFilter<"UserObjective"> | string
    type?: EnumObjectiveTypeWithAggregatesFilter<"UserObjective"> | $Enums.ObjectiveType
    note?: StringNullableWithAggregatesFilter<"UserObjective"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserObjective"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserObjective"> | Date | string
  }

  export type ProfileChangeLogWhereInput = {
    AND?: ProfileChangeLogWhereInput | ProfileChangeLogWhereInput[]
    OR?: ProfileChangeLogWhereInput[]
    NOT?: ProfileChangeLogWhereInput | ProfileChangeLogWhereInput[]
    id?: StringFilter<"ProfileChangeLog"> | string
    userId?: StringFilter<"ProfileChangeLog"> | string
    changeType?: EnumChangeTypeFilter<"ProfileChangeLog"> | $Enums.ChangeType
    details?: StringNullableFilter<"ProfileChangeLog"> | string | null
    changedAt?: DateTimeFilter<"ProfileChangeLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ProfileChangeLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    changeType?: SortOrder
    details?: SortOrderInput | SortOrder
    changedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ProfileChangeLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProfileChangeLogWhereInput | ProfileChangeLogWhereInput[]
    OR?: ProfileChangeLogWhereInput[]
    NOT?: ProfileChangeLogWhereInput | ProfileChangeLogWhereInput[]
    userId?: StringFilter<"ProfileChangeLog"> | string
    changeType?: EnumChangeTypeFilter<"ProfileChangeLog"> | $Enums.ChangeType
    details?: StringNullableFilter<"ProfileChangeLog"> | string | null
    changedAt?: DateTimeFilter<"ProfileChangeLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ProfileChangeLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    changeType?: SortOrder
    details?: SortOrderInput | SortOrder
    changedAt?: SortOrder
    _count?: ProfileChangeLogCountOrderByAggregateInput
    _max?: ProfileChangeLogMaxOrderByAggregateInput
    _min?: ProfileChangeLogMinOrderByAggregateInput
  }

  export type ProfileChangeLogScalarWhereWithAggregatesInput = {
    AND?: ProfileChangeLogScalarWhereWithAggregatesInput | ProfileChangeLogScalarWhereWithAggregatesInput[]
    OR?: ProfileChangeLogScalarWhereWithAggregatesInput[]
    NOT?: ProfileChangeLogScalarWhereWithAggregatesInput | ProfileChangeLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProfileChangeLog"> | string
    userId?: StringWithAggregatesFilter<"ProfileChangeLog"> | string
    changeType?: EnumChangeTypeWithAggregatesFilter<"ProfileChangeLog"> | $Enums.ChangeType
    details?: StringNullableWithAggregatesFilter<"ProfileChangeLog"> | string | null
    changedAt?: DateTimeWithAggregatesFilter<"ProfileChangeLog"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    birthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    isMenopausal?: BoolFilter<"User"> | boolean
    objective?: StringNullableFilter<"User"> | string | null
    sportFrequency?: EnumSportFrequencyNullableFilter<"User"> | $Enums.SportFrequency | null
    profileType?: EnumProfileTypeFilter<"User"> | $Enums.ProfileType
    contextType?: EnumContextTypeFilter<"User"> | $Enums.ContextType
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    cycles?: CycleListRelationFilter
    programs?: ProgramListRelationFilter
    moodTracks?: MoodTrackListRelationFilter
    userSettings?: XOR<UserSettingsNullableScalarRelationFilter, UserSettingsWhereInput> | null
    reminderSettings?: ReminderSettingsListRelationFilter
    userFeatureFlags?: UserFeatureFlagListRelationFilter
    userObjectives?: UserObjectiveListRelationFilter
    profileChangeLogs?: ProfileChangeLogListRelationFilter
    cycleProfileConfig?: XOR<CycleProfileConfigNullableScalarRelationFilter, CycleProfileConfigWhereInput> | null
    symptomLogs?: SymptomLogListRelationFilter
    notifications?: NotificationListRelationFilter
    externalSyncs?: ExternalSyncListRelationFilter
    journalEntries?: JournalEntryListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    logs?: LogListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
    authSessions?: AuthSessionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    isMenopausal?: SortOrder
    objective?: SortOrderInput | SortOrder
    sportFrequency?: SortOrderInput | SortOrder
    profileType?: SortOrder
    contextType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cycles?: CycleOrderByRelationAggregateInput
    programs?: ProgramOrderByRelationAggregateInput
    moodTracks?: MoodTrackOrderByRelationAggregateInput
    userSettings?: UserSettingsOrderByWithRelationInput
    reminderSettings?: ReminderSettingsOrderByRelationAggregateInput
    userFeatureFlags?: UserFeatureFlagOrderByRelationAggregateInput
    userObjectives?: UserObjectiveOrderByRelationAggregateInput
    profileChangeLogs?: ProfileChangeLogOrderByRelationAggregateInput
    cycleProfileConfig?: CycleProfileConfigOrderByWithRelationInput
    symptomLogs?: SymptomLogOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    externalSyncs?: ExternalSyncOrderByRelationAggregateInput
    journalEntries?: JournalEntryOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    logs?: LogOrderByRelationAggregateInput
    refreshTokens?: RefreshTokenOrderByRelationAggregateInput
    authSessions?: AuthSessionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    birthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    isMenopausal?: BoolFilter<"User"> | boolean
    objective?: StringNullableFilter<"User"> | string | null
    sportFrequency?: EnumSportFrequencyNullableFilter<"User"> | $Enums.SportFrequency | null
    profileType?: EnumProfileTypeFilter<"User"> | $Enums.ProfileType
    contextType?: EnumContextTypeFilter<"User"> | $Enums.ContextType
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    cycles?: CycleListRelationFilter
    programs?: ProgramListRelationFilter
    moodTracks?: MoodTrackListRelationFilter
    userSettings?: XOR<UserSettingsNullableScalarRelationFilter, UserSettingsWhereInput> | null
    reminderSettings?: ReminderSettingsListRelationFilter
    userFeatureFlags?: UserFeatureFlagListRelationFilter
    userObjectives?: UserObjectiveListRelationFilter
    profileChangeLogs?: ProfileChangeLogListRelationFilter
    cycleProfileConfig?: XOR<CycleProfileConfigNullableScalarRelationFilter, CycleProfileConfigWhereInput> | null
    symptomLogs?: SymptomLogListRelationFilter
    notifications?: NotificationListRelationFilter
    externalSyncs?: ExternalSyncListRelationFilter
    journalEntries?: JournalEntryListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    logs?: LogListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
    authSessions?: AuthSessionListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    isMenopausal?: SortOrder
    objective?: SortOrderInput | SortOrder
    sportFrequency?: SortOrderInput | SortOrder
    profileType?: SortOrder
    contextType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    birthDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    isMenopausal?: BoolWithAggregatesFilter<"User"> | boolean
    objective?: StringNullableWithAggregatesFilter<"User"> | string | null
    sportFrequency?: EnumSportFrequencyNullableWithAggregatesFilter<"User"> | $Enums.SportFrequency | null
    profileType?: EnumProfileTypeWithAggregatesFilter<"User"> | $Enums.ProfileType
    contextType?: EnumContextTypeWithAggregatesFilter<"User"> | $Enums.ContextType
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type CycleCreateInput = {
    id?: string
    startDate: Date | string
    cycleLength?: number | null
    periodLength?: number | null
    isRegular?: boolean
    externalCycleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCyclesInput
    provider?: CycleProviderCreateNestedOneWithoutCyclesInput
    phases?: PhaseCreateNestedManyWithoutCycleInput
  }

  export type CycleUncheckedCreateInput = {
    id?: string
    userId: string
    startDate: Date | string
    cycleLength?: number | null
    periodLength?: number | null
    isRegular?: boolean
    providerId?: string | null
    externalCycleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phases?: PhaseUncheckedCreateNestedManyWithoutCycleInput
  }

  export type CycleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cycleLength?: NullableIntFieldUpdateOperationsInput | number | null
    periodLength?: NullableIntFieldUpdateOperationsInput | number | null
    isRegular?: BoolFieldUpdateOperationsInput | boolean
    externalCycleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCyclesNestedInput
    provider?: CycleProviderUpdateOneWithoutCyclesNestedInput
    phases?: PhaseUpdateManyWithoutCycleNestedInput
  }

  export type CycleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cycleLength?: NullableIntFieldUpdateOperationsInput | number | null
    periodLength?: NullableIntFieldUpdateOperationsInput | number | null
    isRegular?: BoolFieldUpdateOperationsInput | boolean
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    externalCycleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phases?: PhaseUncheckedUpdateManyWithoutCycleNestedInput
  }

  export type CycleCreateManyInput = {
    id?: string
    userId: string
    startDate: Date | string
    cycleLength?: number | null
    periodLength?: number | null
    isRegular?: boolean
    providerId?: string | null
    externalCycleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CycleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cycleLength?: NullableIntFieldUpdateOperationsInput | number | null
    periodLength?: NullableIntFieldUpdateOperationsInput | number | null
    isRegular?: BoolFieldUpdateOperationsInput | boolean
    externalCycleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CycleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cycleLength?: NullableIntFieldUpdateOperationsInput | number | null
    periodLength?: NullableIntFieldUpdateOperationsInput | number | null
    isRegular?: BoolFieldUpdateOperationsInput | boolean
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    externalCycleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CycleProfileConfigCreateInput = {
    id?: string
    isCycleTrackingEnabled?: boolean
    usesExternalProvider?: boolean
    useMenopauseMode?: boolean
    averageCycleLength?: number | null
    averagePeriodLength?: number | null
    prefersManualInput?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCycleProfileConfigInput
  }

  export type CycleProfileConfigUncheckedCreateInput = {
    id?: string
    userId: string
    isCycleTrackingEnabled?: boolean
    usesExternalProvider?: boolean
    useMenopauseMode?: boolean
    averageCycleLength?: number | null
    averagePeriodLength?: number | null
    prefersManualInput?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CycleProfileConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCycleTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    usesExternalProvider?: BoolFieldUpdateOperationsInput | boolean
    useMenopauseMode?: BoolFieldUpdateOperationsInput | boolean
    averageCycleLength?: NullableIntFieldUpdateOperationsInput | number | null
    averagePeriodLength?: NullableIntFieldUpdateOperationsInput | number | null
    prefersManualInput?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCycleProfileConfigNestedInput
  }

  export type CycleProfileConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isCycleTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    usesExternalProvider?: BoolFieldUpdateOperationsInput | boolean
    useMenopauseMode?: BoolFieldUpdateOperationsInput | boolean
    averageCycleLength?: NullableIntFieldUpdateOperationsInput | number | null
    averagePeriodLength?: NullableIntFieldUpdateOperationsInput | number | null
    prefersManualInput?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CycleProfileConfigCreateManyInput = {
    id?: string
    userId: string
    isCycleTrackingEnabled?: boolean
    usesExternalProvider?: boolean
    useMenopauseMode?: boolean
    averageCycleLength?: number | null
    averagePeriodLength?: number | null
    prefersManualInput?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CycleProfileConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCycleTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    usesExternalProvider?: BoolFieldUpdateOperationsInput | boolean
    useMenopauseMode?: BoolFieldUpdateOperationsInput | boolean
    averageCycleLength?: NullableIntFieldUpdateOperationsInput | number | null
    averagePeriodLength?: NullableIntFieldUpdateOperationsInput | number | null
    prefersManualInput?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CycleProfileConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isCycleTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    usesExternalProvider?: BoolFieldUpdateOperationsInput | boolean
    useMenopauseMode?: BoolFieldUpdateOperationsInput | boolean
    averageCycleLength?: NullableIntFieldUpdateOperationsInput | number | null
    averagePeriodLength?: NullableIntFieldUpdateOperationsInput | number | null
    prefersManualInput?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CycleProviderCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cycles?: CycleCreateNestedManyWithoutProviderInput
  }

  export type CycleProviderUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cycles?: CycleUncheckedCreateNestedManyWithoutProviderInput
  }

  export type CycleProviderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cycles?: CycleUpdateManyWithoutProviderNestedInput
  }

  export type CycleProviderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cycles?: CycleUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type CycleProviderCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CycleProviderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CycleProviderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhaseCreateInput = {
    id?: string
    name: $Enums.CyclePhase
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    cycle: CycleCreateNestedOneWithoutPhasesInput
  }

  export type PhaseUncheckedCreateInput = {
    id?: string
    cycleId: string
    name: $Enums.CyclePhase
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PhaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumCyclePhaseFieldUpdateOperationsInput | $Enums.CyclePhase
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cycle?: CycleUpdateOneRequiredWithoutPhasesNestedInput
  }

  export type PhaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cycleId?: StringFieldUpdateOperationsInput | string
    name?: EnumCyclePhaseFieldUpdateOperationsInput | $Enums.CyclePhase
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhaseCreateManyInput = {
    id?: string
    cycleId: string
    name: $Enums.CyclePhase
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PhaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumCyclePhaseFieldUpdateOperationsInput | $Enums.CyclePhase
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cycleId?: StringFieldUpdateOperationsInput | string
    name?: EnumCyclePhaseFieldUpdateOperationsInput | $Enums.CyclePhase
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseCreateInput = {
    id?: string
    title: string
    description?: string | null
    imageUrl?: string | null
    durationMinutes?: number | null
    intensity?: $Enums.Intensity | null
    muscleZone?: $Enums.MuscleZone | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exerciseTags?: ExerciseTagCreateNestedManyWithoutExerciseInput
    phaseExercises?: PhaseExerciseCreateNestedManyWithoutExerciseInput
    programExercises?: ProgramExerciseCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    imageUrl?: string | null
    durationMinutes?: number | null
    intensity?: $Enums.Intensity | null
    muscleZone?: $Enums.MuscleZone | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exerciseTags?: ExerciseTagUncheckedCreateNestedManyWithoutExerciseInput
    phaseExercises?: PhaseExerciseUncheckedCreateNestedManyWithoutExerciseInput
    programExercises?: ProgramExerciseUncheckedCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    intensity?: NullableEnumIntensityFieldUpdateOperationsInput | $Enums.Intensity | null
    muscleZone?: NullableEnumMuscleZoneFieldUpdateOperationsInput | $Enums.MuscleZone | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exerciseTags?: ExerciseTagUpdateManyWithoutExerciseNestedInput
    phaseExercises?: PhaseExerciseUpdateManyWithoutExerciseNestedInput
    programExercises?: ProgramExerciseUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    intensity?: NullableEnumIntensityFieldUpdateOperationsInput | $Enums.Intensity | null
    muscleZone?: NullableEnumMuscleZoneFieldUpdateOperationsInput | $Enums.MuscleZone | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exerciseTags?: ExerciseTagUncheckedUpdateManyWithoutExerciseNestedInput
    phaseExercises?: PhaseExerciseUncheckedUpdateManyWithoutExerciseNestedInput
    programExercises?: ProgramExerciseUncheckedUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    imageUrl?: string | null
    durationMinutes?: number | null
    intensity?: $Enums.Intensity | null
    muscleZone?: $Enums.MuscleZone | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExerciseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    intensity?: NullableEnumIntensityFieldUpdateOperationsInput | $Enums.Intensity | null
    muscleZone?: NullableEnumMuscleZoneFieldUpdateOperationsInput | $Enums.MuscleZone | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    intensity?: NullableEnumIntensityFieldUpdateOperationsInput | $Enums.Intensity | null
    muscleZone?: NullableEnumMuscleZoneFieldUpdateOperationsInput | $Enums.MuscleZone | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagCreateInput = {
    id?: string
    name: string
    type: $Enums.TagType
    createdAt?: Date | string
    updatedAt?: Date | string
    exerciseTags?: ExerciseTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.TagType
    createdAt?: Date | string
    updatedAt?: Date | string
    exerciseTags?: ExerciseTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTagTypeFieldUpdateOperationsInput | $Enums.TagType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exerciseTags?: ExerciseTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTagTypeFieldUpdateOperationsInput | $Enums.TagType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exerciseTags?: ExerciseTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagCreateManyInput = {
    id?: string
    name: string
    type: $Enums.TagType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTagTypeFieldUpdateOperationsInput | $Enums.TagType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTagTypeFieldUpdateOperationsInput | $Enums.TagType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseTagCreateInput = {
    id?: string
    createdAt?: Date | string
    exercise: ExerciseCreateNestedOneWithoutExerciseTagsInput
    tag: TagCreateNestedOneWithoutExerciseTagsInput
  }

  export type ExerciseTagUncheckedCreateInput = {
    id?: string
    exerciseId: string
    tagId: string
    createdAt?: Date | string
  }

  export type ExerciseTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exercise?: ExerciseUpdateOneRequiredWithoutExerciseTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutExerciseTagsNestedInput
  }

  export type ExerciseTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseTagCreateManyInput = {
    id?: string
    exerciseId: string
    tagId: string
    createdAt?: Date | string
  }

  export type ExerciseTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhaseExerciseCreateInput = {
    id?: string
    phaseName: $Enums.CyclePhase
    createdAt?: Date | string
    exercise: ExerciseCreateNestedOneWithoutPhaseExercisesInput
  }

  export type PhaseExerciseUncheckedCreateInput = {
    id?: string
    phaseName: $Enums.CyclePhase
    exerciseId: string
    createdAt?: Date | string
  }

  export type PhaseExerciseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phaseName?: EnumCyclePhaseFieldUpdateOperationsInput | $Enums.CyclePhase
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exercise?: ExerciseUpdateOneRequiredWithoutPhaseExercisesNestedInput
  }

  export type PhaseExerciseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phaseName?: EnumCyclePhaseFieldUpdateOperationsInput | $Enums.CyclePhase
    exerciseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhaseExerciseCreateManyInput = {
    id?: string
    phaseName: $Enums.CyclePhase
    exerciseId: string
    createdAt?: Date | string
  }

  export type PhaseExerciseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phaseName?: EnumCyclePhaseFieldUpdateOperationsInput | $Enums.CyclePhase
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhaseExerciseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    phaseName?: EnumCyclePhaseFieldUpdateOperationsInput | $Enums.CyclePhase
    exerciseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramCreateInput = {
    id?: string
    title: string
    goal?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProgramsInput
    programExercises?: ProgramExerciseCreateNestedManyWithoutProgramInput
    notifications?: NotificationCreateNestedManyWithoutRelatedProgramInput
  }

  export type ProgramUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    goal?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    programExercises?: ProgramExerciseUncheckedCreateNestedManyWithoutProgramInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRelatedProgramInput
  }

  export type ProgramUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    goal?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProgramsNestedInput
    programExercises?: ProgramExerciseUpdateManyWithoutProgramNestedInput
    notifications?: NotificationUpdateManyWithoutRelatedProgramNestedInput
  }

  export type ProgramUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    goal?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programExercises?: ProgramExerciseUncheckedUpdateManyWithoutProgramNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRelatedProgramNestedInput
  }

  export type ProgramCreateManyInput = {
    id?: string
    userId: string
    title: string
    goal?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgramUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    goal?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    goal?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramExerciseCreateInput = {
    id?: string
    day: number
    order: number
    createdAt?: Date | string
    program: ProgramCreateNestedOneWithoutProgramExercisesInput
    exercise: ExerciseCreateNestedOneWithoutProgramExercisesInput
  }

  export type ProgramExerciseUncheckedCreateInput = {
    id?: string
    programId: string
    exerciseId: string
    day: number
    order: number
    createdAt?: Date | string
  }

  export type ProgramExerciseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    day?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    program?: ProgramUpdateOneRequiredWithoutProgramExercisesNestedInput
    exercise?: ExerciseUpdateOneRequiredWithoutProgramExercisesNestedInput
  }

  export type ProgramExerciseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    day?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramExerciseCreateManyInput = {
    id?: string
    programId: string
    exerciseId: string
    day: number
    order: number
    createdAt?: Date | string
  }

  export type ProgramExerciseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    day?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramExerciseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    day?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: $Enums.NotificationType
    message: string
    date: Date | string
    relatedPhase?: string | null
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
    relatedProgram?: ProgramCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    message: string
    date: Date | string
    relatedPhase?: string | null
    relatedProgramId?: string | null
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    message?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedPhase?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
    relatedProgram?: ProgramUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    message?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedPhase?: NullableStringFieldUpdateOperationsInput | string | null
    relatedProgramId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    message: string
    date: Date | string
    relatedPhase?: string | null
    relatedProgramId?: string | null
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    message?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedPhase?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    message?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedPhase?: NullableStringFieldUpdateOperationsInput | string | null
    relatedProgramId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalSyncCreateInput = {
    id?: string
    provider: $Enums.ExternalProvider
    entitySynced: string
    externalId: string
    status: $Enums.ExternalSyncStatus
    message?: string | null
    syncedAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutExternalSyncsInput
  }

  export type ExternalSyncUncheckedCreateInput = {
    id?: string
    userId: string
    provider: $Enums.ExternalProvider
    entitySynced: string
    externalId: string
    status: $Enums.ExternalSyncStatus
    message?: string | null
    syncedAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExternalSyncUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumExternalProviderFieldUpdateOperationsInput | $Enums.ExternalProvider
    entitySynced?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    status?: EnumExternalSyncStatusFieldUpdateOperationsInput | $Enums.ExternalSyncStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    syncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExternalSyncsNestedInput
  }

  export type ExternalSyncUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: EnumExternalProviderFieldUpdateOperationsInput | $Enums.ExternalProvider
    entitySynced?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    status?: EnumExternalSyncStatusFieldUpdateOperationsInput | $Enums.ExternalSyncStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    syncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalSyncCreateManyInput = {
    id?: string
    userId: string
    provider: $Enums.ExternalProvider
    entitySynced: string
    externalId: string
    status: $Enums.ExternalSyncStatus
    message?: string | null
    syncedAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExternalSyncUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumExternalProviderFieldUpdateOperationsInput | $Enums.ExternalProvider
    entitySynced?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    status?: EnumExternalSyncStatusFieldUpdateOperationsInput | $Enums.ExternalSyncStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    syncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalSyncUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: EnumExternalProviderFieldUpdateOperationsInput | $Enums.ExternalProvider
    entitySynced?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    status?: EnumExternalSyncStatusFieldUpdateOperationsInput | $Enums.ExternalSyncStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    syncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalEntryCreateInput = {
    id?: string
    date: Date | string
    category: $Enums.JournalCategory
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutJournalEntriesInput
  }

  export type JournalEntryUncheckedCreateInput = {
    id?: string
    userId: string
    date: Date | string
    category: $Enums.JournalCategory
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumJournalCategoryFieldUpdateOperationsInput | $Enums.JournalCategory
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutJournalEntriesNestedInput
  }

  export type JournalEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumJournalCategoryFieldUpdateOperationsInput | $Enums.JournalCategory
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalEntryCreateManyInput = {
    id?: string
    userId: string
    date: Date | string
    category: $Enums.JournalCategory
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumJournalCategoryFieldUpdateOperationsInput | $Enums.JournalCategory
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumJournalCategoryFieldUpdateOperationsInput | $Enums.JournalCategory
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    entity: string
    entityId?: string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    action: string
    entity: string
    entityId?: string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId?: string | null
    action: string
    entity: string
    entityId?: string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogCreateInput = {
    id?: string
    eventType: $Enums.EventType
    description?: string | null
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user?: UserCreateNestedOneWithoutLogsInput
  }

  export type LogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    eventType: $Enums.EventType
    description?: string | null
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneWithoutLogsNestedInput
  }

  export type LogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LogCreateManyInput = {
    id?: string
    userId?: string | null
    eventType: $Enums.EventType
    description?: string | null
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RefreshTokenCreateInput = {
    id?: string
    tokenHash: string
    expiresAt: Date | string
    revoked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRefreshTokensInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: string
    userId: string
    tokenHash: string
    expiresAt: Date | string
    revoked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateManyInput = {
    id?: string
    userId: string
    tokenHash: string
    expiresAt: Date | string
    revoked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthSessionCreateInput = {
    id?: string
    userAgent?: string | null
    ipAddress?: string | null
    lastSeen: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAuthSessionsInput
  }

  export type AuthSessionUncheckedCreateInput = {
    id?: string
    userId: string
    userAgent?: string | null
    ipAddress?: string | null
    lastSeen: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuthSessionsNestedInput
  }

  export type AuthSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthSessionCreateManyInput = {
    id?: string
    userId: string
    userAgent?: string | null
    ipAddress?: string | null
    lastSeen: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MoodTrackCreateInput = {
    id?: string
    date: Date | string
    mood?: $Enums.MoodType | null
    energy?: $Enums.EnergyLevel | null
    pain?: $Enums.PainLevel | null
    stress?: $Enums.StressLevel | null
    sleepQuality?: $Enums.SleepQuality | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMoodTracksInput
  }

  export type MoodTrackUncheckedCreateInput = {
    id?: string
    userId: string
    date: Date | string
    mood?: $Enums.MoodType | null
    energy?: $Enums.EnergyLevel | null
    pain?: $Enums.PainLevel | null
    stress?: $Enums.StressLevel | null
    sleepQuality?: $Enums.SleepQuality | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MoodTrackUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    mood?: NullableEnumMoodTypeFieldUpdateOperationsInput | $Enums.MoodType | null
    energy?: NullableEnumEnergyLevelFieldUpdateOperationsInput | $Enums.EnergyLevel | null
    pain?: NullableEnumPainLevelFieldUpdateOperationsInput | $Enums.PainLevel | null
    stress?: NullableEnumStressLevelFieldUpdateOperationsInput | $Enums.StressLevel | null
    sleepQuality?: NullableEnumSleepQualityFieldUpdateOperationsInput | $Enums.SleepQuality | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMoodTracksNestedInput
  }

  export type MoodTrackUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    mood?: NullableEnumMoodTypeFieldUpdateOperationsInput | $Enums.MoodType | null
    energy?: NullableEnumEnergyLevelFieldUpdateOperationsInput | $Enums.EnergyLevel | null
    pain?: NullableEnumPainLevelFieldUpdateOperationsInput | $Enums.PainLevel | null
    stress?: NullableEnumStressLevelFieldUpdateOperationsInput | $Enums.StressLevel | null
    sleepQuality?: NullableEnumSleepQualityFieldUpdateOperationsInput | $Enums.SleepQuality | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MoodTrackCreateManyInput = {
    id?: string
    userId: string
    date: Date | string
    mood?: $Enums.MoodType | null
    energy?: $Enums.EnergyLevel | null
    pain?: $Enums.PainLevel | null
    stress?: $Enums.StressLevel | null
    sleepQuality?: $Enums.SleepQuality | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MoodTrackUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    mood?: NullableEnumMoodTypeFieldUpdateOperationsInput | $Enums.MoodType | null
    energy?: NullableEnumEnergyLevelFieldUpdateOperationsInput | $Enums.EnergyLevel | null
    pain?: NullableEnumPainLevelFieldUpdateOperationsInput | $Enums.PainLevel | null
    stress?: NullableEnumStressLevelFieldUpdateOperationsInput | $Enums.StressLevel | null
    sleepQuality?: NullableEnumSleepQualityFieldUpdateOperationsInput | $Enums.SleepQuality | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MoodTrackUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    mood?: NullableEnumMoodTypeFieldUpdateOperationsInput | $Enums.MoodType | null
    energy?: NullableEnumEnergyLevelFieldUpdateOperationsInput | $Enums.EnergyLevel | null
    pain?: NullableEnumPainLevelFieldUpdateOperationsInput | $Enums.PainLevel | null
    stress?: NullableEnumStressLevelFieldUpdateOperationsInput | $Enums.StressLevel | null
    sleepQuality?: NullableEnumSleepQualityFieldUpdateOperationsInput | $Enums.SleepQuality | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SymptomLogCreateInput = {
    id?: string
    date: Date | string
    symptomType: $Enums.SymptomType
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSymptomLogsInput
  }

  export type SymptomLogUncheckedCreateInput = {
    id?: string
    userId: string
    date: Date | string
    symptomType: $Enums.SymptomType
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SymptomLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    symptomType?: EnumSymptomTypeFieldUpdateOperationsInput | $Enums.SymptomType
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSymptomLogsNestedInput
  }

  export type SymptomLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    symptomType?: EnumSymptomTypeFieldUpdateOperationsInput | $Enums.SymptomType
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SymptomLogCreateManyInput = {
    id?: string
    userId: string
    date: Date | string
    symptomType: $Enums.SymptomType
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SymptomLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    symptomType?: EnumSymptomTypeFieldUpdateOperationsInput | $Enums.SymptomType
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SymptomLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    symptomType?: EnumSymptomTypeFieldUpdateOperationsInput | $Enums.SymptomType
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsCreateInput = {
    id?: string
    unitPreference?: $Enums.UnitPreference
    notificationEnabled?: boolean
    notificationTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserSettingsInput
  }

  export type UserSettingsUncheckedCreateInput = {
    id?: string
    userId: string
    unitPreference?: $Enums.UnitPreference
    notificationEnabled?: boolean
    notificationTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitPreference?: EnumUnitPreferenceFieldUpdateOperationsInput | $Enums.UnitPreference
    notificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserSettingsNestedInput
  }

  export type UserSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    unitPreference?: EnumUnitPreferenceFieldUpdateOperationsInput | $Enums.UnitPreference
    notificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsCreateManyInput = {
    id?: string
    userId: string
    unitPreference?: $Enums.UnitPreference
    notificationEnabled?: boolean
    notificationTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitPreference?: EnumUnitPreferenceFieldUpdateOperationsInput | $Enums.UnitPreference
    notificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    unitPreference?: EnumUnitPreferenceFieldUpdateOperationsInput | $Enums.UnitPreference
    notificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReminderSettingsCreateInput = {
    id?: string
    type: $Enums.ReminderType
    enabled?: boolean
    time?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutReminderSettingsInput
  }

  export type ReminderSettingsUncheckedCreateInput = {
    id?: string
    userId: string
    type: $Enums.ReminderType
    enabled?: boolean
    time?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReminderSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReminderTypeFieldUpdateOperationsInput | $Enums.ReminderType
    enabled?: BoolFieldUpdateOperationsInput | boolean
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReminderSettingsNestedInput
  }

  export type ReminderSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumReminderTypeFieldUpdateOperationsInput | $Enums.ReminderType
    enabled?: BoolFieldUpdateOperationsInput | boolean
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReminderSettingsCreateManyInput = {
    id?: string
    userId: string
    type: $Enums.ReminderType
    enabled?: boolean
    time?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReminderSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReminderTypeFieldUpdateOperationsInput | $Enums.ReminderType
    enabled?: BoolFieldUpdateOperationsInput | boolean
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReminderSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumReminderTypeFieldUpdateOperationsInput | $Enums.ReminderType
    enabled?: BoolFieldUpdateOperationsInput | boolean
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFeatureFlagCreateInput = {
    id?: string
    feature: string
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserFeatureFlagsInput
  }

  export type UserFeatureFlagUncheckedCreateInput = {
    id?: string
    userId: string
    feature: string
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserFeatureFlagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserFeatureFlagsNestedInput
  }

  export type UserFeatureFlagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFeatureFlagCreateManyInput = {
    id?: string
    userId: string
    feature: string
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserFeatureFlagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFeatureFlagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserObjectiveCreateInput = {
    id?: string
    type: $Enums.ObjectiveType
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserObjectivesInput
  }

  export type UserObjectiveUncheckedCreateInput = {
    id?: string
    userId: string
    type: $Enums.ObjectiveType
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserObjectiveUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumObjectiveTypeFieldUpdateOperationsInput | $Enums.ObjectiveType
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserObjectivesNestedInput
  }

  export type UserObjectiveUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumObjectiveTypeFieldUpdateOperationsInput | $Enums.ObjectiveType
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserObjectiveCreateManyInput = {
    id?: string
    userId: string
    type: $Enums.ObjectiveType
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserObjectiveUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumObjectiveTypeFieldUpdateOperationsInput | $Enums.ObjectiveType
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserObjectiveUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumObjectiveTypeFieldUpdateOperationsInput | $Enums.ObjectiveType
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileChangeLogCreateInput = {
    id?: string
    changeType: $Enums.ChangeType
    details?: string | null
    changedAt?: Date | string
    user: UserCreateNestedOneWithoutProfileChangeLogsInput
  }

  export type ProfileChangeLogUncheckedCreateInput = {
    id?: string
    userId: string
    changeType: $Enums.ChangeType
    details?: string | null
    changedAt?: Date | string
  }

  export type ProfileChangeLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeType?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    details?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProfileChangeLogsNestedInput
  }

  export type ProfileChangeLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    changeType?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    details?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileChangeLogCreateManyInput = {
    id?: string
    userId: string
    changeType: $Enums.ChangeType
    details?: string | null
    changedAt?: Date | string
  }

  export type ProfileChangeLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeType?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    details?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileChangeLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    changeType?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    details?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    birthDate?: Date | string | null
    isMenopausal?: boolean
    objective?: string | null
    sportFrequency?: $Enums.SportFrequency | null
    profileType?: $Enums.ProfileType
    contextType?: $Enums.ContextType
    createdAt?: Date | string
    updatedAt?: Date | string
    cycles?: CycleCreateNestedManyWithoutUserInput
    programs?: ProgramCreateNestedManyWithoutUserInput
    moodTracks?: MoodTrackCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
    reminderSettings?: ReminderSettingsCreateNestedManyWithoutUserInput
    userFeatureFlags?: UserFeatureFlagCreateNestedManyWithoutUserInput
    userObjectives?: UserObjectiveCreateNestedManyWithoutUserInput
    profileChangeLogs?: ProfileChangeLogCreateNestedManyWithoutUserInput
    cycleProfileConfig?: CycleProfileConfigCreateNestedOneWithoutUserInput
    symptomLogs?: SymptomLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    externalSyncs?: ExternalSyncCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    birthDate?: Date | string | null
    isMenopausal?: boolean
    objective?: string | null
    sportFrequency?: $Enums.SportFrequency | null
    profileType?: $Enums.ProfileType
    contextType?: $Enums.ContextType
    createdAt?: Date | string
    updatedAt?: Date | string
    cycles?: CycleUncheckedCreateNestedManyWithoutUserInput
    programs?: ProgramUncheckedCreateNestedManyWithoutUserInput
    moodTracks?: MoodTrackUncheckedCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    reminderSettings?: ReminderSettingsUncheckedCreateNestedManyWithoutUserInput
    userFeatureFlags?: UserFeatureFlagUncheckedCreateNestedManyWithoutUserInput
    userObjectives?: UserObjectiveUncheckedCreateNestedManyWithoutUserInput
    profileChangeLogs?: ProfileChangeLogUncheckedCreateNestedManyWithoutUserInput
    cycleProfileConfig?: CycleProfileConfigUncheckedCreateNestedOneWithoutUserInput
    symptomLogs?: SymptomLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    externalSyncs?: ExternalSyncUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isMenopausal?: BoolFieldUpdateOperationsInput | boolean
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    sportFrequency?: NullableEnumSportFrequencyFieldUpdateOperationsInput | $Enums.SportFrequency | null
    profileType?: EnumProfileTypeFieldUpdateOperationsInput | $Enums.ProfileType
    contextType?: EnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cycles?: CycleUpdateManyWithoutUserNestedInput
    programs?: ProgramUpdateManyWithoutUserNestedInput
    moodTracks?: MoodTrackUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
    reminderSettings?: ReminderSettingsUpdateManyWithoutUserNestedInput
    userFeatureFlags?: UserFeatureFlagUpdateManyWithoutUserNestedInput
    userObjectives?: UserObjectiveUpdateManyWithoutUserNestedInput
    profileChangeLogs?: ProfileChangeLogUpdateManyWithoutUserNestedInput
    cycleProfileConfig?: CycleProfileConfigUpdateOneWithoutUserNestedInput
    symptomLogs?: SymptomLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    externalSyncs?: ExternalSyncUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isMenopausal?: BoolFieldUpdateOperationsInput | boolean
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    sportFrequency?: NullableEnumSportFrequencyFieldUpdateOperationsInput | $Enums.SportFrequency | null
    profileType?: EnumProfileTypeFieldUpdateOperationsInput | $Enums.ProfileType
    contextType?: EnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cycles?: CycleUncheckedUpdateManyWithoutUserNestedInput
    programs?: ProgramUncheckedUpdateManyWithoutUserNestedInput
    moodTracks?: MoodTrackUncheckedUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    reminderSettings?: ReminderSettingsUncheckedUpdateManyWithoutUserNestedInput
    userFeatureFlags?: UserFeatureFlagUncheckedUpdateManyWithoutUserNestedInput
    userObjectives?: UserObjectiveUncheckedUpdateManyWithoutUserNestedInput
    profileChangeLogs?: ProfileChangeLogUncheckedUpdateManyWithoutUserNestedInput
    cycleProfileConfig?: CycleProfileConfigUncheckedUpdateOneWithoutUserNestedInput
    symptomLogs?: SymptomLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    externalSyncs?: ExternalSyncUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    birthDate?: Date | string | null
    isMenopausal?: boolean
    objective?: string | null
    sportFrequency?: $Enums.SportFrequency | null
    profileType?: $Enums.ProfileType
    contextType?: $Enums.ContextType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isMenopausal?: BoolFieldUpdateOperationsInput | boolean
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    sportFrequency?: NullableEnumSportFrequencyFieldUpdateOperationsInput | $Enums.SportFrequency | null
    profileType?: EnumProfileTypeFieldUpdateOperationsInput | $Enums.ProfileType
    contextType?: EnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isMenopausal?: BoolFieldUpdateOperationsInput | boolean
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    sportFrequency?: NullableEnumSportFrequencyFieldUpdateOperationsInput | $Enums.SportFrequency | null
    profileType?: EnumProfileTypeFieldUpdateOperationsInput | $Enums.ProfileType
    contextType?: EnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CycleProviderNullableScalarRelationFilter = {
    is?: CycleProviderWhereInput | null
    isNot?: CycleProviderWhereInput | null
  }

  export type PhaseListRelationFilter = {
    every?: PhaseWhereInput
    some?: PhaseWhereInput
    none?: PhaseWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PhaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CycleCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    startDate?: SortOrder
    cycleLength?: SortOrder
    periodLength?: SortOrder
    isRegular?: SortOrder
    providerId?: SortOrder
    externalCycleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CycleAvgOrderByAggregateInput = {
    cycleLength?: SortOrder
    periodLength?: SortOrder
  }

  export type CycleMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    startDate?: SortOrder
    cycleLength?: SortOrder
    periodLength?: SortOrder
    isRegular?: SortOrder
    providerId?: SortOrder
    externalCycleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CycleMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    startDate?: SortOrder
    cycleLength?: SortOrder
    periodLength?: SortOrder
    isRegular?: SortOrder
    providerId?: SortOrder
    externalCycleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CycleSumOrderByAggregateInput = {
    cycleLength?: SortOrder
    periodLength?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type CycleProfileConfigCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    isCycleTrackingEnabled?: SortOrder
    usesExternalProvider?: SortOrder
    useMenopauseMode?: SortOrder
    averageCycleLength?: SortOrder
    averagePeriodLength?: SortOrder
    prefersManualInput?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CycleProfileConfigAvgOrderByAggregateInput = {
    averageCycleLength?: SortOrder
    averagePeriodLength?: SortOrder
  }

  export type CycleProfileConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    isCycleTrackingEnabled?: SortOrder
    usesExternalProvider?: SortOrder
    useMenopauseMode?: SortOrder
    averageCycleLength?: SortOrder
    averagePeriodLength?: SortOrder
    prefersManualInput?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CycleProfileConfigMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    isCycleTrackingEnabled?: SortOrder
    usesExternalProvider?: SortOrder
    useMenopauseMode?: SortOrder
    averageCycleLength?: SortOrder
    averagePeriodLength?: SortOrder
    prefersManualInput?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CycleProfileConfigSumOrderByAggregateInput = {
    averageCycleLength?: SortOrder
    averagePeriodLength?: SortOrder
  }

  export type CycleListRelationFilter = {
    every?: CycleWhereInput
    some?: CycleWhereInput
    none?: CycleWhereInput
  }

  export type CycleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CycleProviderCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CycleProviderMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CycleProviderMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCyclePhaseFilter<$PrismaModel = never> = {
    equals?: $Enums.CyclePhase | EnumCyclePhaseFieldRefInput<$PrismaModel>
    in?: $Enums.CyclePhase[] | ListEnumCyclePhaseFieldRefInput<$PrismaModel>
    notIn?: $Enums.CyclePhase[] | ListEnumCyclePhaseFieldRefInput<$PrismaModel>
    not?: NestedEnumCyclePhaseFilter<$PrismaModel> | $Enums.CyclePhase
  }

  export type CycleScalarRelationFilter = {
    is?: CycleWhereInput
    isNot?: CycleWhereInput
  }

  export type PhaseCountOrderByAggregateInput = {
    id?: SortOrder
    cycleId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PhaseMaxOrderByAggregateInput = {
    id?: SortOrder
    cycleId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PhaseMinOrderByAggregateInput = {
    id?: SortOrder
    cycleId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCyclePhaseWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CyclePhase | EnumCyclePhaseFieldRefInput<$PrismaModel>
    in?: $Enums.CyclePhase[] | ListEnumCyclePhaseFieldRefInput<$PrismaModel>
    notIn?: $Enums.CyclePhase[] | ListEnumCyclePhaseFieldRefInput<$PrismaModel>
    not?: NestedEnumCyclePhaseWithAggregatesFilter<$PrismaModel> | $Enums.CyclePhase
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCyclePhaseFilter<$PrismaModel>
    _max?: NestedEnumCyclePhaseFilter<$PrismaModel>
  }

  export type EnumIntensityNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Intensity | EnumIntensityFieldRefInput<$PrismaModel> | null
    in?: $Enums.Intensity[] | ListEnumIntensityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Intensity[] | ListEnumIntensityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumIntensityNullableFilter<$PrismaModel> | $Enums.Intensity | null
  }

  export type EnumMuscleZoneNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.MuscleZone | EnumMuscleZoneFieldRefInput<$PrismaModel> | null
    in?: $Enums.MuscleZone[] | ListEnumMuscleZoneFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MuscleZone[] | ListEnumMuscleZoneFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMuscleZoneNullableFilter<$PrismaModel> | $Enums.MuscleZone | null
  }

  export type ExerciseTagListRelationFilter = {
    every?: ExerciseTagWhereInput
    some?: ExerciseTagWhereInput
    none?: ExerciseTagWhereInput
  }

  export type PhaseExerciseListRelationFilter = {
    every?: PhaseExerciseWhereInput
    some?: PhaseExerciseWhereInput
    none?: PhaseExerciseWhereInput
  }

  export type ProgramExerciseListRelationFilter = {
    every?: ProgramExerciseWhereInput
    some?: ProgramExerciseWhereInput
    none?: ProgramExerciseWhereInput
  }

  export type ExerciseTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PhaseExerciseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgramExerciseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExerciseCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    durationMinutes?: SortOrder
    intensity?: SortOrder
    muscleZone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExerciseAvgOrderByAggregateInput = {
    durationMinutes?: SortOrder
  }

  export type ExerciseMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    durationMinutes?: SortOrder
    intensity?: SortOrder
    muscleZone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExerciseMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    durationMinutes?: SortOrder
    intensity?: SortOrder
    muscleZone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExerciseSumOrderByAggregateInput = {
    durationMinutes?: SortOrder
  }

  export type EnumIntensityNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Intensity | EnumIntensityFieldRefInput<$PrismaModel> | null
    in?: $Enums.Intensity[] | ListEnumIntensityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Intensity[] | ListEnumIntensityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumIntensityNullableWithAggregatesFilter<$PrismaModel> | $Enums.Intensity | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumIntensityNullableFilter<$PrismaModel>
    _max?: NestedEnumIntensityNullableFilter<$PrismaModel>
  }

  export type EnumMuscleZoneNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MuscleZone | EnumMuscleZoneFieldRefInput<$PrismaModel> | null
    in?: $Enums.MuscleZone[] | ListEnumMuscleZoneFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MuscleZone[] | ListEnumMuscleZoneFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMuscleZoneNullableWithAggregatesFilter<$PrismaModel> | $Enums.MuscleZone | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumMuscleZoneNullableFilter<$PrismaModel>
    _max?: NestedEnumMuscleZoneNullableFilter<$PrismaModel>
  }

  export type EnumTagTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TagType | EnumTagTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TagType[] | ListEnumTagTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TagType[] | ListEnumTagTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTagTypeFilter<$PrismaModel> | $Enums.TagType
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTagTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TagType | EnumTagTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TagType[] | ListEnumTagTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TagType[] | ListEnumTagTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTagTypeWithAggregatesFilter<$PrismaModel> | $Enums.TagType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTagTypeFilter<$PrismaModel>
    _max?: NestedEnumTagTypeFilter<$PrismaModel>
  }

  export type ExerciseScalarRelationFilter = {
    is?: ExerciseWhereInput
    isNot?: ExerciseWhereInput
  }

  export type TagScalarRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type ExerciseTagExerciseIdTagIdCompoundUniqueInput = {
    exerciseId: string
    tagId: string
  }

  export type ExerciseTagCountOrderByAggregateInput = {
    id?: SortOrder
    exerciseId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
  }

  export type ExerciseTagMaxOrderByAggregateInput = {
    id?: SortOrder
    exerciseId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
  }

  export type ExerciseTagMinOrderByAggregateInput = {
    id?: SortOrder
    exerciseId?: SortOrder
    tagId?: SortOrder
    createdAt?: SortOrder
  }

  export type PhaseExerciseCountOrderByAggregateInput = {
    id?: SortOrder
    phaseName?: SortOrder
    exerciseId?: SortOrder
    createdAt?: SortOrder
  }

  export type PhaseExerciseMaxOrderByAggregateInput = {
    id?: SortOrder
    phaseName?: SortOrder
    exerciseId?: SortOrder
    createdAt?: SortOrder
  }

  export type PhaseExerciseMinOrderByAggregateInput = {
    id?: SortOrder
    phaseName?: SortOrder
    exerciseId?: SortOrder
    createdAt?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgramCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    goal?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProgramMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    goal?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProgramMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    goal?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ProgramScalarRelationFilter = {
    is?: ProgramWhereInput
    isNot?: ProgramWhereInput
  }

  export type ProgramExerciseCountOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    exerciseId?: SortOrder
    day?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type ProgramExerciseAvgOrderByAggregateInput = {
    day?: SortOrder
    order?: SortOrder
  }

  export type ProgramExerciseMaxOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    exerciseId?: SortOrder
    day?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type ProgramExerciseMinOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    exerciseId?: SortOrder
    day?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type ProgramExerciseSumOrderByAggregateInput = {
    day?: SortOrder
    order?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type ProgramNullableScalarRelationFilter = {
    is?: ProgramWhereInput | null
    isNot?: ProgramWhereInput | null
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    date?: SortOrder
    relatedPhase?: SortOrder
    relatedProgramId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    date?: SortOrder
    relatedPhase?: SortOrder
    relatedProgramId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    date?: SortOrder
    relatedPhase?: SortOrder
    relatedProgramId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumExternalProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.ExternalProvider | EnumExternalProviderFieldRefInput<$PrismaModel>
    in?: $Enums.ExternalProvider[] | ListEnumExternalProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExternalProvider[] | ListEnumExternalProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumExternalProviderFilter<$PrismaModel> | $Enums.ExternalProvider
  }

  export type EnumExternalSyncStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ExternalSyncStatus | EnumExternalSyncStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExternalSyncStatus[] | ListEnumExternalSyncStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExternalSyncStatus[] | ListEnumExternalSyncStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExternalSyncStatusFilter<$PrismaModel> | $Enums.ExternalSyncStatus
  }

  export type ExternalSyncCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    entitySynced?: SortOrder
    externalId?: SortOrder
    status?: SortOrder
    message?: SortOrder
    syncedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExternalSyncMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    entitySynced?: SortOrder
    externalId?: SortOrder
    status?: SortOrder
    message?: SortOrder
    syncedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExternalSyncMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    entitySynced?: SortOrder
    externalId?: SortOrder
    status?: SortOrder
    message?: SortOrder
    syncedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumExternalProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExternalProvider | EnumExternalProviderFieldRefInput<$PrismaModel>
    in?: $Enums.ExternalProvider[] | ListEnumExternalProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExternalProvider[] | ListEnumExternalProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumExternalProviderWithAggregatesFilter<$PrismaModel> | $Enums.ExternalProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExternalProviderFilter<$PrismaModel>
    _max?: NestedEnumExternalProviderFilter<$PrismaModel>
  }

  export type EnumExternalSyncStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExternalSyncStatus | EnumExternalSyncStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExternalSyncStatus[] | ListEnumExternalSyncStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExternalSyncStatus[] | ListEnumExternalSyncStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExternalSyncStatusWithAggregatesFilter<$PrismaModel> | $Enums.ExternalSyncStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExternalSyncStatusFilter<$PrismaModel>
    _max?: NestedEnumExternalSyncStatusFilter<$PrismaModel>
  }

  export type EnumJournalCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.JournalCategory | EnumJournalCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.JournalCategory[] | ListEnumJournalCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.JournalCategory[] | ListEnumJournalCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumJournalCategoryFilter<$PrismaModel> | $Enums.JournalCategory
  }

  export type JournalEntryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    category?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JournalEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    category?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JournalEntryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    category?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumJournalCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JournalCategory | EnumJournalCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.JournalCategory[] | ListEnumJournalCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.JournalCategory[] | ListEnumJournalCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumJournalCategoryWithAggregatesFilter<$PrismaModel> | $Enums.JournalCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJournalCategoryFilter<$PrismaModel>
    _max?: NestedEnumJournalCategoryFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    oldData?: SortOrder
    newData?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeFilter<$PrismaModel> | $Enums.EventType
  }

  export type LogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    description?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrder
  }

  export type LogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    description?: SortOrder
    timestamp?: SortOrder
  }

  export type LogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    description?: SortOrder
    timestamp?: SortOrder
  }

  export type EnumEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.EventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventTypeFilter<$PrismaModel>
    _max?: NestedEnumEventTypeFilter<$PrismaModel>
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuthSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    lastSeen?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuthSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    lastSeen?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuthSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
    lastSeen?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMoodTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.MoodType | EnumMoodTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.MoodType[] | ListEnumMoodTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MoodType[] | ListEnumMoodTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMoodTypeNullableFilter<$PrismaModel> | $Enums.MoodType | null
  }

  export type EnumEnergyLevelNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EnergyLevel | EnumEnergyLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.EnergyLevel[] | ListEnumEnergyLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EnergyLevel[] | ListEnumEnergyLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEnergyLevelNullableFilter<$PrismaModel> | $Enums.EnergyLevel | null
  }

  export type EnumPainLevelNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PainLevel | EnumPainLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.PainLevel[] | ListEnumPainLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PainLevel[] | ListEnumPainLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPainLevelNullableFilter<$PrismaModel> | $Enums.PainLevel | null
  }

  export type EnumStressLevelNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.StressLevel | EnumStressLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.StressLevel[] | ListEnumStressLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.StressLevel[] | ListEnumStressLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumStressLevelNullableFilter<$PrismaModel> | $Enums.StressLevel | null
  }

  export type EnumSleepQualityNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SleepQuality | EnumSleepQualityFieldRefInput<$PrismaModel> | null
    in?: $Enums.SleepQuality[] | ListEnumSleepQualityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SleepQuality[] | ListEnumSleepQualityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSleepQualityNullableFilter<$PrismaModel> | $Enums.SleepQuality | null
  }

  export type MoodTrackUserIdDateCompoundUniqueInput = {
    userId: string
    date: Date | string
  }

  export type MoodTrackCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    mood?: SortOrder
    energy?: SortOrder
    pain?: SortOrder
    stress?: SortOrder
    sleepQuality?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MoodTrackMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    mood?: SortOrder
    energy?: SortOrder
    pain?: SortOrder
    stress?: SortOrder
    sleepQuality?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MoodTrackMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    mood?: SortOrder
    energy?: SortOrder
    pain?: SortOrder
    stress?: SortOrder
    sleepQuality?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMoodTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MoodType | EnumMoodTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.MoodType[] | ListEnumMoodTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MoodType[] | ListEnumMoodTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMoodTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.MoodType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumMoodTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumMoodTypeNullableFilter<$PrismaModel>
  }

  export type EnumEnergyLevelNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnergyLevel | EnumEnergyLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.EnergyLevel[] | ListEnumEnergyLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EnergyLevel[] | ListEnumEnergyLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEnergyLevelNullableWithAggregatesFilter<$PrismaModel> | $Enums.EnergyLevel | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEnergyLevelNullableFilter<$PrismaModel>
    _max?: NestedEnumEnergyLevelNullableFilter<$PrismaModel>
  }

  export type EnumPainLevelNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PainLevel | EnumPainLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.PainLevel[] | ListEnumPainLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PainLevel[] | ListEnumPainLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPainLevelNullableWithAggregatesFilter<$PrismaModel> | $Enums.PainLevel | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPainLevelNullableFilter<$PrismaModel>
    _max?: NestedEnumPainLevelNullableFilter<$PrismaModel>
  }

  export type EnumStressLevelNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StressLevel | EnumStressLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.StressLevel[] | ListEnumStressLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.StressLevel[] | ListEnumStressLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumStressLevelNullableWithAggregatesFilter<$PrismaModel> | $Enums.StressLevel | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumStressLevelNullableFilter<$PrismaModel>
    _max?: NestedEnumStressLevelNullableFilter<$PrismaModel>
  }

  export type EnumSleepQualityNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SleepQuality | EnumSleepQualityFieldRefInput<$PrismaModel> | null
    in?: $Enums.SleepQuality[] | ListEnumSleepQualityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SleepQuality[] | ListEnumSleepQualityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSleepQualityNullableWithAggregatesFilter<$PrismaModel> | $Enums.SleepQuality | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSleepQualityNullableFilter<$PrismaModel>
    _max?: NestedEnumSleepQualityNullableFilter<$PrismaModel>
  }

  export type EnumSymptomTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SymptomType | EnumSymptomTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SymptomType[] | ListEnumSymptomTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SymptomType[] | ListEnumSymptomTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSymptomTypeFilter<$PrismaModel> | $Enums.SymptomType
  }

  export type SymptomLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    symptomType?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SymptomLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    symptomType?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SymptomLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    symptomType?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSymptomTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SymptomType | EnumSymptomTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SymptomType[] | ListEnumSymptomTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SymptomType[] | ListEnumSymptomTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSymptomTypeWithAggregatesFilter<$PrismaModel> | $Enums.SymptomType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSymptomTypeFilter<$PrismaModel>
    _max?: NestedEnumSymptomTypeFilter<$PrismaModel>
  }

  export type EnumUnitPreferenceFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitPreference | EnumUnitPreferenceFieldRefInput<$PrismaModel>
    in?: $Enums.UnitPreference[] | ListEnumUnitPreferenceFieldRefInput<$PrismaModel>
    notIn?: $Enums.UnitPreference[] | ListEnumUnitPreferenceFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitPreferenceFilter<$PrismaModel> | $Enums.UnitPreference
  }

  export type UserSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    unitPreference?: SortOrder
    notificationEnabled?: SortOrder
    notificationTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    unitPreference?: SortOrder
    notificationEnabled?: SortOrder
    notificationTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    unitPreference?: SortOrder
    notificationEnabled?: SortOrder
    notificationTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumUnitPreferenceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitPreference | EnumUnitPreferenceFieldRefInput<$PrismaModel>
    in?: $Enums.UnitPreference[] | ListEnumUnitPreferenceFieldRefInput<$PrismaModel>
    notIn?: $Enums.UnitPreference[] | ListEnumUnitPreferenceFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitPreferenceWithAggregatesFilter<$PrismaModel> | $Enums.UnitPreference
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUnitPreferenceFilter<$PrismaModel>
    _max?: NestedEnumUnitPreferenceFilter<$PrismaModel>
  }

  export type EnumReminderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderType | EnumReminderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderType[] | ListEnumReminderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderType[] | ListEnumReminderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderTypeFilter<$PrismaModel> | $Enums.ReminderType
  }

  export type ReminderSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    enabled?: SortOrder
    time?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReminderSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    enabled?: SortOrder
    time?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReminderSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    enabled?: SortOrder
    time?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumReminderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderType | EnumReminderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderType[] | ListEnumReminderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderType[] | ListEnumReminderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReminderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReminderTypeFilter<$PrismaModel>
    _max?: NestedEnumReminderTypeFilter<$PrismaModel>
  }

  export type UserFeatureFlagUserIdFeatureCompoundUniqueInput = {
    userId: string
    feature: string
  }

  export type UserFeatureFlagCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    feature?: SortOrder
    isEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserFeatureFlagMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    feature?: SortOrder
    isEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserFeatureFlagMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    feature?: SortOrder
    isEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumObjectiveTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ObjectiveType | EnumObjectiveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ObjectiveType[] | ListEnumObjectiveTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ObjectiveType[] | ListEnumObjectiveTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumObjectiveTypeFilter<$PrismaModel> | $Enums.ObjectiveType
  }

  export type UserObjectiveCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserObjectiveMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserObjectiveMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumObjectiveTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ObjectiveType | EnumObjectiveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ObjectiveType[] | ListEnumObjectiveTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ObjectiveType[] | ListEnumObjectiveTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumObjectiveTypeWithAggregatesFilter<$PrismaModel> | $Enums.ObjectiveType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumObjectiveTypeFilter<$PrismaModel>
    _max?: NestedEnumObjectiveTypeFilter<$PrismaModel>
  }

  export type EnumChangeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ChangeType | EnumChangeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChangeTypeFilter<$PrismaModel> | $Enums.ChangeType
  }

  export type ProfileChangeLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    changeType?: SortOrder
    details?: SortOrder
    changedAt?: SortOrder
  }

  export type ProfileChangeLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    changeType?: SortOrder
    details?: SortOrder
    changedAt?: SortOrder
  }

  export type ProfileChangeLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    changeType?: SortOrder
    details?: SortOrder
    changedAt?: SortOrder
  }

  export type EnumChangeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChangeType | EnumChangeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChangeTypeWithAggregatesFilter<$PrismaModel> | $Enums.ChangeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChangeTypeFilter<$PrismaModel>
    _max?: NestedEnumChangeTypeFilter<$PrismaModel>
  }

  export type EnumSportFrequencyNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SportFrequency | EnumSportFrequencyFieldRefInput<$PrismaModel> | null
    in?: $Enums.SportFrequency[] | ListEnumSportFrequencyFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SportFrequency[] | ListEnumSportFrequencyFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSportFrequencyNullableFilter<$PrismaModel> | $Enums.SportFrequency | null
  }

  export type EnumProfileTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProfileType | EnumProfileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProfileType[] | ListEnumProfileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProfileType[] | ListEnumProfileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProfileTypeFilter<$PrismaModel> | $Enums.ProfileType
  }

  export type EnumContextTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContextType | EnumContextTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContextType[] | ListEnumContextTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContextType[] | ListEnumContextTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContextTypeFilter<$PrismaModel> | $Enums.ContextType
  }

  export type ProgramListRelationFilter = {
    every?: ProgramWhereInput
    some?: ProgramWhereInput
    none?: ProgramWhereInput
  }

  export type MoodTrackListRelationFilter = {
    every?: MoodTrackWhereInput
    some?: MoodTrackWhereInput
    none?: MoodTrackWhereInput
  }

  export type UserSettingsNullableScalarRelationFilter = {
    is?: UserSettingsWhereInput | null
    isNot?: UserSettingsWhereInput | null
  }

  export type ReminderSettingsListRelationFilter = {
    every?: ReminderSettingsWhereInput
    some?: ReminderSettingsWhereInput
    none?: ReminderSettingsWhereInput
  }

  export type UserFeatureFlagListRelationFilter = {
    every?: UserFeatureFlagWhereInput
    some?: UserFeatureFlagWhereInput
    none?: UserFeatureFlagWhereInput
  }

  export type UserObjectiveListRelationFilter = {
    every?: UserObjectiveWhereInput
    some?: UserObjectiveWhereInput
    none?: UserObjectiveWhereInput
  }

  export type ProfileChangeLogListRelationFilter = {
    every?: ProfileChangeLogWhereInput
    some?: ProfileChangeLogWhereInput
    none?: ProfileChangeLogWhereInput
  }

  export type CycleProfileConfigNullableScalarRelationFilter = {
    is?: CycleProfileConfigWhereInput | null
    isNot?: CycleProfileConfigWhereInput | null
  }

  export type SymptomLogListRelationFilter = {
    every?: SymptomLogWhereInput
    some?: SymptomLogWhereInput
    none?: SymptomLogWhereInput
  }

  export type ExternalSyncListRelationFilter = {
    every?: ExternalSyncWhereInput
    some?: ExternalSyncWhereInput
    none?: ExternalSyncWhereInput
  }

  export type JournalEntryListRelationFilter = {
    every?: JournalEntryWhereInput
    some?: JournalEntryWhereInput
    none?: JournalEntryWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type LogListRelationFilter = {
    every?: LogWhereInput
    some?: LogWhereInput
    none?: LogWhereInput
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type AuthSessionListRelationFilter = {
    every?: AuthSessionWhereInput
    some?: AuthSessionWhereInput
    none?: AuthSessionWhereInput
  }

  export type ProgramOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MoodTrackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReminderSettingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserFeatureFlagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserObjectiveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfileChangeLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SymptomLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExternalSyncOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JournalEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuthSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    birthDate?: SortOrder
    isMenopausal?: SortOrder
    objective?: SortOrder
    sportFrequency?: SortOrder
    profileType?: SortOrder
    contextType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    birthDate?: SortOrder
    isMenopausal?: SortOrder
    objective?: SortOrder
    sportFrequency?: SortOrder
    profileType?: SortOrder
    contextType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    birthDate?: SortOrder
    isMenopausal?: SortOrder
    objective?: SortOrder
    sportFrequency?: SortOrder
    profileType?: SortOrder
    contextType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSportFrequencyNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SportFrequency | EnumSportFrequencyFieldRefInput<$PrismaModel> | null
    in?: $Enums.SportFrequency[] | ListEnumSportFrequencyFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SportFrequency[] | ListEnumSportFrequencyFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSportFrequencyNullableWithAggregatesFilter<$PrismaModel> | $Enums.SportFrequency | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSportFrequencyNullableFilter<$PrismaModel>
    _max?: NestedEnumSportFrequencyNullableFilter<$PrismaModel>
  }

  export type EnumProfileTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProfileType | EnumProfileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProfileType[] | ListEnumProfileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProfileType[] | ListEnumProfileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProfileTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProfileType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProfileTypeFilter<$PrismaModel>
    _max?: NestedEnumProfileTypeFilter<$PrismaModel>
  }

  export type EnumContextTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContextType | EnumContextTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContextType[] | ListEnumContextTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContextType[] | ListEnumContextTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContextTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContextType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContextTypeFilter<$PrismaModel>
    _max?: NestedEnumContextTypeFilter<$PrismaModel>
  }

  export type UserCreateNestedOneWithoutCyclesInput = {
    create?: XOR<UserCreateWithoutCyclesInput, UserUncheckedCreateWithoutCyclesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCyclesInput
    connect?: UserWhereUniqueInput
  }

  export type CycleProviderCreateNestedOneWithoutCyclesInput = {
    create?: XOR<CycleProviderCreateWithoutCyclesInput, CycleProviderUncheckedCreateWithoutCyclesInput>
    connectOrCreate?: CycleProviderCreateOrConnectWithoutCyclesInput
    connect?: CycleProviderWhereUniqueInput
  }

  export type PhaseCreateNestedManyWithoutCycleInput = {
    create?: XOR<PhaseCreateWithoutCycleInput, PhaseUncheckedCreateWithoutCycleInput> | PhaseCreateWithoutCycleInput[] | PhaseUncheckedCreateWithoutCycleInput[]
    connectOrCreate?: PhaseCreateOrConnectWithoutCycleInput | PhaseCreateOrConnectWithoutCycleInput[]
    createMany?: PhaseCreateManyCycleInputEnvelope
    connect?: PhaseWhereUniqueInput | PhaseWhereUniqueInput[]
  }

  export type PhaseUncheckedCreateNestedManyWithoutCycleInput = {
    create?: XOR<PhaseCreateWithoutCycleInput, PhaseUncheckedCreateWithoutCycleInput> | PhaseCreateWithoutCycleInput[] | PhaseUncheckedCreateWithoutCycleInput[]
    connectOrCreate?: PhaseCreateOrConnectWithoutCycleInput | PhaseCreateOrConnectWithoutCycleInput[]
    createMany?: PhaseCreateManyCycleInputEnvelope
    connect?: PhaseWhereUniqueInput | PhaseWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserUpdateOneRequiredWithoutCyclesNestedInput = {
    create?: XOR<UserCreateWithoutCyclesInput, UserUncheckedCreateWithoutCyclesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCyclesInput
    upsert?: UserUpsertWithoutCyclesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCyclesInput, UserUpdateWithoutCyclesInput>, UserUncheckedUpdateWithoutCyclesInput>
  }

  export type CycleProviderUpdateOneWithoutCyclesNestedInput = {
    create?: XOR<CycleProviderCreateWithoutCyclesInput, CycleProviderUncheckedCreateWithoutCyclesInput>
    connectOrCreate?: CycleProviderCreateOrConnectWithoutCyclesInput
    upsert?: CycleProviderUpsertWithoutCyclesInput
    disconnect?: CycleProviderWhereInput | boolean
    delete?: CycleProviderWhereInput | boolean
    connect?: CycleProviderWhereUniqueInput
    update?: XOR<XOR<CycleProviderUpdateToOneWithWhereWithoutCyclesInput, CycleProviderUpdateWithoutCyclesInput>, CycleProviderUncheckedUpdateWithoutCyclesInput>
  }

  export type PhaseUpdateManyWithoutCycleNestedInput = {
    create?: XOR<PhaseCreateWithoutCycleInput, PhaseUncheckedCreateWithoutCycleInput> | PhaseCreateWithoutCycleInput[] | PhaseUncheckedCreateWithoutCycleInput[]
    connectOrCreate?: PhaseCreateOrConnectWithoutCycleInput | PhaseCreateOrConnectWithoutCycleInput[]
    upsert?: PhaseUpsertWithWhereUniqueWithoutCycleInput | PhaseUpsertWithWhereUniqueWithoutCycleInput[]
    createMany?: PhaseCreateManyCycleInputEnvelope
    set?: PhaseWhereUniqueInput | PhaseWhereUniqueInput[]
    disconnect?: PhaseWhereUniqueInput | PhaseWhereUniqueInput[]
    delete?: PhaseWhereUniqueInput | PhaseWhereUniqueInput[]
    connect?: PhaseWhereUniqueInput | PhaseWhereUniqueInput[]
    update?: PhaseUpdateWithWhereUniqueWithoutCycleInput | PhaseUpdateWithWhereUniqueWithoutCycleInput[]
    updateMany?: PhaseUpdateManyWithWhereWithoutCycleInput | PhaseUpdateManyWithWhereWithoutCycleInput[]
    deleteMany?: PhaseScalarWhereInput | PhaseScalarWhereInput[]
  }

  export type PhaseUncheckedUpdateManyWithoutCycleNestedInput = {
    create?: XOR<PhaseCreateWithoutCycleInput, PhaseUncheckedCreateWithoutCycleInput> | PhaseCreateWithoutCycleInput[] | PhaseUncheckedCreateWithoutCycleInput[]
    connectOrCreate?: PhaseCreateOrConnectWithoutCycleInput | PhaseCreateOrConnectWithoutCycleInput[]
    upsert?: PhaseUpsertWithWhereUniqueWithoutCycleInput | PhaseUpsertWithWhereUniqueWithoutCycleInput[]
    createMany?: PhaseCreateManyCycleInputEnvelope
    set?: PhaseWhereUniqueInput | PhaseWhereUniqueInput[]
    disconnect?: PhaseWhereUniqueInput | PhaseWhereUniqueInput[]
    delete?: PhaseWhereUniqueInput | PhaseWhereUniqueInput[]
    connect?: PhaseWhereUniqueInput | PhaseWhereUniqueInput[]
    update?: PhaseUpdateWithWhereUniqueWithoutCycleInput | PhaseUpdateWithWhereUniqueWithoutCycleInput[]
    updateMany?: PhaseUpdateManyWithWhereWithoutCycleInput | PhaseUpdateManyWithWhereWithoutCycleInput[]
    deleteMany?: PhaseScalarWhereInput | PhaseScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCycleProfileConfigInput = {
    create?: XOR<UserCreateWithoutCycleProfileConfigInput, UserUncheckedCreateWithoutCycleProfileConfigInput>
    connectOrCreate?: UserCreateOrConnectWithoutCycleProfileConfigInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCycleProfileConfigNestedInput = {
    create?: XOR<UserCreateWithoutCycleProfileConfigInput, UserUncheckedCreateWithoutCycleProfileConfigInput>
    connectOrCreate?: UserCreateOrConnectWithoutCycleProfileConfigInput
    upsert?: UserUpsertWithoutCycleProfileConfigInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCycleProfileConfigInput, UserUpdateWithoutCycleProfileConfigInput>, UserUncheckedUpdateWithoutCycleProfileConfigInput>
  }

  export type CycleCreateNestedManyWithoutProviderInput = {
    create?: XOR<CycleCreateWithoutProviderInput, CycleUncheckedCreateWithoutProviderInput> | CycleCreateWithoutProviderInput[] | CycleUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: CycleCreateOrConnectWithoutProviderInput | CycleCreateOrConnectWithoutProviderInput[]
    createMany?: CycleCreateManyProviderInputEnvelope
    connect?: CycleWhereUniqueInput | CycleWhereUniqueInput[]
  }

  export type CycleUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<CycleCreateWithoutProviderInput, CycleUncheckedCreateWithoutProviderInput> | CycleCreateWithoutProviderInput[] | CycleUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: CycleCreateOrConnectWithoutProviderInput | CycleCreateOrConnectWithoutProviderInput[]
    createMany?: CycleCreateManyProviderInputEnvelope
    connect?: CycleWhereUniqueInput | CycleWhereUniqueInput[]
  }

  export type CycleUpdateManyWithoutProviderNestedInput = {
    create?: XOR<CycleCreateWithoutProviderInput, CycleUncheckedCreateWithoutProviderInput> | CycleCreateWithoutProviderInput[] | CycleUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: CycleCreateOrConnectWithoutProviderInput | CycleCreateOrConnectWithoutProviderInput[]
    upsert?: CycleUpsertWithWhereUniqueWithoutProviderInput | CycleUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: CycleCreateManyProviderInputEnvelope
    set?: CycleWhereUniqueInput | CycleWhereUniqueInput[]
    disconnect?: CycleWhereUniqueInput | CycleWhereUniqueInput[]
    delete?: CycleWhereUniqueInput | CycleWhereUniqueInput[]
    connect?: CycleWhereUniqueInput | CycleWhereUniqueInput[]
    update?: CycleUpdateWithWhereUniqueWithoutProviderInput | CycleUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: CycleUpdateManyWithWhereWithoutProviderInput | CycleUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: CycleScalarWhereInput | CycleScalarWhereInput[]
  }

  export type CycleUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<CycleCreateWithoutProviderInput, CycleUncheckedCreateWithoutProviderInput> | CycleCreateWithoutProviderInput[] | CycleUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: CycleCreateOrConnectWithoutProviderInput | CycleCreateOrConnectWithoutProviderInput[]
    upsert?: CycleUpsertWithWhereUniqueWithoutProviderInput | CycleUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: CycleCreateManyProviderInputEnvelope
    set?: CycleWhereUniqueInput | CycleWhereUniqueInput[]
    disconnect?: CycleWhereUniqueInput | CycleWhereUniqueInput[]
    delete?: CycleWhereUniqueInput | CycleWhereUniqueInput[]
    connect?: CycleWhereUniqueInput | CycleWhereUniqueInput[]
    update?: CycleUpdateWithWhereUniqueWithoutProviderInput | CycleUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: CycleUpdateManyWithWhereWithoutProviderInput | CycleUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: CycleScalarWhereInput | CycleScalarWhereInput[]
  }

  export type CycleCreateNestedOneWithoutPhasesInput = {
    create?: XOR<CycleCreateWithoutPhasesInput, CycleUncheckedCreateWithoutPhasesInput>
    connectOrCreate?: CycleCreateOrConnectWithoutPhasesInput
    connect?: CycleWhereUniqueInput
  }

  export type EnumCyclePhaseFieldUpdateOperationsInput = {
    set?: $Enums.CyclePhase
  }

  export type CycleUpdateOneRequiredWithoutPhasesNestedInput = {
    create?: XOR<CycleCreateWithoutPhasesInput, CycleUncheckedCreateWithoutPhasesInput>
    connectOrCreate?: CycleCreateOrConnectWithoutPhasesInput
    upsert?: CycleUpsertWithoutPhasesInput
    connect?: CycleWhereUniqueInput
    update?: XOR<XOR<CycleUpdateToOneWithWhereWithoutPhasesInput, CycleUpdateWithoutPhasesInput>, CycleUncheckedUpdateWithoutPhasesInput>
  }

  export type ExerciseTagCreateNestedManyWithoutExerciseInput = {
    create?: XOR<ExerciseTagCreateWithoutExerciseInput, ExerciseTagUncheckedCreateWithoutExerciseInput> | ExerciseTagCreateWithoutExerciseInput[] | ExerciseTagUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: ExerciseTagCreateOrConnectWithoutExerciseInput | ExerciseTagCreateOrConnectWithoutExerciseInput[]
    createMany?: ExerciseTagCreateManyExerciseInputEnvelope
    connect?: ExerciseTagWhereUniqueInput | ExerciseTagWhereUniqueInput[]
  }

  export type PhaseExerciseCreateNestedManyWithoutExerciseInput = {
    create?: XOR<PhaseExerciseCreateWithoutExerciseInput, PhaseExerciseUncheckedCreateWithoutExerciseInput> | PhaseExerciseCreateWithoutExerciseInput[] | PhaseExerciseUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: PhaseExerciseCreateOrConnectWithoutExerciseInput | PhaseExerciseCreateOrConnectWithoutExerciseInput[]
    createMany?: PhaseExerciseCreateManyExerciseInputEnvelope
    connect?: PhaseExerciseWhereUniqueInput | PhaseExerciseWhereUniqueInput[]
  }

  export type ProgramExerciseCreateNestedManyWithoutExerciseInput = {
    create?: XOR<ProgramExerciseCreateWithoutExerciseInput, ProgramExerciseUncheckedCreateWithoutExerciseInput> | ProgramExerciseCreateWithoutExerciseInput[] | ProgramExerciseUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: ProgramExerciseCreateOrConnectWithoutExerciseInput | ProgramExerciseCreateOrConnectWithoutExerciseInput[]
    createMany?: ProgramExerciseCreateManyExerciseInputEnvelope
    connect?: ProgramExerciseWhereUniqueInput | ProgramExerciseWhereUniqueInput[]
  }

  export type ExerciseTagUncheckedCreateNestedManyWithoutExerciseInput = {
    create?: XOR<ExerciseTagCreateWithoutExerciseInput, ExerciseTagUncheckedCreateWithoutExerciseInput> | ExerciseTagCreateWithoutExerciseInput[] | ExerciseTagUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: ExerciseTagCreateOrConnectWithoutExerciseInput | ExerciseTagCreateOrConnectWithoutExerciseInput[]
    createMany?: ExerciseTagCreateManyExerciseInputEnvelope
    connect?: ExerciseTagWhereUniqueInput | ExerciseTagWhereUniqueInput[]
  }

  export type PhaseExerciseUncheckedCreateNestedManyWithoutExerciseInput = {
    create?: XOR<PhaseExerciseCreateWithoutExerciseInput, PhaseExerciseUncheckedCreateWithoutExerciseInput> | PhaseExerciseCreateWithoutExerciseInput[] | PhaseExerciseUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: PhaseExerciseCreateOrConnectWithoutExerciseInput | PhaseExerciseCreateOrConnectWithoutExerciseInput[]
    createMany?: PhaseExerciseCreateManyExerciseInputEnvelope
    connect?: PhaseExerciseWhereUniqueInput | PhaseExerciseWhereUniqueInput[]
  }

  export type ProgramExerciseUncheckedCreateNestedManyWithoutExerciseInput = {
    create?: XOR<ProgramExerciseCreateWithoutExerciseInput, ProgramExerciseUncheckedCreateWithoutExerciseInput> | ProgramExerciseCreateWithoutExerciseInput[] | ProgramExerciseUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: ProgramExerciseCreateOrConnectWithoutExerciseInput | ProgramExerciseCreateOrConnectWithoutExerciseInput[]
    createMany?: ProgramExerciseCreateManyExerciseInputEnvelope
    connect?: ProgramExerciseWhereUniqueInput | ProgramExerciseWhereUniqueInput[]
  }

  export type NullableEnumIntensityFieldUpdateOperationsInput = {
    set?: $Enums.Intensity | null
  }

  export type NullableEnumMuscleZoneFieldUpdateOperationsInput = {
    set?: $Enums.MuscleZone | null
  }

  export type ExerciseTagUpdateManyWithoutExerciseNestedInput = {
    create?: XOR<ExerciseTagCreateWithoutExerciseInput, ExerciseTagUncheckedCreateWithoutExerciseInput> | ExerciseTagCreateWithoutExerciseInput[] | ExerciseTagUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: ExerciseTagCreateOrConnectWithoutExerciseInput | ExerciseTagCreateOrConnectWithoutExerciseInput[]
    upsert?: ExerciseTagUpsertWithWhereUniqueWithoutExerciseInput | ExerciseTagUpsertWithWhereUniqueWithoutExerciseInput[]
    createMany?: ExerciseTagCreateManyExerciseInputEnvelope
    set?: ExerciseTagWhereUniqueInput | ExerciseTagWhereUniqueInput[]
    disconnect?: ExerciseTagWhereUniqueInput | ExerciseTagWhereUniqueInput[]
    delete?: ExerciseTagWhereUniqueInput | ExerciseTagWhereUniqueInput[]
    connect?: ExerciseTagWhereUniqueInput | ExerciseTagWhereUniqueInput[]
    update?: ExerciseTagUpdateWithWhereUniqueWithoutExerciseInput | ExerciseTagUpdateWithWhereUniqueWithoutExerciseInput[]
    updateMany?: ExerciseTagUpdateManyWithWhereWithoutExerciseInput | ExerciseTagUpdateManyWithWhereWithoutExerciseInput[]
    deleteMany?: ExerciseTagScalarWhereInput | ExerciseTagScalarWhereInput[]
  }

  export type PhaseExerciseUpdateManyWithoutExerciseNestedInput = {
    create?: XOR<PhaseExerciseCreateWithoutExerciseInput, PhaseExerciseUncheckedCreateWithoutExerciseInput> | PhaseExerciseCreateWithoutExerciseInput[] | PhaseExerciseUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: PhaseExerciseCreateOrConnectWithoutExerciseInput | PhaseExerciseCreateOrConnectWithoutExerciseInput[]
    upsert?: PhaseExerciseUpsertWithWhereUniqueWithoutExerciseInput | PhaseExerciseUpsertWithWhereUniqueWithoutExerciseInput[]
    createMany?: PhaseExerciseCreateManyExerciseInputEnvelope
    set?: PhaseExerciseWhereUniqueInput | PhaseExerciseWhereUniqueInput[]
    disconnect?: PhaseExerciseWhereUniqueInput | PhaseExerciseWhereUniqueInput[]
    delete?: PhaseExerciseWhereUniqueInput | PhaseExerciseWhereUniqueInput[]
    connect?: PhaseExerciseWhereUniqueInput | PhaseExerciseWhereUniqueInput[]
    update?: PhaseExerciseUpdateWithWhereUniqueWithoutExerciseInput | PhaseExerciseUpdateWithWhereUniqueWithoutExerciseInput[]
    updateMany?: PhaseExerciseUpdateManyWithWhereWithoutExerciseInput | PhaseExerciseUpdateManyWithWhereWithoutExerciseInput[]
    deleteMany?: PhaseExerciseScalarWhereInput | PhaseExerciseScalarWhereInput[]
  }

  export type ProgramExerciseUpdateManyWithoutExerciseNestedInput = {
    create?: XOR<ProgramExerciseCreateWithoutExerciseInput, ProgramExerciseUncheckedCreateWithoutExerciseInput> | ProgramExerciseCreateWithoutExerciseInput[] | ProgramExerciseUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: ProgramExerciseCreateOrConnectWithoutExerciseInput | ProgramExerciseCreateOrConnectWithoutExerciseInput[]
    upsert?: ProgramExerciseUpsertWithWhereUniqueWithoutExerciseInput | ProgramExerciseUpsertWithWhereUniqueWithoutExerciseInput[]
    createMany?: ProgramExerciseCreateManyExerciseInputEnvelope
    set?: ProgramExerciseWhereUniqueInput | ProgramExerciseWhereUniqueInput[]
    disconnect?: ProgramExerciseWhereUniqueInput | ProgramExerciseWhereUniqueInput[]
    delete?: ProgramExerciseWhereUniqueInput | ProgramExerciseWhereUniqueInput[]
    connect?: ProgramExerciseWhereUniqueInput | ProgramExerciseWhereUniqueInput[]
    update?: ProgramExerciseUpdateWithWhereUniqueWithoutExerciseInput | ProgramExerciseUpdateWithWhereUniqueWithoutExerciseInput[]
    updateMany?: ProgramExerciseUpdateManyWithWhereWithoutExerciseInput | ProgramExerciseUpdateManyWithWhereWithoutExerciseInput[]
    deleteMany?: ProgramExerciseScalarWhereInput | ProgramExerciseScalarWhereInput[]
  }

  export type ExerciseTagUncheckedUpdateManyWithoutExerciseNestedInput = {
    create?: XOR<ExerciseTagCreateWithoutExerciseInput, ExerciseTagUncheckedCreateWithoutExerciseInput> | ExerciseTagCreateWithoutExerciseInput[] | ExerciseTagUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: ExerciseTagCreateOrConnectWithoutExerciseInput | ExerciseTagCreateOrConnectWithoutExerciseInput[]
    upsert?: ExerciseTagUpsertWithWhereUniqueWithoutExerciseInput | ExerciseTagUpsertWithWhereUniqueWithoutExerciseInput[]
    createMany?: ExerciseTagCreateManyExerciseInputEnvelope
    set?: ExerciseTagWhereUniqueInput | ExerciseTagWhereUniqueInput[]
    disconnect?: ExerciseTagWhereUniqueInput | ExerciseTagWhereUniqueInput[]
    delete?: ExerciseTagWhereUniqueInput | ExerciseTagWhereUniqueInput[]
    connect?: ExerciseTagWhereUniqueInput | ExerciseTagWhereUniqueInput[]
    update?: ExerciseTagUpdateWithWhereUniqueWithoutExerciseInput | ExerciseTagUpdateWithWhereUniqueWithoutExerciseInput[]
    updateMany?: ExerciseTagUpdateManyWithWhereWithoutExerciseInput | ExerciseTagUpdateManyWithWhereWithoutExerciseInput[]
    deleteMany?: ExerciseTagScalarWhereInput | ExerciseTagScalarWhereInput[]
  }

  export type PhaseExerciseUncheckedUpdateManyWithoutExerciseNestedInput = {
    create?: XOR<PhaseExerciseCreateWithoutExerciseInput, PhaseExerciseUncheckedCreateWithoutExerciseInput> | PhaseExerciseCreateWithoutExerciseInput[] | PhaseExerciseUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: PhaseExerciseCreateOrConnectWithoutExerciseInput | PhaseExerciseCreateOrConnectWithoutExerciseInput[]
    upsert?: PhaseExerciseUpsertWithWhereUniqueWithoutExerciseInput | PhaseExerciseUpsertWithWhereUniqueWithoutExerciseInput[]
    createMany?: PhaseExerciseCreateManyExerciseInputEnvelope
    set?: PhaseExerciseWhereUniqueInput | PhaseExerciseWhereUniqueInput[]
    disconnect?: PhaseExerciseWhereUniqueInput | PhaseExerciseWhereUniqueInput[]
    delete?: PhaseExerciseWhereUniqueInput | PhaseExerciseWhereUniqueInput[]
    connect?: PhaseExerciseWhereUniqueInput | PhaseExerciseWhereUniqueInput[]
    update?: PhaseExerciseUpdateWithWhereUniqueWithoutExerciseInput | PhaseExerciseUpdateWithWhereUniqueWithoutExerciseInput[]
    updateMany?: PhaseExerciseUpdateManyWithWhereWithoutExerciseInput | PhaseExerciseUpdateManyWithWhereWithoutExerciseInput[]
    deleteMany?: PhaseExerciseScalarWhereInput | PhaseExerciseScalarWhereInput[]
  }

  export type ProgramExerciseUncheckedUpdateManyWithoutExerciseNestedInput = {
    create?: XOR<ProgramExerciseCreateWithoutExerciseInput, ProgramExerciseUncheckedCreateWithoutExerciseInput> | ProgramExerciseCreateWithoutExerciseInput[] | ProgramExerciseUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: ProgramExerciseCreateOrConnectWithoutExerciseInput | ProgramExerciseCreateOrConnectWithoutExerciseInput[]
    upsert?: ProgramExerciseUpsertWithWhereUniqueWithoutExerciseInput | ProgramExerciseUpsertWithWhereUniqueWithoutExerciseInput[]
    createMany?: ProgramExerciseCreateManyExerciseInputEnvelope
    set?: ProgramExerciseWhereUniqueInput | ProgramExerciseWhereUniqueInput[]
    disconnect?: ProgramExerciseWhereUniqueInput | ProgramExerciseWhereUniqueInput[]
    delete?: ProgramExerciseWhereUniqueInput | ProgramExerciseWhereUniqueInput[]
    connect?: ProgramExerciseWhereUniqueInput | ProgramExerciseWhereUniqueInput[]
    update?: ProgramExerciseUpdateWithWhereUniqueWithoutExerciseInput | ProgramExerciseUpdateWithWhereUniqueWithoutExerciseInput[]
    updateMany?: ProgramExerciseUpdateManyWithWhereWithoutExerciseInput | ProgramExerciseUpdateManyWithWhereWithoutExerciseInput[]
    deleteMany?: ProgramExerciseScalarWhereInput | ProgramExerciseScalarWhereInput[]
  }

  export type ExerciseTagCreateNestedManyWithoutTagInput = {
    create?: XOR<ExerciseTagCreateWithoutTagInput, ExerciseTagUncheckedCreateWithoutTagInput> | ExerciseTagCreateWithoutTagInput[] | ExerciseTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ExerciseTagCreateOrConnectWithoutTagInput | ExerciseTagCreateOrConnectWithoutTagInput[]
    createMany?: ExerciseTagCreateManyTagInputEnvelope
    connect?: ExerciseTagWhereUniqueInput | ExerciseTagWhereUniqueInput[]
  }

  export type ExerciseTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<ExerciseTagCreateWithoutTagInput, ExerciseTagUncheckedCreateWithoutTagInput> | ExerciseTagCreateWithoutTagInput[] | ExerciseTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ExerciseTagCreateOrConnectWithoutTagInput | ExerciseTagCreateOrConnectWithoutTagInput[]
    createMany?: ExerciseTagCreateManyTagInputEnvelope
    connect?: ExerciseTagWhereUniqueInput | ExerciseTagWhereUniqueInput[]
  }

  export type EnumTagTypeFieldUpdateOperationsInput = {
    set?: $Enums.TagType
  }

  export type ExerciseTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<ExerciseTagCreateWithoutTagInput, ExerciseTagUncheckedCreateWithoutTagInput> | ExerciseTagCreateWithoutTagInput[] | ExerciseTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ExerciseTagCreateOrConnectWithoutTagInput | ExerciseTagCreateOrConnectWithoutTagInput[]
    upsert?: ExerciseTagUpsertWithWhereUniqueWithoutTagInput | ExerciseTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: ExerciseTagCreateManyTagInputEnvelope
    set?: ExerciseTagWhereUniqueInput | ExerciseTagWhereUniqueInput[]
    disconnect?: ExerciseTagWhereUniqueInput | ExerciseTagWhereUniqueInput[]
    delete?: ExerciseTagWhereUniqueInput | ExerciseTagWhereUniqueInput[]
    connect?: ExerciseTagWhereUniqueInput | ExerciseTagWhereUniqueInput[]
    update?: ExerciseTagUpdateWithWhereUniqueWithoutTagInput | ExerciseTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: ExerciseTagUpdateManyWithWhereWithoutTagInput | ExerciseTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: ExerciseTagScalarWhereInput | ExerciseTagScalarWhereInput[]
  }

  export type ExerciseTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<ExerciseTagCreateWithoutTagInput, ExerciseTagUncheckedCreateWithoutTagInput> | ExerciseTagCreateWithoutTagInput[] | ExerciseTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ExerciseTagCreateOrConnectWithoutTagInput | ExerciseTagCreateOrConnectWithoutTagInput[]
    upsert?: ExerciseTagUpsertWithWhereUniqueWithoutTagInput | ExerciseTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: ExerciseTagCreateManyTagInputEnvelope
    set?: ExerciseTagWhereUniqueInput | ExerciseTagWhereUniqueInput[]
    disconnect?: ExerciseTagWhereUniqueInput | ExerciseTagWhereUniqueInput[]
    delete?: ExerciseTagWhereUniqueInput | ExerciseTagWhereUniqueInput[]
    connect?: ExerciseTagWhereUniqueInput | ExerciseTagWhereUniqueInput[]
    update?: ExerciseTagUpdateWithWhereUniqueWithoutTagInput | ExerciseTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: ExerciseTagUpdateManyWithWhereWithoutTagInput | ExerciseTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: ExerciseTagScalarWhereInput | ExerciseTagScalarWhereInput[]
  }

  export type ExerciseCreateNestedOneWithoutExerciseTagsInput = {
    create?: XOR<ExerciseCreateWithoutExerciseTagsInput, ExerciseUncheckedCreateWithoutExerciseTagsInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutExerciseTagsInput
    connect?: ExerciseWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutExerciseTagsInput = {
    create?: XOR<TagCreateWithoutExerciseTagsInput, TagUncheckedCreateWithoutExerciseTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutExerciseTagsInput
    connect?: TagWhereUniqueInput
  }

  export type ExerciseUpdateOneRequiredWithoutExerciseTagsNestedInput = {
    create?: XOR<ExerciseCreateWithoutExerciseTagsInput, ExerciseUncheckedCreateWithoutExerciseTagsInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutExerciseTagsInput
    upsert?: ExerciseUpsertWithoutExerciseTagsInput
    connect?: ExerciseWhereUniqueInput
    update?: XOR<XOR<ExerciseUpdateToOneWithWhereWithoutExerciseTagsInput, ExerciseUpdateWithoutExerciseTagsInput>, ExerciseUncheckedUpdateWithoutExerciseTagsInput>
  }

  export type TagUpdateOneRequiredWithoutExerciseTagsNestedInput = {
    create?: XOR<TagCreateWithoutExerciseTagsInput, TagUncheckedCreateWithoutExerciseTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutExerciseTagsInput
    upsert?: TagUpsertWithoutExerciseTagsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutExerciseTagsInput, TagUpdateWithoutExerciseTagsInput>, TagUncheckedUpdateWithoutExerciseTagsInput>
  }

  export type ExerciseCreateNestedOneWithoutPhaseExercisesInput = {
    create?: XOR<ExerciseCreateWithoutPhaseExercisesInput, ExerciseUncheckedCreateWithoutPhaseExercisesInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutPhaseExercisesInput
    connect?: ExerciseWhereUniqueInput
  }

  export type ExerciseUpdateOneRequiredWithoutPhaseExercisesNestedInput = {
    create?: XOR<ExerciseCreateWithoutPhaseExercisesInput, ExerciseUncheckedCreateWithoutPhaseExercisesInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutPhaseExercisesInput
    upsert?: ExerciseUpsertWithoutPhaseExercisesInput
    connect?: ExerciseWhereUniqueInput
    update?: XOR<XOR<ExerciseUpdateToOneWithWhereWithoutPhaseExercisesInput, ExerciseUpdateWithoutPhaseExercisesInput>, ExerciseUncheckedUpdateWithoutPhaseExercisesInput>
  }

  export type UserCreateNestedOneWithoutProgramsInput = {
    create?: XOR<UserCreateWithoutProgramsInput, UserUncheckedCreateWithoutProgramsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProgramsInput
    connect?: UserWhereUniqueInput
  }

  export type ProgramExerciseCreateNestedManyWithoutProgramInput = {
    create?: XOR<ProgramExerciseCreateWithoutProgramInput, ProgramExerciseUncheckedCreateWithoutProgramInput> | ProgramExerciseCreateWithoutProgramInput[] | ProgramExerciseUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProgramExerciseCreateOrConnectWithoutProgramInput | ProgramExerciseCreateOrConnectWithoutProgramInput[]
    createMany?: ProgramExerciseCreateManyProgramInputEnvelope
    connect?: ProgramExerciseWhereUniqueInput | ProgramExerciseWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutRelatedProgramInput = {
    create?: XOR<NotificationCreateWithoutRelatedProgramInput, NotificationUncheckedCreateWithoutRelatedProgramInput> | NotificationCreateWithoutRelatedProgramInput[] | NotificationUncheckedCreateWithoutRelatedProgramInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRelatedProgramInput | NotificationCreateOrConnectWithoutRelatedProgramInput[]
    createMany?: NotificationCreateManyRelatedProgramInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ProgramExerciseUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<ProgramExerciseCreateWithoutProgramInput, ProgramExerciseUncheckedCreateWithoutProgramInput> | ProgramExerciseCreateWithoutProgramInput[] | ProgramExerciseUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProgramExerciseCreateOrConnectWithoutProgramInput | ProgramExerciseCreateOrConnectWithoutProgramInput[]
    createMany?: ProgramExerciseCreateManyProgramInputEnvelope
    connect?: ProgramExerciseWhereUniqueInput | ProgramExerciseWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutRelatedProgramInput = {
    create?: XOR<NotificationCreateWithoutRelatedProgramInput, NotificationUncheckedCreateWithoutRelatedProgramInput> | NotificationCreateWithoutRelatedProgramInput[] | NotificationUncheckedCreateWithoutRelatedProgramInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRelatedProgramInput | NotificationCreateOrConnectWithoutRelatedProgramInput[]
    createMany?: NotificationCreateManyRelatedProgramInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutProgramsNestedInput = {
    create?: XOR<UserCreateWithoutProgramsInput, UserUncheckedCreateWithoutProgramsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProgramsInput
    upsert?: UserUpsertWithoutProgramsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProgramsInput, UserUpdateWithoutProgramsInput>, UserUncheckedUpdateWithoutProgramsInput>
  }

  export type ProgramExerciseUpdateManyWithoutProgramNestedInput = {
    create?: XOR<ProgramExerciseCreateWithoutProgramInput, ProgramExerciseUncheckedCreateWithoutProgramInput> | ProgramExerciseCreateWithoutProgramInput[] | ProgramExerciseUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProgramExerciseCreateOrConnectWithoutProgramInput | ProgramExerciseCreateOrConnectWithoutProgramInput[]
    upsert?: ProgramExerciseUpsertWithWhereUniqueWithoutProgramInput | ProgramExerciseUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: ProgramExerciseCreateManyProgramInputEnvelope
    set?: ProgramExerciseWhereUniqueInput | ProgramExerciseWhereUniqueInput[]
    disconnect?: ProgramExerciseWhereUniqueInput | ProgramExerciseWhereUniqueInput[]
    delete?: ProgramExerciseWhereUniqueInput | ProgramExerciseWhereUniqueInput[]
    connect?: ProgramExerciseWhereUniqueInput | ProgramExerciseWhereUniqueInput[]
    update?: ProgramExerciseUpdateWithWhereUniqueWithoutProgramInput | ProgramExerciseUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: ProgramExerciseUpdateManyWithWhereWithoutProgramInput | ProgramExerciseUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: ProgramExerciseScalarWhereInput | ProgramExerciseScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutRelatedProgramNestedInput = {
    create?: XOR<NotificationCreateWithoutRelatedProgramInput, NotificationUncheckedCreateWithoutRelatedProgramInput> | NotificationCreateWithoutRelatedProgramInput[] | NotificationUncheckedCreateWithoutRelatedProgramInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRelatedProgramInput | NotificationCreateOrConnectWithoutRelatedProgramInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutRelatedProgramInput | NotificationUpsertWithWhereUniqueWithoutRelatedProgramInput[]
    createMany?: NotificationCreateManyRelatedProgramInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutRelatedProgramInput | NotificationUpdateWithWhereUniqueWithoutRelatedProgramInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutRelatedProgramInput | NotificationUpdateManyWithWhereWithoutRelatedProgramInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ProgramExerciseUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<ProgramExerciseCreateWithoutProgramInput, ProgramExerciseUncheckedCreateWithoutProgramInput> | ProgramExerciseCreateWithoutProgramInput[] | ProgramExerciseUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProgramExerciseCreateOrConnectWithoutProgramInput | ProgramExerciseCreateOrConnectWithoutProgramInput[]
    upsert?: ProgramExerciseUpsertWithWhereUniqueWithoutProgramInput | ProgramExerciseUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: ProgramExerciseCreateManyProgramInputEnvelope
    set?: ProgramExerciseWhereUniqueInput | ProgramExerciseWhereUniqueInput[]
    disconnect?: ProgramExerciseWhereUniqueInput | ProgramExerciseWhereUniqueInput[]
    delete?: ProgramExerciseWhereUniqueInput | ProgramExerciseWhereUniqueInput[]
    connect?: ProgramExerciseWhereUniqueInput | ProgramExerciseWhereUniqueInput[]
    update?: ProgramExerciseUpdateWithWhereUniqueWithoutProgramInput | ProgramExerciseUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: ProgramExerciseUpdateManyWithWhereWithoutProgramInput | ProgramExerciseUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: ProgramExerciseScalarWhereInput | ProgramExerciseScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutRelatedProgramNestedInput = {
    create?: XOR<NotificationCreateWithoutRelatedProgramInput, NotificationUncheckedCreateWithoutRelatedProgramInput> | NotificationCreateWithoutRelatedProgramInput[] | NotificationUncheckedCreateWithoutRelatedProgramInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRelatedProgramInput | NotificationCreateOrConnectWithoutRelatedProgramInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutRelatedProgramInput | NotificationUpsertWithWhereUniqueWithoutRelatedProgramInput[]
    createMany?: NotificationCreateManyRelatedProgramInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutRelatedProgramInput | NotificationUpdateWithWhereUniqueWithoutRelatedProgramInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutRelatedProgramInput | NotificationUpdateManyWithWhereWithoutRelatedProgramInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ProgramCreateNestedOneWithoutProgramExercisesInput = {
    create?: XOR<ProgramCreateWithoutProgramExercisesInput, ProgramUncheckedCreateWithoutProgramExercisesInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutProgramExercisesInput
    connect?: ProgramWhereUniqueInput
  }

  export type ExerciseCreateNestedOneWithoutProgramExercisesInput = {
    create?: XOR<ExerciseCreateWithoutProgramExercisesInput, ExerciseUncheckedCreateWithoutProgramExercisesInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutProgramExercisesInput
    connect?: ExerciseWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProgramUpdateOneRequiredWithoutProgramExercisesNestedInput = {
    create?: XOR<ProgramCreateWithoutProgramExercisesInput, ProgramUncheckedCreateWithoutProgramExercisesInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutProgramExercisesInput
    upsert?: ProgramUpsertWithoutProgramExercisesInput
    connect?: ProgramWhereUniqueInput
    update?: XOR<XOR<ProgramUpdateToOneWithWhereWithoutProgramExercisesInput, ProgramUpdateWithoutProgramExercisesInput>, ProgramUncheckedUpdateWithoutProgramExercisesInput>
  }

  export type ExerciseUpdateOneRequiredWithoutProgramExercisesNestedInput = {
    create?: XOR<ExerciseCreateWithoutProgramExercisesInput, ExerciseUncheckedCreateWithoutProgramExercisesInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutProgramExercisesInput
    upsert?: ExerciseUpsertWithoutProgramExercisesInput
    connect?: ExerciseWhereUniqueInput
    update?: XOR<XOR<ExerciseUpdateToOneWithWhereWithoutProgramExercisesInput, ExerciseUpdateWithoutProgramExercisesInput>, ExerciseUncheckedUpdateWithoutProgramExercisesInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type ProgramCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<ProgramCreateWithoutNotificationsInput, ProgramUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutNotificationsInput
    connect?: ProgramWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type ProgramUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<ProgramCreateWithoutNotificationsInput, ProgramUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutNotificationsInput
    upsert?: ProgramUpsertWithoutNotificationsInput
    disconnect?: ProgramWhereInput | boolean
    delete?: ProgramWhereInput | boolean
    connect?: ProgramWhereUniqueInput
    update?: XOR<XOR<ProgramUpdateToOneWithWhereWithoutNotificationsInput, ProgramUpdateWithoutNotificationsInput>, ProgramUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutExternalSyncsInput = {
    create?: XOR<UserCreateWithoutExternalSyncsInput, UserUncheckedCreateWithoutExternalSyncsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExternalSyncsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumExternalProviderFieldUpdateOperationsInput = {
    set?: $Enums.ExternalProvider
  }

  export type EnumExternalSyncStatusFieldUpdateOperationsInput = {
    set?: $Enums.ExternalSyncStatus
  }

  export type UserUpdateOneRequiredWithoutExternalSyncsNestedInput = {
    create?: XOR<UserCreateWithoutExternalSyncsInput, UserUncheckedCreateWithoutExternalSyncsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExternalSyncsInput
    upsert?: UserUpsertWithoutExternalSyncsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExternalSyncsInput, UserUpdateWithoutExternalSyncsInput>, UserUncheckedUpdateWithoutExternalSyncsInput>
  }

  export type UserCreateNestedOneWithoutJournalEntriesInput = {
    create?: XOR<UserCreateWithoutJournalEntriesInput, UserUncheckedCreateWithoutJournalEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutJournalEntriesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumJournalCategoryFieldUpdateOperationsInput = {
    set?: $Enums.JournalCategory
  }

  export type UserUpdateOneRequiredWithoutJournalEntriesNestedInput = {
    create?: XOR<UserCreateWithoutJournalEntriesInput, UserUncheckedCreateWithoutJournalEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutJournalEntriesInput
    upsert?: UserUpsertWithoutJournalEntriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutJournalEntriesInput, UserUpdateWithoutJournalEntriesInput>, UserUncheckedUpdateWithoutJournalEntriesInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserCreateNestedOneWithoutLogsInput = {
    create?: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.EventType
  }

  export type UserUpdateOneWithoutLogsNestedInput = {
    create?: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogsInput
    upsert?: UserUpsertWithoutLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLogsInput, UserUpdateWithoutLogsInput>, UserUncheckedUpdateWithoutLogsInput>
  }

  export type UserCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    upsert?: UserUpsertWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefreshTokensInput, UserUpdateWithoutRefreshTokensInput>, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserCreateNestedOneWithoutAuthSessionsInput = {
    create?: XOR<UserCreateWithoutAuthSessionsInput, UserUncheckedCreateWithoutAuthSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuthSessionsNestedInput = {
    create?: XOR<UserCreateWithoutAuthSessionsInput, UserUncheckedCreateWithoutAuthSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthSessionsInput
    upsert?: UserUpsertWithoutAuthSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuthSessionsInput, UserUpdateWithoutAuthSessionsInput>, UserUncheckedUpdateWithoutAuthSessionsInput>
  }

  export type UserCreateNestedOneWithoutMoodTracksInput = {
    create?: XOR<UserCreateWithoutMoodTracksInput, UserUncheckedCreateWithoutMoodTracksInput>
    connectOrCreate?: UserCreateOrConnectWithoutMoodTracksInput
    connect?: UserWhereUniqueInput
  }

  export type NullableEnumMoodTypeFieldUpdateOperationsInput = {
    set?: $Enums.MoodType | null
  }

  export type NullableEnumEnergyLevelFieldUpdateOperationsInput = {
    set?: $Enums.EnergyLevel | null
  }

  export type NullableEnumPainLevelFieldUpdateOperationsInput = {
    set?: $Enums.PainLevel | null
  }

  export type NullableEnumStressLevelFieldUpdateOperationsInput = {
    set?: $Enums.StressLevel | null
  }

  export type NullableEnumSleepQualityFieldUpdateOperationsInput = {
    set?: $Enums.SleepQuality | null
  }

  export type UserUpdateOneRequiredWithoutMoodTracksNestedInput = {
    create?: XOR<UserCreateWithoutMoodTracksInput, UserUncheckedCreateWithoutMoodTracksInput>
    connectOrCreate?: UserCreateOrConnectWithoutMoodTracksInput
    upsert?: UserUpsertWithoutMoodTracksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMoodTracksInput, UserUpdateWithoutMoodTracksInput>, UserUncheckedUpdateWithoutMoodTracksInput>
  }

  export type UserCreateNestedOneWithoutSymptomLogsInput = {
    create?: XOR<UserCreateWithoutSymptomLogsInput, UserUncheckedCreateWithoutSymptomLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSymptomLogsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumSymptomTypeFieldUpdateOperationsInput = {
    set?: $Enums.SymptomType
  }

  export type UserUpdateOneRequiredWithoutSymptomLogsNestedInput = {
    create?: XOR<UserCreateWithoutSymptomLogsInput, UserUncheckedCreateWithoutSymptomLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSymptomLogsInput
    upsert?: UserUpsertWithoutSymptomLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSymptomLogsInput, UserUpdateWithoutSymptomLogsInput>, UserUncheckedUpdateWithoutSymptomLogsInput>
  }

  export type UserCreateNestedOneWithoutUserSettingsInput = {
    create?: XOR<UserCreateWithoutUserSettingsInput, UserUncheckedCreateWithoutUserSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSettingsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumUnitPreferenceFieldUpdateOperationsInput = {
    set?: $Enums.UnitPreference
  }

  export type UserUpdateOneRequiredWithoutUserSettingsNestedInput = {
    create?: XOR<UserCreateWithoutUserSettingsInput, UserUncheckedCreateWithoutUserSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSettingsInput
    upsert?: UserUpsertWithoutUserSettingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserSettingsInput, UserUpdateWithoutUserSettingsInput>, UserUncheckedUpdateWithoutUserSettingsInput>
  }

  export type UserCreateNestedOneWithoutReminderSettingsInput = {
    create?: XOR<UserCreateWithoutReminderSettingsInput, UserUncheckedCreateWithoutReminderSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReminderSettingsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumReminderTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReminderType
  }

  export type UserUpdateOneRequiredWithoutReminderSettingsNestedInput = {
    create?: XOR<UserCreateWithoutReminderSettingsInput, UserUncheckedCreateWithoutReminderSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReminderSettingsInput
    upsert?: UserUpsertWithoutReminderSettingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReminderSettingsInput, UserUpdateWithoutReminderSettingsInput>, UserUncheckedUpdateWithoutReminderSettingsInput>
  }

  export type UserCreateNestedOneWithoutUserFeatureFlagsInput = {
    create?: XOR<UserCreateWithoutUserFeatureFlagsInput, UserUncheckedCreateWithoutUserFeatureFlagsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserFeatureFlagsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserFeatureFlagsNestedInput = {
    create?: XOR<UserCreateWithoutUserFeatureFlagsInput, UserUncheckedCreateWithoutUserFeatureFlagsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserFeatureFlagsInput
    upsert?: UserUpsertWithoutUserFeatureFlagsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserFeatureFlagsInput, UserUpdateWithoutUserFeatureFlagsInput>, UserUncheckedUpdateWithoutUserFeatureFlagsInput>
  }

  export type UserCreateNestedOneWithoutUserObjectivesInput = {
    create?: XOR<UserCreateWithoutUserObjectivesInput, UserUncheckedCreateWithoutUserObjectivesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserObjectivesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumObjectiveTypeFieldUpdateOperationsInput = {
    set?: $Enums.ObjectiveType
  }

  export type UserUpdateOneRequiredWithoutUserObjectivesNestedInput = {
    create?: XOR<UserCreateWithoutUserObjectivesInput, UserUncheckedCreateWithoutUserObjectivesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserObjectivesInput
    upsert?: UserUpsertWithoutUserObjectivesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserObjectivesInput, UserUpdateWithoutUserObjectivesInput>, UserUncheckedUpdateWithoutUserObjectivesInput>
  }

  export type UserCreateNestedOneWithoutProfileChangeLogsInput = {
    create?: XOR<UserCreateWithoutProfileChangeLogsInput, UserUncheckedCreateWithoutProfileChangeLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileChangeLogsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumChangeTypeFieldUpdateOperationsInput = {
    set?: $Enums.ChangeType
  }

  export type UserUpdateOneRequiredWithoutProfileChangeLogsNestedInput = {
    create?: XOR<UserCreateWithoutProfileChangeLogsInput, UserUncheckedCreateWithoutProfileChangeLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileChangeLogsInput
    upsert?: UserUpsertWithoutProfileChangeLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfileChangeLogsInput, UserUpdateWithoutProfileChangeLogsInput>, UserUncheckedUpdateWithoutProfileChangeLogsInput>
  }

  export type CycleCreateNestedManyWithoutUserInput = {
    create?: XOR<CycleCreateWithoutUserInput, CycleUncheckedCreateWithoutUserInput> | CycleCreateWithoutUserInput[] | CycleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CycleCreateOrConnectWithoutUserInput | CycleCreateOrConnectWithoutUserInput[]
    createMany?: CycleCreateManyUserInputEnvelope
    connect?: CycleWhereUniqueInput | CycleWhereUniqueInput[]
  }

  export type ProgramCreateNestedManyWithoutUserInput = {
    create?: XOR<ProgramCreateWithoutUserInput, ProgramUncheckedCreateWithoutUserInput> | ProgramCreateWithoutUserInput[] | ProgramUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProgramCreateOrConnectWithoutUserInput | ProgramCreateOrConnectWithoutUserInput[]
    createMany?: ProgramCreateManyUserInputEnvelope
    connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
  }

  export type MoodTrackCreateNestedManyWithoutUserInput = {
    create?: XOR<MoodTrackCreateWithoutUserInput, MoodTrackUncheckedCreateWithoutUserInput> | MoodTrackCreateWithoutUserInput[] | MoodTrackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MoodTrackCreateOrConnectWithoutUserInput | MoodTrackCreateOrConnectWithoutUserInput[]
    createMany?: MoodTrackCreateManyUserInputEnvelope
    connect?: MoodTrackWhereUniqueInput | MoodTrackWhereUniqueInput[]
  }

  export type UserSettingsCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    connect?: UserSettingsWhereUniqueInput
  }

  export type ReminderSettingsCreateNestedManyWithoutUserInput = {
    create?: XOR<ReminderSettingsCreateWithoutUserInput, ReminderSettingsUncheckedCreateWithoutUserInput> | ReminderSettingsCreateWithoutUserInput[] | ReminderSettingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReminderSettingsCreateOrConnectWithoutUserInput | ReminderSettingsCreateOrConnectWithoutUserInput[]
    createMany?: ReminderSettingsCreateManyUserInputEnvelope
    connect?: ReminderSettingsWhereUniqueInput | ReminderSettingsWhereUniqueInput[]
  }

  export type UserFeatureFlagCreateNestedManyWithoutUserInput = {
    create?: XOR<UserFeatureFlagCreateWithoutUserInput, UserFeatureFlagUncheckedCreateWithoutUserInput> | UserFeatureFlagCreateWithoutUserInput[] | UserFeatureFlagUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFeatureFlagCreateOrConnectWithoutUserInput | UserFeatureFlagCreateOrConnectWithoutUserInput[]
    createMany?: UserFeatureFlagCreateManyUserInputEnvelope
    connect?: UserFeatureFlagWhereUniqueInput | UserFeatureFlagWhereUniqueInput[]
  }

  export type UserObjectiveCreateNestedManyWithoutUserInput = {
    create?: XOR<UserObjectiveCreateWithoutUserInput, UserObjectiveUncheckedCreateWithoutUserInput> | UserObjectiveCreateWithoutUserInput[] | UserObjectiveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserObjectiveCreateOrConnectWithoutUserInput | UserObjectiveCreateOrConnectWithoutUserInput[]
    createMany?: UserObjectiveCreateManyUserInputEnvelope
    connect?: UserObjectiveWhereUniqueInput | UserObjectiveWhereUniqueInput[]
  }

  export type ProfileChangeLogCreateNestedManyWithoutUserInput = {
    create?: XOR<ProfileChangeLogCreateWithoutUserInput, ProfileChangeLogUncheckedCreateWithoutUserInput> | ProfileChangeLogCreateWithoutUserInput[] | ProfileChangeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfileChangeLogCreateOrConnectWithoutUserInput | ProfileChangeLogCreateOrConnectWithoutUserInput[]
    createMany?: ProfileChangeLogCreateManyUserInputEnvelope
    connect?: ProfileChangeLogWhereUniqueInput | ProfileChangeLogWhereUniqueInput[]
  }

  export type CycleProfileConfigCreateNestedOneWithoutUserInput = {
    create?: XOR<CycleProfileConfigCreateWithoutUserInput, CycleProfileConfigUncheckedCreateWithoutUserInput>
    connectOrCreate?: CycleProfileConfigCreateOrConnectWithoutUserInput
    connect?: CycleProfileConfigWhereUniqueInput
  }

  export type SymptomLogCreateNestedManyWithoutUserInput = {
    create?: XOR<SymptomLogCreateWithoutUserInput, SymptomLogUncheckedCreateWithoutUserInput> | SymptomLogCreateWithoutUserInput[] | SymptomLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SymptomLogCreateOrConnectWithoutUserInput | SymptomLogCreateOrConnectWithoutUserInput[]
    createMany?: SymptomLogCreateManyUserInputEnvelope
    connect?: SymptomLogWhereUniqueInput | SymptomLogWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ExternalSyncCreateNestedManyWithoutUserInput = {
    create?: XOR<ExternalSyncCreateWithoutUserInput, ExternalSyncUncheckedCreateWithoutUserInput> | ExternalSyncCreateWithoutUserInput[] | ExternalSyncUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExternalSyncCreateOrConnectWithoutUserInput | ExternalSyncCreateOrConnectWithoutUserInput[]
    createMany?: ExternalSyncCreateManyUserInputEnvelope
    connect?: ExternalSyncWhereUniqueInput | ExternalSyncWhereUniqueInput[]
  }

  export type JournalEntryCreateNestedManyWithoutUserInput = {
    create?: XOR<JournalEntryCreateWithoutUserInput, JournalEntryUncheckedCreateWithoutUserInput> | JournalEntryCreateWithoutUserInput[] | JournalEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JournalEntryCreateOrConnectWithoutUserInput | JournalEntryCreateOrConnectWithoutUserInput[]
    createMany?: JournalEntryCreateManyUserInputEnvelope
    connect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type LogCreateNestedManyWithoutUserInput = {
    create?: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput> | LogCreateWithoutUserInput[] | LogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogCreateOrConnectWithoutUserInput | LogCreateOrConnectWithoutUserInput[]
    createMany?: LogCreateManyUserInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type AuthSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<AuthSessionCreateWithoutUserInput, AuthSessionUncheckedCreateWithoutUserInput> | AuthSessionCreateWithoutUserInput[] | AuthSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthSessionCreateOrConnectWithoutUserInput | AuthSessionCreateOrConnectWithoutUserInput[]
    createMany?: AuthSessionCreateManyUserInputEnvelope
    connect?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
  }

  export type CycleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CycleCreateWithoutUserInput, CycleUncheckedCreateWithoutUserInput> | CycleCreateWithoutUserInput[] | CycleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CycleCreateOrConnectWithoutUserInput | CycleCreateOrConnectWithoutUserInput[]
    createMany?: CycleCreateManyUserInputEnvelope
    connect?: CycleWhereUniqueInput | CycleWhereUniqueInput[]
  }

  export type ProgramUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProgramCreateWithoutUserInput, ProgramUncheckedCreateWithoutUserInput> | ProgramCreateWithoutUserInput[] | ProgramUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProgramCreateOrConnectWithoutUserInput | ProgramCreateOrConnectWithoutUserInput[]
    createMany?: ProgramCreateManyUserInputEnvelope
    connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
  }

  export type MoodTrackUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MoodTrackCreateWithoutUserInput, MoodTrackUncheckedCreateWithoutUserInput> | MoodTrackCreateWithoutUserInput[] | MoodTrackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MoodTrackCreateOrConnectWithoutUserInput | MoodTrackCreateOrConnectWithoutUserInput[]
    createMany?: MoodTrackCreateManyUserInputEnvelope
    connect?: MoodTrackWhereUniqueInput | MoodTrackWhereUniqueInput[]
  }

  export type UserSettingsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    connect?: UserSettingsWhereUniqueInput
  }

  export type ReminderSettingsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReminderSettingsCreateWithoutUserInput, ReminderSettingsUncheckedCreateWithoutUserInput> | ReminderSettingsCreateWithoutUserInput[] | ReminderSettingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReminderSettingsCreateOrConnectWithoutUserInput | ReminderSettingsCreateOrConnectWithoutUserInput[]
    createMany?: ReminderSettingsCreateManyUserInputEnvelope
    connect?: ReminderSettingsWhereUniqueInput | ReminderSettingsWhereUniqueInput[]
  }

  export type UserFeatureFlagUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserFeatureFlagCreateWithoutUserInput, UserFeatureFlagUncheckedCreateWithoutUserInput> | UserFeatureFlagCreateWithoutUserInput[] | UserFeatureFlagUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFeatureFlagCreateOrConnectWithoutUserInput | UserFeatureFlagCreateOrConnectWithoutUserInput[]
    createMany?: UserFeatureFlagCreateManyUserInputEnvelope
    connect?: UserFeatureFlagWhereUniqueInput | UserFeatureFlagWhereUniqueInput[]
  }

  export type UserObjectiveUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserObjectiveCreateWithoutUserInput, UserObjectiveUncheckedCreateWithoutUserInput> | UserObjectiveCreateWithoutUserInput[] | UserObjectiveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserObjectiveCreateOrConnectWithoutUserInput | UserObjectiveCreateOrConnectWithoutUserInput[]
    createMany?: UserObjectiveCreateManyUserInputEnvelope
    connect?: UserObjectiveWhereUniqueInput | UserObjectiveWhereUniqueInput[]
  }

  export type ProfileChangeLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProfileChangeLogCreateWithoutUserInput, ProfileChangeLogUncheckedCreateWithoutUserInput> | ProfileChangeLogCreateWithoutUserInput[] | ProfileChangeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfileChangeLogCreateOrConnectWithoutUserInput | ProfileChangeLogCreateOrConnectWithoutUserInput[]
    createMany?: ProfileChangeLogCreateManyUserInputEnvelope
    connect?: ProfileChangeLogWhereUniqueInput | ProfileChangeLogWhereUniqueInput[]
  }

  export type CycleProfileConfigUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<CycleProfileConfigCreateWithoutUserInput, CycleProfileConfigUncheckedCreateWithoutUserInput>
    connectOrCreate?: CycleProfileConfigCreateOrConnectWithoutUserInput
    connect?: CycleProfileConfigWhereUniqueInput
  }

  export type SymptomLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SymptomLogCreateWithoutUserInput, SymptomLogUncheckedCreateWithoutUserInput> | SymptomLogCreateWithoutUserInput[] | SymptomLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SymptomLogCreateOrConnectWithoutUserInput | SymptomLogCreateOrConnectWithoutUserInput[]
    createMany?: SymptomLogCreateManyUserInputEnvelope
    connect?: SymptomLogWhereUniqueInput | SymptomLogWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ExternalSyncUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ExternalSyncCreateWithoutUserInput, ExternalSyncUncheckedCreateWithoutUserInput> | ExternalSyncCreateWithoutUserInput[] | ExternalSyncUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExternalSyncCreateOrConnectWithoutUserInput | ExternalSyncCreateOrConnectWithoutUserInput[]
    createMany?: ExternalSyncCreateManyUserInputEnvelope
    connect?: ExternalSyncWhereUniqueInput | ExternalSyncWhereUniqueInput[]
  }

  export type JournalEntryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<JournalEntryCreateWithoutUserInput, JournalEntryUncheckedCreateWithoutUserInput> | JournalEntryCreateWithoutUserInput[] | JournalEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JournalEntryCreateOrConnectWithoutUserInput | JournalEntryCreateOrConnectWithoutUserInput[]
    createMany?: JournalEntryCreateManyUserInputEnvelope
    connect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type LogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput> | LogCreateWithoutUserInput[] | LogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogCreateOrConnectWithoutUserInput | LogCreateOrConnectWithoutUserInput[]
    createMany?: LogCreateManyUserInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type AuthSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuthSessionCreateWithoutUserInput, AuthSessionUncheckedCreateWithoutUserInput> | AuthSessionCreateWithoutUserInput[] | AuthSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthSessionCreateOrConnectWithoutUserInput | AuthSessionCreateOrConnectWithoutUserInput[]
    createMany?: AuthSessionCreateManyUserInputEnvelope
    connect?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
  }

  export type NullableEnumSportFrequencyFieldUpdateOperationsInput = {
    set?: $Enums.SportFrequency | null
  }

  export type EnumProfileTypeFieldUpdateOperationsInput = {
    set?: $Enums.ProfileType
  }

  export type EnumContextTypeFieldUpdateOperationsInput = {
    set?: $Enums.ContextType
  }

  export type CycleUpdateManyWithoutUserNestedInput = {
    create?: XOR<CycleCreateWithoutUserInput, CycleUncheckedCreateWithoutUserInput> | CycleCreateWithoutUserInput[] | CycleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CycleCreateOrConnectWithoutUserInput | CycleCreateOrConnectWithoutUserInput[]
    upsert?: CycleUpsertWithWhereUniqueWithoutUserInput | CycleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CycleCreateManyUserInputEnvelope
    set?: CycleWhereUniqueInput | CycleWhereUniqueInput[]
    disconnect?: CycleWhereUniqueInput | CycleWhereUniqueInput[]
    delete?: CycleWhereUniqueInput | CycleWhereUniqueInput[]
    connect?: CycleWhereUniqueInput | CycleWhereUniqueInput[]
    update?: CycleUpdateWithWhereUniqueWithoutUserInput | CycleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CycleUpdateManyWithWhereWithoutUserInput | CycleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CycleScalarWhereInput | CycleScalarWhereInput[]
  }

  export type ProgramUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProgramCreateWithoutUserInput, ProgramUncheckedCreateWithoutUserInput> | ProgramCreateWithoutUserInput[] | ProgramUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProgramCreateOrConnectWithoutUserInput | ProgramCreateOrConnectWithoutUserInput[]
    upsert?: ProgramUpsertWithWhereUniqueWithoutUserInput | ProgramUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProgramCreateManyUserInputEnvelope
    set?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    disconnect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    delete?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    update?: ProgramUpdateWithWhereUniqueWithoutUserInput | ProgramUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProgramUpdateManyWithWhereWithoutUserInput | ProgramUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProgramScalarWhereInput | ProgramScalarWhereInput[]
  }

  export type MoodTrackUpdateManyWithoutUserNestedInput = {
    create?: XOR<MoodTrackCreateWithoutUserInput, MoodTrackUncheckedCreateWithoutUserInput> | MoodTrackCreateWithoutUserInput[] | MoodTrackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MoodTrackCreateOrConnectWithoutUserInput | MoodTrackCreateOrConnectWithoutUserInput[]
    upsert?: MoodTrackUpsertWithWhereUniqueWithoutUserInput | MoodTrackUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MoodTrackCreateManyUserInputEnvelope
    set?: MoodTrackWhereUniqueInput | MoodTrackWhereUniqueInput[]
    disconnect?: MoodTrackWhereUniqueInput | MoodTrackWhereUniqueInput[]
    delete?: MoodTrackWhereUniqueInput | MoodTrackWhereUniqueInput[]
    connect?: MoodTrackWhereUniqueInput | MoodTrackWhereUniqueInput[]
    update?: MoodTrackUpdateWithWhereUniqueWithoutUserInput | MoodTrackUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MoodTrackUpdateManyWithWhereWithoutUserInput | MoodTrackUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MoodTrackScalarWhereInput | MoodTrackScalarWhereInput[]
  }

  export type UserSettingsUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    upsert?: UserSettingsUpsertWithoutUserInput
    disconnect?: UserSettingsWhereInput | boolean
    delete?: UserSettingsWhereInput | boolean
    connect?: UserSettingsWhereUniqueInput
    update?: XOR<XOR<UserSettingsUpdateToOneWithWhereWithoutUserInput, UserSettingsUpdateWithoutUserInput>, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type ReminderSettingsUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReminderSettingsCreateWithoutUserInput, ReminderSettingsUncheckedCreateWithoutUserInput> | ReminderSettingsCreateWithoutUserInput[] | ReminderSettingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReminderSettingsCreateOrConnectWithoutUserInput | ReminderSettingsCreateOrConnectWithoutUserInput[]
    upsert?: ReminderSettingsUpsertWithWhereUniqueWithoutUserInput | ReminderSettingsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReminderSettingsCreateManyUserInputEnvelope
    set?: ReminderSettingsWhereUniqueInput | ReminderSettingsWhereUniqueInput[]
    disconnect?: ReminderSettingsWhereUniqueInput | ReminderSettingsWhereUniqueInput[]
    delete?: ReminderSettingsWhereUniqueInput | ReminderSettingsWhereUniqueInput[]
    connect?: ReminderSettingsWhereUniqueInput | ReminderSettingsWhereUniqueInput[]
    update?: ReminderSettingsUpdateWithWhereUniqueWithoutUserInput | ReminderSettingsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReminderSettingsUpdateManyWithWhereWithoutUserInput | ReminderSettingsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReminderSettingsScalarWhereInput | ReminderSettingsScalarWhereInput[]
  }

  export type UserFeatureFlagUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserFeatureFlagCreateWithoutUserInput, UserFeatureFlagUncheckedCreateWithoutUserInput> | UserFeatureFlagCreateWithoutUserInput[] | UserFeatureFlagUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFeatureFlagCreateOrConnectWithoutUserInput | UserFeatureFlagCreateOrConnectWithoutUserInput[]
    upsert?: UserFeatureFlagUpsertWithWhereUniqueWithoutUserInput | UserFeatureFlagUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserFeatureFlagCreateManyUserInputEnvelope
    set?: UserFeatureFlagWhereUniqueInput | UserFeatureFlagWhereUniqueInput[]
    disconnect?: UserFeatureFlagWhereUniqueInput | UserFeatureFlagWhereUniqueInput[]
    delete?: UserFeatureFlagWhereUniqueInput | UserFeatureFlagWhereUniqueInput[]
    connect?: UserFeatureFlagWhereUniqueInput | UserFeatureFlagWhereUniqueInput[]
    update?: UserFeatureFlagUpdateWithWhereUniqueWithoutUserInput | UserFeatureFlagUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserFeatureFlagUpdateManyWithWhereWithoutUserInput | UserFeatureFlagUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserFeatureFlagScalarWhereInput | UserFeatureFlagScalarWhereInput[]
  }

  export type UserObjectiveUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserObjectiveCreateWithoutUserInput, UserObjectiveUncheckedCreateWithoutUserInput> | UserObjectiveCreateWithoutUserInput[] | UserObjectiveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserObjectiveCreateOrConnectWithoutUserInput | UserObjectiveCreateOrConnectWithoutUserInput[]
    upsert?: UserObjectiveUpsertWithWhereUniqueWithoutUserInput | UserObjectiveUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserObjectiveCreateManyUserInputEnvelope
    set?: UserObjectiveWhereUniqueInput | UserObjectiveWhereUniqueInput[]
    disconnect?: UserObjectiveWhereUniqueInput | UserObjectiveWhereUniqueInput[]
    delete?: UserObjectiveWhereUniqueInput | UserObjectiveWhereUniqueInput[]
    connect?: UserObjectiveWhereUniqueInput | UserObjectiveWhereUniqueInput[]
    update?: UserObjectiveUpdateWithWhereUniqueWithoutUserInput | UserObjectiveUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserObjectiveUpdateManyWithWhereWithoutUserInput | UserObjectiveUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserObjectiveScalarWhereInput | UserObjectiveScalarWhereInput[]
  }

  export type ProfileChangeLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProfileChangeLogCreateWithoutUserInput, ProfileChangeLogUncheckedCreateWithoutUserInput> | ProfileChangeLogCreateWithoutUserInput[] | ProfileChangeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfileChangeLogCreateOrConnectWithoutUserInput | ProfileChangeLogCreateOrConnectWithoutUserInput[]
    upsert?: ProfileChangeLogUpsertWithWhereUniqueWithoutUserInput | ProfileChangeLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProfileChangeLogCreateManyUserInputEnvelope
    set?: ProfileChangeLogWhereUniqueInput | ProfileChangeLogWhereUniqueInput[]
    disconnect?: ProfileChangeLogWhereUniqueInput | ProfileChangeLogWhereUniqueInput[]
    delete?: ProfileChangeLogWhereUniqueInput | ProfileChangeLogWhereUniqueInput[]
    connect?: ProfileChangeLogWhereUniqueInput | ProfileChangeLogWhereUniqueInput[]
    update?: ProfileChangeLogUpdateWithWhereUniqueWithoutUserInput | ProfileChangeLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProfileChangeLogUpdateManyWithWhereWithoutUserInput | ProfileChangeLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProfileChangeLogScalarWhereInput | ProfileChangeLogScalarWhereInput[]
  }

  export type CycleProfileConfigUpdateOneWithoutUserNestedInput = {
    create?: XOR<CycleProfileConfigCreateWithoutUserInput, CycleProfileConfigUncheckedCreateWithoutUserInput>
    connectOrCreate?: CycleProfileConfigCreateOrConnectWithoutUserInput
    upsert?: CycleProfileConfigUpsertWithoutUserInput
    disconnect?: CycleProfileConfigWhereInput | boolean
    delete?: CycleProfileConfigWhereInput | boolean
    connect?: CycleProfileConfigWhereUniqueInput
    update?: XOR<XOR<CycleProfileConfigUpdateToOneWithWhereWithoutUserInput, CycleProfileConfigUpdateWithoutUserInput>, CycleProfileConfigUncheckedUpdateWithoutUserInput>
  }

  export type SymptomLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<SymptomLogCreateWithoutUserInput, SymptomLogUncheckedCreateWithoutUserInput> | SymptomLogCreateWithoutUserInput[] | SymptomLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SymptomLogCreateOrConnectWithoutUserInput | SymptomLogCreateOrConnectWithoutUserInput[]
    upsert?: SymptomLogUpsertWithWhereUniqueWithoutUserInput | SymptomLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SymptomLogCreateManyUserInputEnvelope
    set?: SymptomLogWhereUniqueInput | SymptomLogWhereUniqueInput[]
    disconnect?: SymptomLogWhereUniqueInput | SymptomLogWhereUniqueInput[]
    delete?: SymptomLogWhereUniqueInput | SymptomLogWhereUniqueInput[]
    connect?: SymptomLogWhereUniqueInput | SymptomLogWhereUniqueInput[]
    update?: SymptomLogUpdateWithWhereUniqueWithoutUserInput | SymptomLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SymptomLogUpdateManyWithWhereWithoutUserInput | SymptomLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SymptomLogScalarWhereInput | SymptomLogScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ExternalSyncUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExternalSyncCreateWithoutUserInput, ExternalSyncUncheckedCreateWithoutUserInput> | ExternalSyncCreateWithoutUserInput[] | ExternalSyncUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExternalSyncCreateOrConnectWithoutUserInput | ExternalSyncCreateOrConnectWithoutUserInput[]
    upsert?: ExternalSyncUpsertWithWhereUniqueWithoutUserInput | ExternalSyncUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExternalSyncCreateManyUserInputEnvelope
    set?: ExternalSyncWhereUniqueInput | ExternalSyncWhereUniqueInput[]
    disconnect?: ExternalSyncWhereUniqueInput | ExternalSyncWhereUniqueInput[]
    delete?: ExternalSyncWhereUniqueInput | ExternalSyncWhereUniqueInput[]
    connect?: ExternalSyncWhereUniqueInput | ExternalSyncWhereUniqueInput[]
    update?: ExternalSyncUpdateWithWhereUniqueWithoutUserInput | ExternalSyncUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExternalSyncUpdateManyWithWhereWithoutUserInput | ExternalSyncUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExternalSyncScalarWhereInput | ExternalSyncScalarWhereInput[]
  }

  export type JournalEntryUpdateManyWithoutUserNestedInput = {
    create?: XOR<JournalEntryCreateWithoutUserInput, JournalEntryUncheckedCreateWithoutUserInput> | JournalEntryCreateWithoutUserInput[] | JournalEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JournalEntryCreateOrConnectWithoutUserInput | JournalEntryCreateOrConnectWithoutUserInput[]
    upsert?: JournalEntryUpsertWithWhereUniqueWithoutUserInput | JournalEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: JournalEntryCreateManyUserInputEnvelope
    set?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    disconnect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    delete?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    connect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    update?: JournalEntryUpdateWithWhereUniqueWithoutUserInput | JournalEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: JournalEntryUpdateManyWithWhereWithoutUserInput | JournalEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: JournalEntryScalarWhereInput | JournalEntryScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type LogUpdateManyWithoutUserNestedInput = {
    create?: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput> | LogCreateWithoutUserInput[] | LogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogCreateOrConnectWithoutUserInput | LogCreateOrConnectWithoutUserInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutUserInput | LogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LogCreateManyUserInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutUserInput | LogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LogUpdateManyWithWhereWithoutUserInput | LogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type AuthSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuthSessionCreateWithoutUserInput, AuthSessionUncheckedCreateWithoutUserInput> | AuthSessionCreateWithoutUserInput[] | AuthSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthSessionCreateOrConnectWithoutUserInput | AuthSessionCreateOrConnectWithoutUserInput[]
    upsert?: AuthSessionUpsertWithWhereUniqueWithoutUserInput | AuthSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuthSessionCreateManyUserInputEnvelope
    set?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
    disconnect?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
    delete?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
    connect?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
    update?: AuthSessionUpdateWithWhereUniqueWithoutUserInput | AuthSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuthSessionUpdateManyWithWhereWithoutUserInput | AuthSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuthSessionScalarWhereInput | AuthSessionScalarWhereInput[]
  }

  export type CycleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CycleCreateWithoutUserInput, CycleUncheckedCreateWithoutUserInput> | CycleCreateWithoutUserInput[] | CycleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CycleCreateOrConnectWithoutUserInput | CycleCreateOrConnectWithoutUserInput[]
    upsert?: CycleUpsertWithWhereUniqueWithoutUserInput | CycleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CycleCreateManyUserInputEnvelope
    set?: CycleWhereUniqueInput | CycleWhereUniqueInput[]
    disconnect?: CycleWhereUniqueInput | CycleWhereUniqueInput[]
    delete?: CycleWhereUniqueInput | CycleWhereUniqueInput[]
    connect?: CycleWhereUniqueInput | CycleWhereUniqueInput[]
    update?: CycleUpdateWithWhereUniqueWithoutUserInput | CycleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CycleUpdateManyWithWhereWithoutUserInput | CycleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CycleScalarWhereInput | CycleScalarWhereInput[]
  }

  export type ProgramUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProgramCreateWithoutUserInput, ProgramUncheckedCreateWithoutUserInput> | ProgramCreateWithoutUserInput[] | ProgramUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProgramCreateOrConnectWithoutUserInput | ProgramCreateOrConnectWithoutUserInput[]
    upsert?: ProgramUpsertWithWhereUniqueWithoutUserInput | ProgramUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProgramCreateManyUserInputEnvelope
    set?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    disconnect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    delete?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    connect?: ProgramWhereUniqueInput | ProgramWhereUniqueInput[]
    update?: ProgramUpdateWithWhereUniqueWithoutUserInput | ProgramUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProgramUpdateManyWithWhereWithoutUserInput | ProgramUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProgramScalarWhereInput | ProgramScalarWhereInput[]
  }

  export type MoodTrackUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MoodTrackCreateWithoutUserInput, MoodTrackUncheckedCreateWithoutUserInput> | MoodTrackCreateWithoutUserInput[] | MoodTrackUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MoodTrackCreateOrConnectWithoutUserInput | MoodTrackCreateOrConnectWithoutUserInput[]
    upsert?: MoodTrackUpsertWithWhereUniqueWithoutUserInput | MoodTrackUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MoodTrackCreateManyUserInputEnvelope
    set?: MoodTrackWhereUniqueInput | MoodTrackWhereUniqueInput[]
    disconnect?: MoodTrackWhereUniqueInput | MoodTrackWhereUniqueInput[]
    delete?: MoodTrackWhereUniqueInput | MoodTrackWhereUniqueInput[]
    connect?: MoodTrackWhereUniqueInput | MoodTrackWhereUniqueInput[]
    update?: MoodTrackUpdateWithWhereUniqueWithoutUserInput | MoodTrackUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MoodTrackUpdateManyWithWhereWithoutUserInput | MoodTrackUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MoodTrackScalarWhereInput | MoodTrackScalarWhereInput[]
  }

  export type UserSettingsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    upsert?: UserSettingsUpsertWithoutUserInput
    disconnect?: UserSettingsWhereInput | boolean
    delete?: UserSettingsWhereInput | boolean
    connect?: UserSettingsWhereUniqueInput
    update?: XOR<XOR<UserSettingsUpdateToOneWithWhereWithoutUserInput, UserSettingsUpdateWithoutUserInput>, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type ReminderSettingsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReminderSettingsCreateWithoutUserInput, ReminderSettingsUncheckedCreateWithoutUserInput> | ReminderSettingsCreateWithoutUserInput[] | ReminderSettingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReminderSettingsCreateOrConnectWithoutUserInput | ReminderSettingsCreateOrConnectWithoutUserInput[]
    upsert?: ReminderSettingsUpsertWithWhereUniqueWithoutUserInput | ReminderSettingsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReminderSettingsCreateManyUserInputEnvelope
    set?: ReminderSettingsWhereUniqueInput | ReminderSettingsWhereUniqueInput[]
    disconnect?: ReminderSettingsWhereUniqueInput | ReminderSettingsWhereUniqueInput[]
    delete?: ReminderSettingsWhereUniqueInput | ReminderSettingsWhereUniqueInput[]
    connect?: ReminderSettingsWhereUniqueInput | ReminderSettingsWhereUniqueInput[]
    update?: ReminderSettingsUpdateWithWhereUniqueWithoutUserInput | ReminderSettingsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReminderSettingsUpdateManyWithWhereWithoutUserInput | ReminderSettingsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReminderSettingsScalarWhereInput | ReminderSettingsScalarWhereInput[]
  }

  export type UserFeatureFlagUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserFeatureFlagCreateWithoutUserInput, UserFeatureFlagUncheckedCreateWithoutUserInput> | UserFeatureFlagCreateWithoutUserInput[] | UserFeatureFlagUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFeatureFlagCreateOrConnectWithoutUserInput | UserFeatureFlagCreateOrConnectWithoutUserInput[]
    upsert?: UserFeatureFlagUpsertWithWhereUniqueWithoutUserInput | UserFeatureFlagUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserFeatureFlagCreateManyUserInputEnvelope
    set?: UserFeatureFlagWhereUniqueInput | UserFeatureFlagWhereUniqueInput[]
    disconnect?: UserFeatureFlagWhereUniqueInput | UserFeatureFlagWhereUniqueInput[]
    delete?: UserFeatureFlagWhereUniqueInput | UserFeatureFlagWhereUniqueInput[]
    connect?: UserFeatureFlagWhereUniqueInput | UserFeatureFlagWhereUniqueInput[]
    update?: UserFeatureFlagUpdateWithWhereUniqueWithoutUserInput | UserFeatureFlagUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserFeatureFlagUpdateManyWithWhereWithoutUserInput | UserFeatureFlagUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserFeatureFlagScalarWhereInput | UserFeatureFlagScalarWhereInput[]
  }

  export type UserObjectiveUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserObjectiveCreateWithoutUserInput, UserObjectiveUncheckedCreateWithoutUserInput> | UserObjectiveCreateWithoutUserInput[] | UserObjectiveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserObjectiveCreateOrConnectWithoutUserInput | UserObjectiveCreateOrConnectWithoutUserInput[]
    upsert?: UserObjectiveUpsertWithWhereUniqueWithoutUserInput | UserObjectiveUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserObjectiveCreateManyUserInputEnvelope
    set?: UserObjectiveWhereUniqueInput | UserObjectiveWhereUniqueInput[]
    disconnect?: UserObjectiveWhereUniqueInput | UserObjectiveWhereUniqueInput[]
    delete?: UserObjectiveWhereUniqueInput | UserObjectiveWhereUniqueInput[]
    connect?: UserObjectiveWhereUniqueInput | UserObjectiveWhereUniqueInput[]
    update?: UserObjectiveUpdateWithWhereUniqueWithoutUserInput | UserObjectiveUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserObjectiveUpdateManyWithWhereWithoutUserInput | UserObjectiveUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserObjectiveScalarWhereInput | UserObjectiveScalarWhereInput[]
  }

  export type ProfileChangeLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProfileChangeLogCreateWithoutUserInput, ProfileChangeLogUncheckedCreateWithoutUserInput> | ProfileChangeLogCreateWithoutUserInput[] | ProfileChangeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfileChangeLogCreateOrConnectWithoutUserInput | ProfileChangeLogCreateOrConnectWithoutUserInput[]
    upsert?: ProfileChangeLogUpsertWithWhereUniqueWithoutUserInput | ProfileChangeLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProfileChangeLogCreateManyUserInputEnvelope
    set?: ProfileChangeLogWhereUniqueInput | ProfileChangeLogWhereUniqueInput[]
    disconnect?: ProfileChangeLogWhereUniqueInput | ProfileChangeLogWhereUniqueInput[]
    delete?: ProfileChangeLogWhereUniqueInput | ProfileChangeLogWhereUniqueInput[]
    connect?: ProfileChangeLogWhereUniqueInput | ProfileChangeLogWhereUniqueInput[]
    update?: ProfileChangeLogUpdateWithWhereUniqueWithoutUserInput | ProfileChangeLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProfileChangeLogUpdateManyWithWhereWithoutUserInput | ProfileChangeLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProfileChangeLogScalarWhereInput | ProfileChangeLogScalarWhereInput[]
  }

  export type CycleProfileConfigUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<CycleProfileConfigCreateWithoutUserInput, CycleProfileConfigUncheckedCreateWithoutUserInput>
    connectOrCreate?: CycleProfileConfigCreateOrConnectWithoutUserInput
    upsert?: CycleProfileConfigUpsertWithoutUserInput
    disconnect?: CycleProfileConfigWhereInput | boolean
    delete?: CycleProfileConfigWhereInput | boolean
    connect?: CycleProfileConfigWhereUniqueInput
    update?: XOR<XOR<CycleProfileConfigUpdateToOneWithWhereWithoutUserInput, CycleProfileConfigUpdateWithoutUserInput>, CycleProfileConfigUncheckedUpdateWithoutUserInput>
  }

  export type SymptomLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SymptomLogCreateWithoutUserInput, SymptomLogUncheckedCreateWithoutUserInput> | SymptomLogCreateWithoutUserInput[] | SymptomLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SymptomLogCreateOrConnectWithoutUserInput | SymptomLogCreateOrConnectWithoutUserInput[]
    upsert?: SymptomLogUpsertWithWhereUniqueWithoutUserInput | SymptomLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SymptomLogCreateManyUserInputEnvelope
    set?: SymptomLogWhereUniqueInput | SymptomLogWhereUniqueInput[]
    disconnect?: SymptomLogWhereUniqueInput | SymptomLogWhereUniqueInput[]
    delete?: SymptomLogWhereUniqueInput | SymptomLogWhereUniqueInput[]
    connect?: SymptomLogWhereUniqueInput | SymptomLogWhereUniqueInput[]
    update?: SymptomLogUpdateWithWhereUniqueWithoutUserInput | SymptomLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SymptomLogUpdateManyWithWhereWithoutUserInput | SymptomLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SymptomLogScalarWhereInput | SymptomLogScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ExternalSyncUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExternalSyncCreateWithoutUserInput, ExternalSyncUncheckedCreateWithoutUserInput> | ExternalSyncCreateWithoutUserInput[] | ExternalSyncUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExternalSyncCreateOrConnectWithoutUserInput | ExternalSyncCreateOrConnectWithoutUserInput[]
    upsert?: ExternalSyncUpsertWithWhereUniqueWithoutUserInput | ExternalSyncUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExternalSyncCreateManyUserInputEnvelope
    set?: ExternalSyncWhereUniqueInput | ExternalSyncWhereUniqueInput[]
    disconnect?: ExternalSyncWhereUniqueInput | ExternalSyncWhereUniqueInput[]
    delete?: ExternalSyncWhereUniqueInput | ExternalSyncWhereUniqueInput[]
    connect?: ExternalSyncWhereUniqueInput | ExternalSyncWhereUniqueInput[]
    update?: ExternalSyncUpdateWithWhereUniqueWithoutUserInput | ExternalSyncUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExternalSyncUpdateManyWithWhereWithoutUserInput | ExternalSyncUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExternalSyncScalarWhereInput | ExternalSyncScalarWhereInput[]
  }

  export type JournalEntryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<JournalEntryCreateWithoutUserInput, JournalEntryUncheckedCreateWithoutUserInput> | JournalEntryCreateWithoutUserInput[] | JournalEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JournalEntryCreateOrConnectWithoutUserInput | JournalEntryCreateOrConnectWithoutUserInput[]
    upsert?: JournalEntryUpsertWithWhereUniqueWithoutUserInput | JournalEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: JournalEntryCreateManyUserInputEnvelope
    set?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    disconnect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    delete?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    connect?: JournalEntryWhereUniqueInput | JournalEntryWhereUniqueInput[]
    update?: JournalEntryUpdateWithWhereUniqueWithoutUserInput | JournalEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: JournalEntryUpdateManyWithWhereWithoutUserInput | JournalEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: JournalEntryScalarWhereInput | JournalEntryScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type LogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput> | LogCreateWithoutUserInput[] | LogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogCreateOrConnectWithoutUserInput | LogCreateOrConnectWithoutUserInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutUserInput | LogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LogCreateManyUserInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutUserInput | LogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LogUpdateManyWithWhereWithoutUserInput | LogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type AuthSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuthSessionCreateWithoutUserInput, AuthSessionUncheckedCreateWithoutUserInput> | AuthSessionCreateWithoutUserInput[] | AuthSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthSessionCreateOrConnectWithoutUserInput | AuthSessionCreateOrConnectWithoutUserInput[]
    upsert?: AuthSessionUpsertWithWhereUniqueWithoutUserInput | AuthSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuthSessionCreateManyUserInputEnvelope
    set?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
    disconnect?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
    delete?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
    connect?: AuthSessionWhereUniqueInput | AuthSessionWhereUniqueInput[]
    update?: AuthSessionUpdateWithWhereUniqueWithoutUserInput | AuthSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuthSessionUpdateManyWithWhereWithoutUserInput | AuthSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuthSessionScalarWhereInput | AuthSessionScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumCyclePhaseFilter<$PrismaModel = never> = {
    equals?: $Enums.CyclePhase | EnumCyclePhaseFieldRefInput<$PrismaModel>
    in?: $Enums.CyclePhase[] | ListEnumCyclePhaseFieldRefInput<$PrismaModel>
    notIn?: $Enums.CyclePhase[] | ListEnumCyclePhaseFieldRefInput<$PrismaModel>
    not?: NestedEnumCyclePhaseFilter<$PrismaModel> | $Enums.CyclePhase
  }

  export type NestedEnumCyclePhaseWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CyclePhase | EnumCyclePhaseFieldRefInput<$PrismaModel>
    in?: $Enums.CyclePhase[] | ListEnumCyclePhaseFieldRefInput<$PrismaModel>
    notIn?: $Enums.CyclePhase[] | ListEnumCyclePhaseFieldRefInput<$PrismaModel>
    not?: NestedEnumCyclePhaseWithAggregatesFilter<$PrismaModel> | $Enums.CyclePhase
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCyclePhaseFilter<$PrismaModel>
    _max?: NestedEnumCyclePhaseFilter<$PrismaModel>
  }

  export type NestedEnumIntensityNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Intensity | EnumIntensityFieldRefInput<$PrismaModel> | null
    in?: $Enums.Intensity[] | ListEnumIntensityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Intensity[] | ListEnumIntensityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumIntensityNullableFilter<$PrismaModel> | $Enums.Intensity | null
  }

  export type NestedEnumMuscleZoneNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.MuscleZone | EnumMuscleZoneFieldRefInput<$PrismaModel> | null
    in?: $Enums.MuscleZone[] | ListEnumMuscleZoneFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MuscleZone[] | ListEnumMuscleZoneFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMuscleZoneNullableFilter<$PrismaModel> | $Enums.MuscleZone | null
  }

  export type NestedEnumIntensityNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Intensity | EnumIntensityFieldRefInput<$PrismaModel> | null
    in?: $Enums.Intensity[] | ListEnumIntensityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Intensity[] | ListEnumIntensityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumIntensityNullableWithAggregatesFilter<$PrismaModel> | $Enums.Intensity | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumIntensityNullableFilter<$PrismaModel>
    _max?: NestedEnumIntensityNullableFilter<$PrismaModel>
  }

  export type NestedEnumMuscleZoneNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MuscleZone | EnumMuscleZoneFieldRefInput<$PrismaModel> | null
    in?: $Enums.MuscleZone[] | ListEnumMuscleZoneFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MuscleZone[] | ListEnumMuscleZoneFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMuscleZoneNullableWithAggregatesFilter<$PrismaModel> | $Enums.MuscleZone | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumMuscleZoneNullableFilter<$PrismaModel>
    _max?: NestedEnumMuscleZoneNullableFilter<$PrismaModel>
  }

  export type NestedEnumTagTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TagType | EnumTagTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TagType[] | ListEnumTagTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TagType[] | ListEnumTagTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTagTypeFilter<$PrismaModel> | $Enums.TagType
  }

  export type NestedEnumTagTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TagType | EnumTagTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TagType[] | ListEnumTagTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TagType[] | ListEnumTagTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTagTypeWithAggregatesFilter<$PrismaModel> | $Enums.TagType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTagTypeFilter<$PrismaModel>
    _max?: NestedEnumTagTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumExternalProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.ExternalProvider | EnumExternalProviderFieldRefInput<$PrismaModel>
    in?: $Enums.ExternalProvider[] | ListEnumExternalProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExternalProvider[] | ListEnumExternalProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumExternalProviderFilter<$PrismaModel> | $Enums.ExternalProvider
  }

  export type NestedEnumExternalSyncStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ExternalSyncStatus | EnumExternalSyncStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExternalSyncStatus[] | ListEnumExternalSyncStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExternalSyncStatus[] | ListEnumExternalSyncStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExternalSyncStatusFilter<$PrismaModel> | $Enums.ExternalSyncStatus
  }

  export type NestedEnumExternalProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExternalProvider | EnumExternalProviderFieldRefInput<$PrismaModel>
    in?: $Enums.ExternalProvider[] | ListEnumExternalProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExternalProvider[] | ListEnumExternalProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumExternalProviderWithAggregatesFilter<$PrismaModel> | $Enums.ExternalProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExternalProviderFilter<$PrismaModel>
    _max?: NestedEnumExternalProviderFilter<$PrismaModel>
  }

  export type NestedEnumExternalSyncStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExternalSyncStatus | EnumExternalSyncStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExternalSyncStatus[] | ListEnumExternalSyncStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExternalSyncStatus[] | ListEnumExternalSyncStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExternalSyncStatusWithAggregatesFilter<$PrismaModel> | $Enums.ExternalSyncStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExternalSyncStatusFilter<$PrismaModel>
    _max?: NestedEnumExternalSyncStatusFilter<$PrismaModel>
  }

  export type NestedEnumJournalCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.JournalCategory | EnumJournalCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.JournalCategory[] | ListEnumJournalCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.JournalCategory[] | ListEnumJournalCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumJournalCategoryFilter<$PrismaModel> | $Enums.JournalCategory
  }

  export type NestedEnumJournalCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JournalCategory | EnumJournalCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.JournalCategory[] | ListEnumJournalCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.JournalCategory[] | ListEnumJournalCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumJournalCategoryWithAggregatesFilter<$PrismaModel> | $Enums.JournalCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJournalCategoryFilter<$PrismaModel>
    _max?: NestedEnumJournalCategoryFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeFilter<$PrismaModel> | $Enums.EventType
  }

  export type NestedEnumEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.EventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventTypeFilter<$PrismaModel>
    _max?: NestedEnumEventTypeFilter<$PrismaModel>
  }

  export type NestedEnumMoodTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.MoodType | EnumMoodTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.MoodType[] | ListEnumMoodTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MoodType[] | ListEnumMoodTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMoodTypeNullableFilter<$PrismaModel> | $Enums.MoodType | null
  }

  export type NestedEnumEnergyLevelNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EnergyLevel | EnumEnergyLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.EnergyLevel[] | ListEnumEnergyLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EnergyLevel[] | ListEnumEnergyLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEnergyLevelNullableFilter<$PrismaModel> | $Enums.EnergyLevel | null
  }

  export type NestedEnumPainLevelNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PainLevel | EnumPainLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.PainLevel[] | ListEnumPainLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PainLevel[] | ListEnumPainLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPainLevelNullableFilter<$PrismaModel> | $Enums.PainLevel | null
  }

  export type NestedEnumStressLevelNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.StressLevel | EnumStressLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.StressLevel[] | ListEnumStressLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.StressLevel[] | ListEnumStressLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumStressLevelNullableFilter<$PrismaModel> | $Enums.StressLevel | null
  }

  export type NestedEnumSleepQualityNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SleepQuality | EnumSleepQualityFieldRefInput<$PrismaModel> | null
    in?: $Enums.SleepQuality[] | ListEnumSleepQualityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SleepQuality[] | ListEnumSleepQualityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSleepQualityNullableFilter<$PrismaModel> | $Enums.SleepQuality | null
  }

  export type NestedEnumMoodTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MoodType | EnumMoodTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.MoodType[] | ListEnumMoodTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MoodType[] | ListEnumMoodTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMoodTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.MoodType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumMoodTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumMoodTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumEnergyLevelNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EnergyLevel | EnumEnergyLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.EnergyLevel[] | ListEnumEnergyLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EnergyLevel[] | ListEnumEnergyLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEnergyLevelNullableWithAggregatesFilter<$PrismaModel> | $Enums.EnergyLevel | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEnergyLevelNullableFilter<$PrismaModel>
    _max?: NestedEnumEnergyLevelNullableFilter<$PrismaModel>
  }

  export type NestedEnumPainLevelNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PainLevel | EnumPainLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.PainLevel[] | ListEnumPainLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PainLevel[] | ListEnumPainLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPainLevelNullableWithAggregatesFilter<$PrismaModel> | $Enums.PainLevel | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPainLevelNullableFilter<$PrismaModel>
    _max?: NestedEnumPainLevelNullableFilter<$PrismaModel>
  }

  export type NestedEnumStressLevelNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StressLevel | EnumStressLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.StressLevel[] | ListEnumStressLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.StressLevel[] | ListEnumStressLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumStressLevelNullableWithAggregatesFilter<$PrismaModel> | $Enums.StressLevel | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumStressLevelNullableFilter<$PrismaModel>
    _max?: NestedEnumStressLevelNullableFilter<$PrismaModel>
  }

  export type NestedEnumSleepQualityNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SleepQuality | EnumSleepQualityFieldRefInput<$PrismaModel> | null
    in?: $Enums.SleepQuality[] | ListEnumSleepQualityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SleepQuality[] | ListEnumSleepQualityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSleepQualityNullableWithAggregatesFilter<$PrismaModel> | $Enums.SleepQuality | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSleepQualityNullableFilter<$PrismaModel>
    _max?: NestedEnumSleepQualityNullableFilter<$PrismaModel>
  }

  export type NestedEnumSymptomTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SymptomType | EnumSymptomTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SymptomType[] | ListEnumSymptomTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SymptomType[] | ListEnumSymptomTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSymptomTypeFilter<$PrismaModel> | $Enums.SymptomType
  }

  export type NestedEnumSymptomTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SymptomType | EnumSymptomTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SymptomType[] | ListEnumSymptomTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SymptomType[] | ListEnumSymptomTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSymptomTypeWithAggregatesFilter<$PrismaModel> | $Enums.SymptomType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSymptomTypeFilter<$PrismaModel>
    _max?: NestedEnumSymptomTypeFilter<$PrismaModel>
  }

  export type NestedEnumUnitPreferenceFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitPreference | EnumUnitPreferenceFieldRefInput<$PrismaModel>
    in?: $Enums.UnitPreference[] | ListEnumUnitPreferenceFieldRefInput<$PrismaModel>
    notIn?: $Enums.UnitPreference[] | ListEnumUnitPreferenceFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitPreferenceFilter<$PrismaModel> | $Enums.UnitPreference
  }

  export type NestedEnumUnitPreferenceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UnitPreference | EnumUnitPreferenceFieldRefInput<$PrismaModel>
    in?: $Enums.UnitPreference[] | ListEnumUnitPreferenceFieldRefInput<$PrismaModel>
    notIn?: $Enums.UnitPreference[] | ListEnumUnitPreferenceFieldRefInput<$PrismaModel>
    not?: NestedEnumUnitPreferenceWithAggregatesFilter<$PrismaModel> | $Enums.UnitPreference
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUnitPreferenceFilter<$PrismaModel>
    _max?: NestedEnumUnitPreferenceFilter<$PrismaModel>
  }

  export type NestedEnumReminderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderType | EnumReminderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderType[] | ListEnumReminderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderType[] | ListEnumReminderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderTypeFilter<$PrismaModel> | $Enums.ReminderType
  }

  export type NestedEnumReminderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderType | EnumReminderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderType[] | ListEnumReminderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderType[] | ListEnumReminderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReminderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReminderTypeFilter<$PrismaModel>
    _max?: NestedEnumReminderTypeFilter<$PrismaModel>
  }

  export type NestedEnumObjectiveTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ObjectiveType | EnumObjectiveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ObjectiveType[] | ListEnumObjectiveTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ObjectiveType[] | ListEnumObjectiveTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumObjectiveTypeFilter<$PrismaModel> | $Enums.ObjectiveType
  }

  export type NestedEnumObjectiveTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ObjectiveType | EnumObjectiveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ObjectiveType[] | ListEnumObjectiveTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ObjectiveType[] | ListEnumObjectiveTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumObjectiveTypeWithAggregatesFilter<$PrismaModel> | $Enums.ObjectiveType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumObjectiveTypeFilter<$PrismaModel>
    _max?: NestedEnumObjectiveTypeFilter<$PrismaModel>
  }

  export type NestedEnumChangeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ChangeType | EnumChangeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChangeTypeFilter<$PrismaModel> | $Enums.ChangeType
  }

  export type NestedEnumChangeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChangeType | EnumChangeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChangeType[] | ListEnumChangeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumChangeTypeWithAggregatesFilter<$PrismaModel> | $Enums.ChangeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChangeTypeFilter<$PrismaModel>
    _max?: NestedEnumChangeTypeFilter<$PrismaModel>
  }

  export type NestedEnumSportFrequencyNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SportFrequency | EnumSportFrequencyFieldRefInput<$PrismaModel> | null
    in?: $Enums.SportFrequency[] | ListEnumSportFrequencyFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SportFrequency[] | ListEnumSportFrequencyFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSportFrequencyNullableFilter<$PrismaModel> | $Enums.SportFrequency | null
  }

  export type NestedEnumProfileTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProfileType | EnumProfileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProfileType[] | ListEnumProfileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProfileType[] | ListEnumProfileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProfileTypeFilter<$PrismaModel> | $Enums.ProfileType
  }

  export type NestedEnumContextTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContextType | EnumContextTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContextType[] | ListEnumContextTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContextType[] | ListEnumContextTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContextTypeFilter<$PrismaModel> | $Enums.ContextType
  }

  export type NestedEnumSportFrequencyNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SportFrequency | EnumSportFrequencyFieldRefInput<$PrismaModel> | null
    in?: $Enums.SportFrequency[] | ListEnumSportFrequencyFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SportFrequency[] | ListEnumSportFrequencyFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSportFrequencyNullableWithAggregatesFilter<$PrismaModel> | $Enums.SportFrequency | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSportFrequencyNullableFilter<$PrismaModel>
    _max?: NestedEnumSportFrequencyNullableFilter<$PrismaModel>
  }

  export type NestedEnumProfileTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProfileType | EnumProfileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProfileType[] | ListEnumProfileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProfileType[] | ListEnumProfileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProfileTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProfileType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProfileTypeFilter<$PrismaModel>
    _max?: NestedEnumProfileTypeFilter<$PrismaModel>
  }

  export type NestedEnumContextTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContextType | EnumContextTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContextType[] | ListEnumContextTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContextType[] | ListEnumContextTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContextTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContextType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContextTypeFilter<$PrismaModel>
    _max?: NestedEnumContextTypeFilter<$PrismaModel>
  }

  export type UserCreateWithoutCyclesInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    birthDate?: Date | string | null
    isMenopausal?: boolean
    objective?: string | null
    sportFrequency?: $Enums.SportFrequency | null
    profileType?: $Enums.ProfileType
    contextType?: $Enums.ContextType
    createdAt?: Date | string
    updatedAt?: Date | string
    programs?: ProgramCreateNestedManyWithoutUserInput
    moodTracks?: MoodTrackCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
    reminderSettings?: ReminderSettingsCreateNestedManyWithoutUserInput
    userFeatureFlags?: UserFeatureFlagCreateNestedManyWithoutUserInput
    userObjectives?: UserObjectiveCreateNestedManyWithoutUserInput
    profileChangeLogs?: ProfileChangeLogCreateNestedManyWithoutUserInput
    cycleProfileConfig?: CycleProfileConfigCreateNestedOneWithoutUserInput
    symptomLogs?: SymptomLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    externalSyncs?: ExternalSyncCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCyclesInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    birthDate?: Date | string | null
    isMenopausal?: boolean
    objective?: string | null
    sportFrequency?: $Enums.SportFrequency | null
    profileType?: $Enums.ProfileType
    contextType?: $Enums.ContextType
    createdAt?: Date | string
    updatedAt?: Date | string
    programs?: ProgramUncheckedCreateNestedManyWithoutUserInput
    moodTracks?: MoodTrackUncheckedCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    reminderSettings?: ReminderSettingsUncheckedCreateNestedManyWithoutUserInput
    userFeatureFlags?: UserFeatureFlagUncheckedCreateNestedManyWithoutUserInput
    userObjectives?: UserObjectiveUncheckedCreateNestedManyWithoutUserInput
    profileChangeLogs?: ProfileChangeLogUncheckedCreateNestedManyWithoutUserInput
    cycleProfileConfig?: CycleProfileConfigUncheckedCreateNestedOneWithoutUserInput
    symptomLogs?: SymptomLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    externalSyncs?: ExternalSyncUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCyclesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCyclesInput, UserUncheckedCreateWithoutCyclesInput>
  }

  export type CycleProviderCreateWithoutCyclesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CycleProviderUncheckedCreateWithoutCyclesInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CycleProviderCreateOrConnectWithoutCyclesInput = {
    where: CycleProviderWhereUniqueInput
    create: XOR<CycleProviderCreateWithoutCyclesInput, CycleProviderUncheckedCreateWithoutCyclesInput>
  }

  export type PhaseCreateWithoutCycleInput = {
    id?: string
    name: $Enums.CyclePhase
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PhaseUncheckedCreateWithoutCycleInput = {
    id?: string
    name: $Enums.CyclePhase
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PhaseCreateOrConnectWithoutCycleInput = {
    where: PhaseWhereUniqueInput
    create: XOR<PhaseCreateWithoutCycleInput, PhaseUncheckedCreateWithoutCycleInput>
  }

  export type PhaseCreateManyCycleInputEnvelope = {
    data: PhaseCreateManyCycleInput | PhaseCreateManyCycleInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCyclesInput = {
    update: XOR<UserUpdateWithoutCyclesInput, UserUncheckedUpdateWithoutCyclesInput>
    create: XOR<UserCreateWithoutCyclesInput, UserUncheckedCreateWithoutCyclesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCyclesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCyclesInput, UserUncheckedUpdateWithoutCyclesInput>
  }

  export type UserUpdateWithoutCyclesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isMenopausal?: BoolFieldUpdateOperationsInput | boolean
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    sportFrequency?: NullableEnumSportFrequencyFieldUpdateOperationsInput | $Enums.SportFrequency | null
    profileType?: EnumProfileTypeFieldUpdateOperationsInput | $Enums.ProfileType
    contextType?: EnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programs?: ProgramUpdateManyWithoutUserNestedInput
    moodTracks?: MoodTrackUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
    reminderSettings?: ReminderSettingsUpdateManyWithoutUserNestedInput
    userFeatureFlags?: UserFeatureFlagUpdateManyWithoutUserNestedInput
    userObjectives?: UserObjectiveUpdateManyWithoutUserNestedInput
    profileChangeLogs?: ProfileChangeLogUpdateManyWithoutUserNestedInput
    cycleProfileConfig?: CycleProfileConfigUpdateOneWithoutUserNestedInput
    symptomLogs?: SymptomLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    externalSyncs?: ExternalSyncUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCyclesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isMenopausal?: BoolFieldUpdateOperationsInput | boolean
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    sportFrequency?: NullableEnumSportFrequencyFieldUpdateOperationsInput | $Enums.SportFrequency | null
    profileType?: EnumProfileTypeFieldUpdateOperationsInput | $Enums.ProfileType
    contextType?: EnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programs?: ProgramUncheckedUpdateManyWithoutUserNestedInput
    moodTracks?: MoodTrackUncheckedUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    reminderSettings?: ReminderSettingsUncheckedUpdateManyWithoutUserNestedInput
    userFeatureFlags?: UserFeatureFlagUncheckedUpdateManyWithoutUserNestedInput
    userObjectives?: UserObjectiveUncheckedUpdateManyWithoutUserNestedInput
    profileChangeLogs?: ProfileChangeLogUncheckedUpdateManyWithoutUserNestedInput
    cycleProfileConfig?: CycleProfileConfigUncheckedUpdateOneWithoutUserNestedInput
    symptomLogs?: SymptomLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    externalSyncs?: ExternalSyncUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CycleProviderUpsertWithoutCyclesInput = {
    update: XOR<CycleProviderUpdateWithoutCyclesInput, CycleProviderUncheckedUpdateWithoutCyclesInput>
    create: XOR<CycleProviderCreateWithoutCyclesInput, CycleProviderUncheckedCreateWithoutCyclesInput>
    where?: CycleProviderWhereInput
  }

  export type CycleProviderUpdateToOneWithWhereWithoutCyclesInput = {
    where?: CycleProviderWhereInput
    data: XOR<CycleProviderUpdateWithoutCyclesInput, CycleProviderUncheckedUpdateWithoutCyclesInput>
  }

  export type CycleProviderUpdateWithoutCyclesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CycleProviderUncheckedUpdateWithoutCyclesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhaseUpsertWithWhereUniqueWithoutCycleInput = {
    where: PhaseWhereUniqueInput
    update: XOR<PhaseUpdateWithoutCycleInput, PhaseUncheckedUpdateWithoutCycleInput>
    create: XOR<PhaseCreateWithoutCycleInput, PhaseUncheckedCreateWithoutCycleInput>
  }

  export type PhaseUpdateWithWhereUniqueWithoutCycleInput = {
    where: PhaseWhereUniqueInput
    data: XOR<PhaseUpdateWithoutCycleInput, PhaseUncheckedUpdateWithoutCycleInput>
  }

  export type PhaseUpdateManyWithWhereWithoutCycleInput = {
    where: PhaseScalarWhereInput
    data: XOR<PhaseUpdateManyMutationInput, PhaseUncheckedUpdateManyWithoutCycleInput>
  }

  export type PhaseScalarWhereInput = {
    AND?: PhaseScalarWhereInput | PhaseScalarWhereInput[]
    OR?: PhaseScalarWhereInput[]
    NOT?: PhaseScalarWhereInput | PhaseScalarWhereInput[]
    id?: StringFilter<"Phase"> | string
    cycleId?: StringFilter<"Phase"> | string
    name?: EnumCyclePhaseFilter<"Phase"> | $Enums.CyclePhase
    startDate?: DateTimeFilter<"Phase"> | Date | string
    endDate?: DateTimeFilter<"Phase"> | Date | string
    createdAt?: DateTimeFilter<"Phase"> | Date | string
    updatedAt?: DateTimeFilter<"Phase"> | Date | string
  }

  export type UserCreateWithoutCycleProfileConfigInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    birthDate?: Date | string | null
    isMenopausal?: boolean
    objective?: string | null
    sportFrequency?: $Enums.SportFrequency | null
    profileType?: $Enums.ProfileType
    contextType?: $Enums.ContextType
    createdAt?: Date | string
    updatedAt?: Date | string
    cycles?: CycleCreateNestedManyWithoutUserInput
    programs?: ProgramCreateNestedManyWithoutUserInput
    moodTracks?: MoodTrackCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
    reminderSettings?: ReminderSettingsCreateNestedManyWithoutUserInput
    userFeatureFlags?: UserFeatureFlagCreateNestedManyWithoutUserInput
    userObjectives?: UserObjectiveCreateNestedManyWithoutUserInput
    profileChangeLogs?: ProfileChangeLogCreateNestedManyWithoutUserInput
    symptomLogs?: SymptomLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    externalSyncs?: ExternalSyncCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCycleProfileConfigInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    birthDate?: Date | string | null
    isMenopausal?: boolean
    objective?: string | null
    sportFrequency?: $Enums.SportFrequency | null
    profileType?: $Enums.ProfileType
    contextType?: $Enums.ContextType
    createdAt?: Date | string
    updatedAt?: Date | string
    cycles?: CycleUncheckedCreateNestedManyWithoutUserInput
    programs?: ProgramUncheckedCreateNestedManyWithoutUserInput
    moodTracks?: MoodTrackUncheckedCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    reminderSettings?: ReminderSettingsUncheckedCreateNestedManyWithoutUserInput
    userFeatureFlags?: UserFeatureFlagUncheckedCreateNestedManyWithoutUserInput
    userObjectives?: UserObjectiveUncheckedCreateNestedManyWithoutUserInput
    profileChangeLogs?: ProfileChangeLogUncheckedCreateNestedManyWithoutUserInput
    symptomLogs?: SymptomLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    externalSyncs?: ExternalSyncUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCycleProfileConfigInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCycleProfileConfigInput, UserUncheckedCreateWithoutCycleProfileConfigInput>
  }

  export type UserUpsertWithoutCycleProfileConfigInput = {
    update: XOR<UserUpdateWithoutCycleProfileConfigInput, UserUncheckedUpdateWithoutCycleProfileConfigInput>
    create: XOR<UserCreateWithoutCycleProfileConfigInput, UserUncheckedCreateWithoutCycleProfileConfigInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCycleProfileConfigInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCycleProfileConfigInput, UserUncheckedUpdateWithoutCycleProfileConfigInput>
  }

  export type UserUpdateWithoutCycleProfileConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isMenopausal?: BoolFieldUpdateOperationsInput | boolean
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    sportFrequency?: NullableEnumSportFrequencyFieldUpdateOperationsInput | $Enums.SportFrequency | null
    profileType?: EnumProfileTypeFieldUpdateOperationsInput | $Enums.ProfileType
    contextType?: EnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cycles?: CycleUpdateManyWithoutUserNestedInput
    programs?: ProgramUpdateManyWithoutUserNestedInput
    moodTracks?: MoodTrackUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
    reminderSettings?: ReminderSettingsUpdateManyWithoutUserNestedInput
    userFeatureFlags?: UserFeatureFlagUpdateManyWithoutUserNestedInput
    userObjectives?: UserObjectiveUpdateManyWithoutUserNestedInput
    profileChangeLogs?: ProfileChangeLogUpdateManyWithoutUserNestedInput
    symptomLogs?: SymptomLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    externalSyncs?: ExternalSyncUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCycleProfileConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isMenopausal?: BoolFieldUpdateOperationsInput | boolean
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    sportFrequency?: NullableEnumSportFrequencyFieldUpdateOperationsInput | $Enums.SportFrequency | null
    profileType?: EnumProfileTypeFieldUpdateOperationsInput | $Enums.ProfileType
    contextType?: EnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cycles?: CycleUncheckedUpdateManyWithoutUserNestedInput
    programs?: ProgramUncheckedUpdateManyWithoutUserNestedInput
    moodTracks?: MoodTrackUncheckedUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    reminderSettings?: ReminderSettingsUncheckedUpdateManyWithoutUserNestedInput
    userFeatureFlags?: UserFeatureFlagUncheckedUpdateManyWithoutUserNestedInput
    userObjectives?: UserObjectiveUncheckedUpdateManyWithoutUserNestedInput
    profileChangeLogs?: ProfileChangeLogUncheckedUpdateManyWithoutUserNestedInput
    symptomLogs?: SymptomLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    externalSyncs?: ExternalSyncUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CycleCreateWithoutProviderInput = {
    id?: string
    startDate: Date | string
    cycleLength?: number | null
    periodLength?: number | null
    isRegular?: boolean
    externalCycleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCyclesInput
    phases?: PhaseCreateNestedManyWithoutCycleInput
  }

  export type CycleUncheckedCreateWithoutProviderInput = {
    id?: string
    userId: string
    startDate: Date | string
    cycleLength?: number | null
    periodLength?: number | null
    isRegular?: boolean
    externalCycleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phases?: PhaseUncheckedCreateNestedManyWithoutCycleInput
  }

  export type CycleCreateOrConnectWithoutProviderInput = {
    where: CycleWhereUniqueInput
    create: XOR<CycleCreateWithoutProviderInput, CycleUncheckedCreateWithoutProviderInput>
  }

  export type CycleCreateManyProviderInputEnvelope = {
    data: CycleCreateManyProviderInput | CycleCreateManyProviderInput[]
    skipDuplicates?: boolean
  }

  export type CycleUpsertWithWhereUniqueWithoutProviderInput = {
    where: CycleWhereUniqueInput
    update: XOR<CycleUpdateWithoutProviderInput, CycleUncheckedUpdateWithoutProviderInput>
    create: XOR<CycleCreateWithoutProviderInput, CycleUncheckedCreateWithoutProviderInput>
  }

  export type CycleUpdateWithWhereUniqueWithoutProviderInput = {
    where: CycleWhereUniqueInput
    data: XOR<CycleUpdateWithoutProviderInput, CycleUncheckedUpdateWithoutProviderInput>
  }

  export type CycleUpdateManyWithWhereWithoutProviderInput = {
    where: CycleScalarWhereInput
    data: XOR<CycleUpdateManyMutationInput, CycleUncheckedUpdateManyWithoutProviderInput>
  }

  export type CycleScalarWhereInput = {
    AND?: CycleScalarWhereInput | CycleScalarWhereInput[]
    OR?: CycleScalarWhereInput[]
    NOT?: CycleScalarWhereInput | CycleScalarWhereInput[]
    id?: StringFilter<"Cycle"> | string
    userId?: StringFilter<"Cycle"> | string
    startDate?: DateTimeFilter<"Cycle"> | Date | string
    cycleLength?: IntNullableFilter<"Cycle"> | number | null
    periodLength?: IntNullableFilter<"Cycle"> | number | null
    isRegular?: BoolFilter<"Cycle"> | boolean
    providerId?: StringNullableFilter<"Cycle"> | string | null
    externalCycleId?: StringNullableFilter<"Cycle"> | string | null
    createdAt?: DateTimeFilter<"Cycle"> | Date | string
    updatedAt?: DateTimeFilter<"Cycle"> | Date | string
  }

  export type CycleCreateWithoutPhasesInput = {
    id?: string
    startDate: Date | string
    cycleLength?: number | null
    periodLength?: number | null
    isRegular?: boolean
    externalCycleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCyclesInput
    provider?: CycleProviderCreateNestedOneWithoutCyclesInput
  }

  export type CycleUncheckedCreateWithoutPhasesInput = {
    id?: string
    userId: string
    startDate: Date | string
    cycleLength?: number | null
    periodLength?: number | null
    isRegular?: boolean
    providerId?: string | null
    externalCycleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CycleCreateOrConnectWithoutPhasesInput = {
    where: CycleWhereUniqueInput
    create: XOR<CycleCreateWithoutPhasesInput, CycleUncheckedCreateWithoutPhasesInput>
  }

  export type CycleUpsertWithoutPhasesInput = {
    update: XOR<CycleUpdateWithoutPhasesInput, CycleUncheckedUpdateWithoutPhasesInput>
    create: XOR<CycleCreateWithoutPhasesInput, CycleUncheckedCreateWithoutPhasesInput>
    where?: CycleWhereInput
  }

  export type CycleUpdateToOneWithWhereWithoutPhasesInput = {
    where?: CycleWhereInput
    data: XOR<CycleUpdateWithoutPhasesInput, CycleUncheckedUpdateWithoutPhasesInput>
  }

  export type CycleUpdateWithoutPhasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cycleLength?: NullableIntFieldUpdateOperationsInput | number | null
    periodLength?: NullableIntFieldUpdateOperationsInput | number | null
    isRegular?: BoolFieldUpdateOperationsInput | boolean
    externalCycleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCyclesNestedInput
    provider?: CycleProviderUpdateOneWithoutCyclesNestedInput
  }

  export type CycleUncheckedUpdateWithoutPhasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cycleLength?: NullableIntFieldUpdateOperationsInput | number | null
    periodLength?: NullableIntFieldUpdateOperationsInput | number | null
    isRegular?: BoolFieldUpdateOperationsInput | boolean
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    externalCycleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseTagCreateWithoutExerciseInput = {
    id?: string
    createdAt?: Date | string
    tag: TagCreateNestedOneWithoutExerciseTagsInput
  }

  export type ExerciseTagUncheckedCreateWithoutExerciseInput = {
    id?: string
    tagId: string
    createdAt?: Date | string
  }

  export type ExerciseTagCreateOrConnectWithoutExerciseInput = {
    where: ExerciseTagWhereUniqueInput
    create: XOR<ExerciseTagCreateWithoutExerciseInput, ExerciseTagUncheckedCreateWithoutExerciseInput>
  }

  export type ExerciseTagCreateManyExerciseInputEnvelope = {
    data: ExerciseTagCreateManyExerciseInput | ExerciseTagCreateManyExerciseInput[]
    skipDuplicates?: boolean
  }

  export type PhaseExerciseCreateWithoutExerciseInput = {
    id?: string
    phaseName: $Enums.CyclePhase
    createdAt?: Date | string
  }

  export type PhaseExerciseUncheckedCreateWithoutExerciseInput = {
    id?: string
    phaseName: $Enums.CyclePhase
    createdAt?: Date | string
  }

  export type PhaseExerciseCreateOrConnectWithoutExerciseInput = {
    where: PhaseExerciseWhereUniqueInput
    create: XOR<PhaseExerciseCreateWithoutExerciseInput, PhaseExerciseUncheckedCreateWithoutExerciseInput>
  }

  export type PhaseExerciseCreateManyExerciseInputEnvelope = {
    data: PhaseExerciseCreateManyExerciseInput | PhaseExerciseCreateManyExerciseInput[]
    skipDuplicates?: boolean
  }

  export type ProgramExerciseCreateWithoutExerciseInput = {
    id?: string
    day: number
    order: number
    createdAt?: Date | string
    program: ProgramCreateNestedOneWithoutProgramExercisesInput
  }

  export type ProgramExerciseUncheckedCreateWithoutExerciseInput = {
    id?: string
    programId: string
    day: number
    order: number
    createdAt?: Date | string
  }

  export type ProgramExerciseCreateOrConnectWithoutExerciseInput = {
    where: ProgramExerciseWhereUniqueInput
    create: XOR<ProgramExerciseCreateWithoutExerciseInput, ProgramExerciseUncheckedCreateWithoutExerciseInput>
  }

  export type ProgramExerciseCreateManyExerciseInputEnvelope = {
    data: ProgramExerciseCreateManyExerciseInput | ProgramExerciseCreateManyExerciseInput[]
    skipDuplicates?: boolean
  }

  export type ExerciseTagUpsertWithWhereUniqueWithoutExerciseInput = {
    where: ExerciseTagWhereUniqueInput
    update: XOR<ExerciseTagUpdateWithoutExerciseInput, ExerciseTagUncheckedUpdateWithoutExerciseInput>
    create: XOR<ExerciseTagCreateWithoutExerciseInput, ExerciseTagUncheckedCreateWithoutExerciseInput>
  }

  export type ExerciseTagUpdateWithWhereUniqueWithoutExerciseInput = {
    where: ExerciseTagWhereUniqueInput
    data: XOR<ExerciseTagUpdateWithoutExerciseInput, ExerciseTagUncheckedUpdateWithoutExerciseInput>
  }

  export type ExerciseTagUpdateManyWithWhereWithoutExerciseInput = {
    where: ExerciseTagScalarWhereInput
    data: XOR<ExerciseTagUpdateManyMutationInput, ExerciseTagUncheckedUpdateManyWithoutExerciseInput>
  }

  export type ExerciseTagScalarWhereInput = {
    AND?: ExerciseTagScalarWhereInput | ExerciseTagScalarWhereInput[]
    OR?: ExerciseTagScalarWhereInput[]
    NOT?: ExerciseTagScalarWhereInput | ExerciseTagScalarWhereInput[]
    id?: StringFilter<"ExerciseTag"> | string
    exerciseId?: StringFilter<"ExerciseTag"> | string
    tagId?: StringFilter<"ExerciseTag"> | string
    createdAt?: DateTimeFilter<"ExerciseTag"> | Date | string
  }

  export type PhaseExerciseUpsertWithWhereUniqueWithoutExerciseInput = {
    where: PhaseExerciseWhereUniqueInput
    update: XOR<PhaseExerciseUpdateWithoutExerciseInput, PhaseExerciseUncheckedUpdateWithoutExerciseInput>
    create: XOR<PhaseExerciseCreateWithoutExerciseInput, PhaseExerciseUncheckedCreateWithoutExerciseInput>
  }

  export type PhaseExerciseUpdateWithWhereUniqueWithoutExerciseInput = {
    where: PhaseExerciseWhereUniqueInput
    data: XOR<PhaseExerciseUpdateWithoutExerciseInput, PhaseExerciseUncheckedUpdateWithoutExerciseInput>
  }

  export type PhaseExerciseUpdateManyWithWhereWithoutExerciseInput = {
    where: PhaseExerciseScalarWhereInput
    data: XOR<PhaseExerciseUpdateManyMutationInput, PhaseExerciseUncheckedUpdateManyWithoutExerciseInput>
  }

  export type PhaseExerciseScalarWhereInput = {
    AND?: PhaseExerciseScalarWhereInput | PhaseExerciseScalarWhereInput[]
    OR?: PhaseExerciseScalarWhereInput[]
    NOT?: PhaseExerciseScalarWhereInput | PhaseExerciseScalarWhereInput[]
    id?: StringFilter<"PhaseExercise"> | string
    phaseName?: EnumCyclePhaseFilter<"PhaseExercise"> | $Enums.CyclePhase
    exerciseId?: StringFilter<"PhaseExercise"> | string
    createdAt?: DateTimeFilter<"PhaseExercise"> | Date | string
  }

  export type ProgramExerciseUpsertWithWhereUniqueWithoutExerciseInput = {
    where: ProgramExerciseWhereUniqueInput
    update: XOR<ProgramExerciseUpdateWithoutExerciseInput, ProgramExerciseUncheckedUpdateWithoutExerciseInput>
    create: XOR<ProgramExerciseCreateWithoutExerciseInput, ProgramExerciseUncheckedCreateWithoutExerciseInput>
  }

  export type ProgramExerciseUpdateWithWhereUniqueWithoutExerciseInput = {
    where: ProgramExerciseWhereUniqueInput
    data: XOR<ProgramExerciseUpdateWithoutExerciseInput, ProgramExerciseUncheckedUpdateWithoutExerciseInput>
  }

  export type ProgramExerciseUpdateManyWithWhereWithoutExerciseInput = {
    where: ProgramExerciseScalarWhereInput
    data: XOR<ProgramExerciseUpdateManyMutationInput, ProgramExerciseUncheckedUpdateManyWithoutExerciseInput>
  }

  export type ProgramExerciseScalarWhereInput = {
    AND?: ProgramExerciseScalarWhereInput | ProgramExerciseScalarWhereInput[]
    OR?: ProgramExerciseScalarWhereInput[]
    NOT?: ProgramExerciseScalarWhereInput | ProgramExerciseScalarWhereInput[]
    id?: StringFilter<"ProgramExercise"> | string
    programId?: StringFilter<"ProgramExercise"> | string
    exerciseId?: StringFilter<"ProgramExercise"> | string
    day?: IntFilter<"ProgramExercise"> | number
    order?: IntFilter<"ProgramExercise"> | number
    createdAt?: DateTimeFilter<"ProgramExercise"> | Date | string
  }

  export type ExerciseTagCreateWithoutTagInput = {
    id?: string
    createdAt?: Date | string
    exercise: ExerciseCreateNestedOneWithoutExerciseTagsInput
  }

  export type ExerciseTagUncheckedCreateWithoutTagInput = {
    id?: string
    exerciseId: string
    createdAt?: Date | string
  }

  export type ExerciseTagCreateOrConnectWithoutTagInput = {
    where: ExerciseTagWhereUniqueInput
    create: XOR<ExerciseTagCreateWithoutTagInput, ExerciseTagUncheckedCreateWithoutTagInput>
  }

  export type ExerciseTagCreateManyTagInputEnvelope = {
    data: ExerciseTagCreateManyTagInput | ExerciseTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type ExerciseTagUpsertWithWhereUniqueWithoutTagInput = {
    where: ExerciseTagWhereUniqueInput
    update: XOR<ExerciseTagUpdateWithoutTagInput, ExerciseTagUncheckedUpdateWithoutTagInput>
    create: XOR<ExerciseTagCreateWithoutTagInput, ExerciseTagUncheckedCreateWithoutTagInput>
  }

  export type ExerciseTagUpdateWithWhereUniqueWithoutTagInput = {
    where: ExerciseTagWhereUniqueInput
    data: XOR<ExerciseTagUpdateWithoutTagInput, ExerciseTagUncheckedUpdateWithoutTagInput>
  }

  export type ExerciseTagUpdateManyWithWhereWithoutTagInput = {
    where: ExerciseTagScalarWhereInput
    data: XOR<ExerciseTagUpdateManyMutationInput, ExerciseTagUncheckedUpdateManyWithoutTagInput>
  }

  export type ExerciseCreateWithoutExerciseTagsInput = {
    id?: string
    title: string
    description?: string | null
    imageUrl?: string | null
    durationMinutes?: number | null
    intensity?: $Enums.Intensity | null
    muscleZone?: $Enums.MuscleZone | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phaseExercises?: PhaseExerciseCreateNestedManyWithoutExerciseInput
    programExercises?: ProgramExerciseCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateWithoutExerciseTagsInput = {
    id?: string
    title: string
    description?: string | null
    imageUrl?: string | null
    durationMinutes?: number | null
    intensity?: $Enums.Intensity | null
    muscleZone?: $Enums.MuscleZone | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phaseExercises?: PhaseExerciseUncheckedCreateNestedManyWithoutExerciseInput
    programExercises?: ProgramExerciseUncheckedCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseCreateOrConnectWithoutExerciseTagsInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutExerciseTagsInput, ExerciseUncheckedCreateWithoutExerciseTagsInput>
  }

  export type TagCreateWithoutExerciseTagsInput = {
    id?: string
    name: string
    type: $Enums.TagType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagUncheckedCreateWithoutExerciseTagsInput = {
    id?: string
    name: string
    type: $Enums.TagType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagCreateOrConnectWithoutExerciseTagsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutExerciseTagsInput, TagUncheckedCreateWithoutExerciseTagsInput>
  }

  export type ExerciseUpsertWithoutExerciseTagsInput = {
    update: XOR<ExerciseUpdateWithoutExerciseTagsInput, ExerciseUncheckedUpdateWithoutExerciseTagsInput>
    create: XOR<ExerciseCreateWithoutExerciseTagsInput, ExerciseUncheckedCreateWithoutExerciseTagsInput>
    where?: ExerciseWhereInput
  }

  export type ExerciseUpdateToOneWithWhereWithoutExerciseTagsInput = {
    where?: ExerciseWhereInput
    data: XOR<ExerciseUpdateWithoutExerciseTagsInput, ExerciseUncheckedUpdateWithoutExerciseTagsInput>
  }

  export type ExerciseUpdateWithoutExerciseTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    intensity?: NullableEnumIntensityFieldUpdateOperationsInput | $Enums.Intensity | null
    muscleZone?: NullableEnumMuscleZoneFieldUpdateOperationsInput | $Enums.MuscleZone | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phaseExercises?: PhaseExerciseUpdateManyWithoutExerciseNestedInput
    programExercises?: ProgramExerciseUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateWithoutExerciseTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    intensity?: NullableEnumIntensityFieldUpdateOperationsInput | $Enums.Intensity | null
    muscleZone?: NullableEnumMuscleZoneFieldUpdateOperationsInput | $Enums.MuscleZone | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phaseExercises?: PhaseExerciseUncheckedUpdateManyWithoutExerciseNestedInput
    programExercises?: ProgramExerciseUncheckedUpdateManyWithoutExerciseNestedInput
  }

  export type TagUpsertWithoutExerciseTagsInput = {
    update: XOR<TagUpdateWithoutExerciseTagsInput, TagUncheckedUpdateWithoutExerciseTagsInput>
    create: XOR<TagCreateWithoutExerciseTagsInput, TagUncheckedCreateWithoutExerciseTagsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutExerciseTagsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutExerciseTagsInput, TagUncheckedUpdateWithoutExerciseTagsInput>
  }

  export type TagUpdateWithoutExerciseTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTagTypeFieldUpdateOperationsInput | $Enums.TagType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateWithoutExerciseTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTagTypeFieldUpdateOperationsInput | $Enums.TagType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseCreateWithoutPhaseExercisesInput = {
    id?: string
    title: string
    description?: string | null
    imageUrl?: string | null
    durationMinutes?: number | null
    intensity?: $Enums.Intensity | null
    muscleZone?: $Enums.MuscleZone | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exerciseTags?: ExerciseTagCreateNestedManyWithoutExerciseInput
    programExercises?: ProgramExerciseCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateWithoutPhaseExercisesInput = {
    id?: string
    title: string
    description?: string | null
    imageUrl?: string | null
    durationMinutes?: number | null
    intensity?: $Enums.Intensity | null
    muscleZone?: $Enums.MuscleZone | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exerciseTags?: ExerciseTagUncheckedCreateNestedManyWithoutExerciseInput
    programExercises?: ProgramExerciseUncheckedCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseCreateOrConnectWithoutPhaseExercisesInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutPhaseExercisesInput, ExerciseUncheckedCreateWithoutPhaseExercisesInput>
  }

  export type ExerciseUpsertWithoutPhaseExercisesInput = {
    update: XOR<ExerciseUpdateWithoutPhaseExercisesInput, ExerciseUncheckedUpdateWithoutPhaseExercisesInput>
    create: XOR<ExerciseCreateWithoutPhaseExercisesInput, ExerciseUncheckedCreateWithoutPhaseExercisesInput>
    where?: ExerciseWhereInput
  }

  export type ExerciseUpdateToOneWithWhereWithoutPhaseExercisesInput = {
    where?: ExerciseWhereInput
    data: XOR<ExerciseUpdateWithoutPhaseExercisesInput, ExerciseUncheckedUpdateWithoutPhaseExercisesInput>
  }

  export type ExerciseUpdateWithoutPhaseExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    intensity?: NullableEnumIntensityFieldUpdateOperationsInput | $Enums.Intensity | null
    muscleZone?: NullableEnumMuscleZoneFieldUpdateOperationsInput | $Enums.MuscleZone | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exerciseTags?: ExerciseTagUpdateManyWithoutExerciseNestedInput
    programExercises?: ProgramExerciseUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateWithoutPhaseExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    intensity?: NullableEnumIntensityFieldUpdateOperationsInput | $Enums.Intensity | null
    muscleZone?: NullableEnumMuscleZoneFieldUpdateOperationsInput | $Enums.MuscleZone | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exerciseTags?: ExerciseTagUncheckedUpdateManyWithoutExerciseNestedInput
    programExercises?: ProgramExerciseUncheckedUpdateManyWithoutExerciseNestedInput
  }

  export type UserCreateWithoutProgramsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    birthDate?: Date | string | null
    isMenopausal?: boolean
    objective?: string | null
    sportFrequency?: $Enums.SportFrequency | null
    profileType?: $Enums.ProfileType
    contextType?: $Enums.ContextType
    createdAt?: Date | string
    updatedAt?: Date | string
    cycles?: CycleCreateNestedManyWithoutUserInput
    moodTracks?: MoodTrackCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
    reminderSettings?: ReminderSettingsCreateNestedManyWithoutUserInput
    userFeatureFlags?: UserFeatureFlagCreateNestedManyWithoutUserInput
    userObjectives?: UserObjectiveCreateNestedManyWithoutUserInput
    profileChangeLogs?: ProfileChangeLogCreateNestedManyWithoutUserInput
    cycleProfileConfig?: CycleProfileConfigCreateNestedOneWithoutUserInput
    symptomLogs?: SymptomLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    externalSyncs?: ExternalSyncCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProgramsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    birthDate?: Date | string | null
    isMenopausal?: boolean
    objective?: string | null
    sportFrequency?: $Enums.SportFrequency | null
    profileType?: $Enums.ProfileType
    contextType?: $Enums.ContextType
    createdAt?: Date | string
    updatedAt?: Date | string
    cycles?: CycleUncheckedCreateNestedManyWithoutUserInput
    moodTracks?: MoodTrackUncheckedCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    reminderSettings?: ReminderSettingsUncheckedCreateNestedManyWithoutUserInput
    userFeatureFlags?: UserFeatureFlagUncheckedCreateNestedManyWithoutUserInput
    userObjectives?: UserObjectiveUncheckedCreateNestedManyWithoutUserInput
    profileChangeLogs?: ProfileChangeLogUncheckedCreateNestedManyWithoutUserInput
    cycleProfileConfig?: CycleProfileConfigUncheckedCreateNestedOneWithoutUserInput
    symptomLogs?: SymptomLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    externalSyncs?: ExternalSyncUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProgramsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProgramsInput, UserUncheckedCreateWithoutProgramsInput>
  }

  export type ProgramExerciseCreateWithoutProgramInput = {
    id?: string
    day: number
    order: number
    createdAt?: Date | string
    exercise: ExerciseCreateNestedOneWithoutProgramExercisesInput
  }

  export type ProgramExerciseUncheckedCreateWithoutProgramInput = {
    id?: string
    exerciseId: string
    day: number
    order: number
    createdAt?: Date | string
  }

  export type ProgramExerciseCreateOrConnectWithoutProgramInput = {
    where: ProgramExerciseWhereUniqueInput
    create: XOR<ProgramExerciseCreateWithoutProgramInput, ProgramExerciseUncheckedCreateWithoutProgramInput>
  }

  export type ProgramExerciseCreateManyProgramInputEnvelope = {
    data: ProgramExerciseCreateManyProgramInput | ProgramExerciseCreateManyProgramInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutRelatedProgramInput = {
    id?: string
    type: $Enums.NotificationType
    message: string
    date: Date | string
    relatedPhase?: string | null
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutRelatedProgramInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    message: string
    date: Date | string
    relatedPhase?: string | null
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutRelatedProgramInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutRelatedProgramInput, NotificationUncheckedCreateWithoutRelatedProgramInput>
  }

  export type NotificationCreateManyRelatedProgramInputEnvelope = {
    data: NotificationCreateManyRelatedProgramInput | NotificationCreateManyRelatedProgramInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutProgramsInput = {
    update: XOR<UserUpdateWithoutProgramsInput, UserUncheckedUpdateWithoutProgramsInput>
    create: XOR<UserCreateWithoutProgramsInput, UserUncheckedCreateWithoutProgramsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProgramsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProgramsInput, UserUncheckedUpdateWithoutProgramsInput>
  }

  export type UserUpdateWithoutProgramsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isMenopausal?: BoolFieldUpdateOperationsInput | boolean
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    sportFrequency?: NullableEnumSportFrequencyFieldUpdateOperationsInput | $Enums.SportFrequency | null
    profileType?: EnumProfileTypeFieldUpdateOperationsInput | $Enums.ProfileType
    contextType?: EnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cycles?: CycleUpdateManyWithoutUserNestedInput
    moodTracks?: MoodTrackUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
    reminderSettings?: ReminderSettingsUpdateManyWithoutUserNestedInput
    userFeatureFlags?: UserFeatureFlagUpdateManyWithoutUserNestedInput
    userObjectives?: UserObjectiveUpdateManyWithoutUserNestedInput
    profileChangeLogs?: ProfileChangeLogUpdateManyWithoutUserNestedInput
    cycleProfileConfig?: CycleProfileConfigUpdateOneWithoutUserNestedInput
    symptomLogs?: SymptomLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    externalSyncs?: ExternalSyncUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProgramsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isMenopausal?: BoolFieldUpdateOperationsInput | boolean
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    sportFrequency?: NullableEnumSportFrequencyFieldUpdateOperationsInput | $Enums.SportFrequency | null
    profileType?: EnumProfileTypeFieldUpdateOperationsInput | $Enums.ProfileType
    contextType?: EnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cycles?: CycleUncheckedUpdateManyWithoutUserNestedInput
    moodTracks?: MoodTrackUncheckedUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    reminderSettings?: ReminderSettingsUncheckedUpdateManyWithoutUserNestedInput
    userFeatureFlags?: UserFeatureFlagUncheckedUpdateManyWithoutUserNestedInput
    userObjectives?: UserObjectiveUncheckedUpdateManyWithoutUserNestedInput
    profileChangeLogs?: ProfileChangeLogUncheckedUpdateManyWithoutUserNestedInput
    cycleProfileConfig?: CycleProfileConfigUncheckedUpdateOneWithoutUserNestedInput
    symptomLogs?: SymptomLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    externalSyncs?: ExternalSyncUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProgramExerciseUpsertWithWhereUniqueWithoutProgramInput = {
    where: ProgramExerciseWhereUniqueInput
    update: XOR<ProgramExerciseUpdateWithoutProgramInput, ProgramExerciseUncheckedUpdateWithoutProgramInput>
    create: XOR<ProgramExerciseCreateWithoutProgramInput, ProgramExerciseUncheckedCreateWithoutProgramInput>
  }

  export type ProgramExerciseUpdateWithWhereUniqueWithoutProgramInput = {
    where: ProgramExerciseWhereUniqueInput
    data: XOR<ProgramExerciseUpdateWithoutProgramInput, ProgramExerciseUncheckedUpdateWithoutProgramInput>
  }

  export type ProgramExerciseUpdateManyWithWhereWithoutProgramInput = {
    where: ProgramExerciseScalarWhereInput
    data: XOR<ProgramExerciseUpdateManyMutationInput, ProgramExerciseUncheckedUpdateManyWithoutProgramInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutRelatedProgramInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutRelatedProgramInput, NotificationUncheckedUpdateWithoutRelatedProgramInput>
    create: XOR<NotificationCreateWithoutRelatedProgramInput, NotificationUncheckedCreateWithoutRelatedProgramInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutRelatedProgramInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutRelatedProgramInput, NotificationUncheckedUpdateWithoutRelatedProgramInput>
  }

  export type NotificationUpdateManyWithWhereWithoutRelatedProgramInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutRelatedProgramInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    message?: StringFilter<"Notification"> | string
    date?: DateTimeFilter<"Notification"> | Date | string
    relatedPhase?: StringNullableFilter<"Notification"> | string | null
    relatedProgramId?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type ProgramCreateWithoutProgramExercisesInput = {
    id?: string
    title: string
    goal?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProgramsInput
    notifications?: NotificationCreateNestedManyWithoutRelatedProgramInput
  }

  export type ProgramUncheckedCreateWithoutProgramExercisesInput = {
    id?: string
    userId: string
    title: string
    goal?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutRelatedProgramInput
  }

  export type ProgramCreateOrConnectWithoutProgramExercisesInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutProgramExercisesInput, ProgramUncheckedCreateWithoutProgramExercisesInput>
  }

  export type ExerciseCreateWithoutProgramExercisesInput = {
    id?: string
    title: string
    description?: string | null
    imageUrl?: string | null
    durationMinutes?: number | null
    intensity?: $Enums.Intensity | null
    muscleZone?: $Enums.MuscleZone | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exerciseTags?: ExerciseTagCreateNestedManyWithoutExerciseInput
    phaseExercises?: PhaseExerciseCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateWithoutProgramExercisesInput = {
    id?: string
    title: string
    description?: string | null
    imageUrl?: string | null
    durationMinutes?: number | null
    intensity?: $Enums.Intensity | null
    muscleZone?: $Enums.MuscleZone | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exerciseTags?: ExerciseTagUncheckedCreateNestedManyWithoutExerciseInput
    phaseExercises?: PhaseExerciseUncheckedCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseCreateOrConnectWithoutProgramExercisesInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutProgramExercisesInput, ExerciseUncheckedCreateWithoutProgramExercisesInput>
  }

  export type ProgramUpsertWithoutProgramExercisesInput = {
    update: XOR<ProgramUpdateWithoutProgramExercisesInput, ProgramUncheckedUpdateWithoutProgramExercisesInput>
    create: XOR<ProgramCreateWithoutProgramExercisesInput, ProgramUncheckedCreateWithoutProgramExercisesInput>
    where?: ProgramWhereInput
  }

  export type ProgramUpdateToOneWithWhereWithoutProgramExercisesInput = {
    where?: ProgramWhereInput
    data: XOR<ProgramUpdateWithoutProgramExercisesInput, ProgramUncheckedUpdateWithoutProgramExercisesInput>
  }

  export type ProgramUpdateWithoutProgramExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    goal?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProgramsNestedInput
    notifications?: NotificationUpdateManyWithoutRelatedProgramNestedInput
  }

  export type ProgramUncheckedUpdateWithoutProgramExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    goal?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutRelatedProgramNestedInput
  }

  export type ExerciseUpsertWithoutProgramExercisesInput = {
    update: XOR<ExerciseUpdateWithoutProgramExercisesInput, ExerciseUncheckedUpdateWithoutProgramExercisesInput>
    create: XOR<ExerciseCreateWithoutProgramExercisesInput, ExerciseUncheckedCreateWithoutProgramExercisesInput>
    where?: ExerciseWhereInput
  }

  export type ExerciseUpdateToOneWithWhereWithoutProgramExercisesInput = {
    where?: ExerciseWhereInput
    data: XOR<ExerciseUpdateWithoutProgramExercisesInput, ExerciseUncheckedUpdateWithoutProgramExercisesInput>
  }

  export type ExerciseUpdateWithoutProgramExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    intensity?: NullableEnumIntensityFieldUpdateOperationsInput | $Enums.Intensity | null
    muscleZone?: NullableEnumMuscleZoneFieldUpdateOperationsInput | $Enums.MuscleZone | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exerciseTags?: ExerciseTagUpdateManyWithoutExerciseNestedInput
    phaseExercises?: PhaseExerciseUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateWithoutProgramExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    intensity?: NullableEnumIntensityFieldUpdateOperationsInput | $Enums.Intensity | null
    muscleZone?: NullableEnumMuscleZoneFieldUpdateOperationsInput | $Enums.MuscleZone | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exerciseTags?: ExerciseTagUncheckedUpdateManyWithoutExerciseNestedInput
    phaseExercises?: PhaseExerciseUncheckedUpdateManyWithoutExerciseNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    birthDate?: Date | string | null
    isMenopausal?: boolean
    objective?: string | null
    sportFrequency?: $Enums.SportFrequency | null
    profileType?: $Enums.ProfileType
    contextType?: $Enums.ContextType
    createdAt?: Date | string
    updatedAt?: Date | string
    cycles?: CycleCreateNestedManyWithoutUserInput
    programs?: ProgramCreateNestedManyWithoutUserInput
    moodTracks?: MoodTrackCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
    reminderSettings?: ReminderSettingsCreateNestedManyWithoutUserInput
    userFeatureFlags?: UserFeatureFlagCreateNestedManyWithoutUserInput
    userObjectives?: UserObjectiveCreateNestedManyWithoutUserInput
    profileChangeLogs?: ProfileChangeLogCreateNestedManyWithoutUserInput
    cycleProfileConfig?: CycleProfileConfigCreateNestedOneWithoutUserInput
    symptomLogs?: SymptomLogCreateNestedManyWithoutUserInput
    externalSyncs?: ExternalSyncCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    birthDate?: Date | string | null
    isMenopausal?: boolean
    objective?: string | null
    sportFrequency?: $Enums.SportFrequency | null
    profileType?: $Enums.ProfileType
    contextType?: $Enums.ContextType
    createdAt?: Date | string
    updatedAt?: Date | string
    cycles?: CycleUncheckedCreateNestedManyWithoutUserInput
    programs?: ProgramUncheckedCreateNestedManyWithoutUserInput
    moodTracks?: MoodTrackUncheckedCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    reminderSettings?: ReminderSettingsUncheckedCreateNestedManyWithoutUserInput
    userFeatureFlags?: UserFeatureFlagUncheckedCreateNestedManyWithoutUserInput
    userObjectives?: UserObjectiveUncheckedCreateNestedManyWithoutUserInput
    profileChangeLogs?: ProfileChangeLogUncheckedCreateNestedManyWithoutUserInput
    cycleProfileConfig?: CycleProfileConfigUncheckedCreateNestedOneWithoutUserInput
    symptomLogs?: SymptomLogUncheckedCreateNestedManyWithoutUserInput
    externalSyncs?: ExternalSyncUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type ProgramCreateWithoutNotificationsInput = {
    id?: string
    title: string
    goal?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProgramsInput
    programExercises?: ProgramExerciseCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateWithoutNotificationsInput = {
    id?: string
    userId: string
    title: string
    goal?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    programExercises?: ProgramExerciseUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramCreateOrConnectWithoutNotificationsInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutNotificationsInput, ProgramUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isMenopausal?: BoolFieldUpdateOperationsInput | boolean
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    sportFrequency?: NullableEnumSportFrequencyFieldUpdateOperationsInput | $Enums.SportFrequency | null
    profileType?: EnumProfileTypeFieldUpdateOperationsInput | $Enums.ProfileType
    contextType?: EnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cycles?: CycleUpdateManyWithoutUserNestedInput
    programs?: ProgramUpdateManyWithoutUserNestedInput
    moodTracks?: MoodTrackUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
    reminderSettings?: ReminderSettingsUpdateManyWithoutUserNestedInput
    userFeatureFlags?: UserFeatureFlagUpdateManyWithoutUserNestedInput
    userObjectives?: UserObjectiveUpdateManyWithoutUserNestedInput
    profileChangeLogs?: ProfileChangeLogUpdateManyWithoutUserNestedInput
    cycleProfileConfig?: CycleProfileConfigUpdateOneWithoutUserNestedInput
    symptomLogs?: SymptomLogUpdateManyWithoutUserNestedInput
    externalSyncs?: ExternalSyncUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isMenopausal?: BoolFieldUpdateOperationsInput | boolean
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    sportFrequency?: NullableEnumSportFrequencyFieldUpdateOperationsInput | $Enums.SportFrequency | null
    profileType?: EnumProfileTypeFieldUpdateOperationsInput | $Enums.ProfileType
    contextType?: EnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cycles?: CycleUncheckedUpdateManyWithoutUserNestedInput
    programs?: ProgramUncheckedUpdateManyWithoutUserNestedInput
    moodTracks?: MoodTrackUncheckedUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    reminderSettings?: ReminderSettingsUncheckedUpdateManyWithoutUserNestedInput
    userFeatureFlags?: UserFeatureFlagUncheckedUpdateManyWithoutUserNestedInput
    userObjectives?: UserObjectiveUncheckedUpdateManyWithoutUserNestedInput
    profileChangeLogs?: ProfileChangeLogUncheckedUpdateManyWithoutUserNestedInput
    cycleProfileConfig?: CycleProfileConfigUncheckedUpdateOneWithoutUserNestedInput
    symptomLogs?: SymptomLogUncheckedUpdateManyWithoutUserNestedInput
    externalSyncs?: ExternalSyncUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProgramUpsertWithoutNotificationsInput = {
    update: XOR<ProgramUpdateWithoutNotificationsInput, ProgramUncheckedUpdateWithoutNotificationsInput>
    create: XOR<ProgramCreateWithoutNotificationsInput, ProgramUncheckedCreateWithoutNotificationsInput>
    where?: ProgramWhereInput
  }

  export type ProgramUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: ProgramWhereInput
    data: XOR<ProgramUpdateWithoutNotificationsInput, ProgramUncheckedUpdateWithoutNotificationsInput>
  }

  export type ProgramUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    goal?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProgramsNestedInput
    programExercises?: ProgramExerciseUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    goal?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programExercises?: ProgramExerciseUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type UserCreateWithoutExternalSyncsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    birthDate?: Date | string | null
    isMenopausal?: boolean
    objective?: string | null
    sportFrequency?: $Enums.SportFrequency | null
    profileType?: $Enums.ProfileType
    contextType?: $Enums.ContextType
    createdAt?: Date | string
    updatedAt?: Date | string
    cycles?: CycleCreateNestedManyWithoutUserInput
    programs?: ProgramCreateNestedManyWithoutUserInput
    moodTracks?: MoodTrackCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
    reminderSettings?: ReminderSettingsCreateNestedManyWithoutUserInput
    userFeatureFlags?: UserFeatureFlagCreateNestedManyWithoutUserInput
    userObjectives?: UserObjectiveCreateNestedManyWithoutUserInput
    profileChangeLogs?: ProfileChangeLogCreateNestedManyWithoutUserInput
    cycleProfileConfig?: CycleProfileConfigCreateNestedOneWithoutUserInput
    symptomLogs?: SymptomLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutExternalSyncsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    birthDate?: Date | string | null
    isMenopausal?: boolean
    objective?: string | null
    sportFrequency?: $Enums.SportFrequency | null
    profileType?: $Enums.ProfileType
    contextType?: $Enums.ContextType
    createdAt?: Date | string
    updatedAt?: Date | string
    cycles?: CycleUncheckedCreateNestedManyWithoutUserInput
    programs?: ProgramUncheckedCreateNestedManyWithoutUserInput
    moodTracks?: MoodTrackUncheckedCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    reminderSettings?: ReminderSettingsUncheckedCreateNestedManyWithoutUserInput
    userFeatureFlags?: UserFeatureFlagUncheckedCreateNestedManyWithoutUserInput
    userObjectives?: UserObjectiveUncheckedCreateNestedManyWithoutUserInput
    profileChangeLogs?: ProfileChangeLogUncheckedCreateNestedManyWithoutUserInput
    cycleProfileConfig?: CycleProfileConfigUncheckedCreateNestedOneWithoutUserInput
    symptomLogs?: SymptomLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutExternalSyncsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExternalSyncsInput, UserUncheckedCreateWithoutExternalSyncsInput>
  }

  export type UserUpsertWithoutExternalSyncsInput = {
    update: XOR<UserUpdateWithoutExternalSyncsInput, UserUncheckedUpdateWithoutExternalSyncsInput>
    create: XOR<UserCreateWithoutExternalSyncsInput, UserUncheckedCreateWithoutExternalSyncsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExternalSyncsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExternalSyncsInput, UserUncheckedUpdateWithoutExternalSyncsInput>
  }

  export type UserUpdateWithoutExternalSyncsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isMenopausal?: BoolFieldUpdateOperationsInput | boolean
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    sportFrequency?: NullableEnumSportFrequencyFieldUpdateOperationsInput | $Enums.SportFrequency | null
    profileType?: EnumProfileTypeFieldUpdateOperationsInput | $Enums.ProfileType
    contextType?: EnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cycles?: CycleUpdateManyWithoutUserNestedInput
    programs?: ProgramUpdateManyWithoutUserNestedInput
    moodTracks?: MoodTrackUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
    reminderSettings?: ReminderSettingsUpdateManyWithoutUserNestedInput
    userFeatureFlags?: UserFeatureFlagUpdateManyWithoutUserNestedInput
    userObjectives?: UserObjectiveUpdateManyWithoutUserNestedInput
    profileChangeLogs?: ProfileChangeLogUpdateManyWithoutUserNestedInput
    cycleProfileConfig?: CycleProfileConfigUpdateOneWithoutUserNestedInput
    symptomLogs?: SymptomLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutExternalSyncsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isMenopausal?: BoolFieldUpdateOperationsInput | boolean
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    sportFrequency?: NullableEnumSportFrequencyFieldUpdateOperationsInput | $Enums.SportFrequency | null
    profileType?: EnumProfileTypeFieldUpdateOperationsInput | $Enums.ProfileType
    contextType?: EnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cycles?: CycleUncheckedUpdateManyWithoutUserNestedInput
    programs?: ProgramUncheckedUpdateManyWithoutUserNestedInput
    moodTracks?: MoodTrackUncheckedUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    reminderSettings?: ReminderSettingsUncheckedUpdateManyWithoutUserNestedInput
    userFeatureFlags?: UserFeatureFlagUncheckedUpdateManyWithoutUserNestedInput
    userObjectives?: UserObjectiveUncheckedUpdateManyWithoutUserNestedInput
    profileChangeLogs?: ProfileChangeLogUncheckedUpdateManyWithoutUserNestedInput
    cycleProfileConfig?: CycleProfileConfigUncheckedUpdateOneWithoutUserNestedInput
    symptomLogs?: SymptomLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutJournalEntriesInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    birthDate?: Date | string | null
    isMenopausal?: boolean
    objective?: string | null
    sportFrequency?: $Enums.SportFrequency | null
    profileType?: $Enums.ProfileType
    contextType?: $Enums.ContextType
    createdAt?: Date | string
    updatedAt?: Date | string
    cycles?: CycleCreateNestedManyWithoutUserInput
    programs?: ProgramCreateNestedManyWithoutUserInput
    moodTracks?: MoodTrackCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
    reminderSettings?: ReminderSettingsCreateNestedManyWithoutUserInput
    userFeatureFlags?: UserFeatureFlagCreateNestedManyWithoutUserInput
    userObjectives?: UserObjectiveCreateNestedManyWithoutUserInput
    profileChangeLogs?: ProfileChangeLogCreateNestedManyWithoutUserInput
    cycleProfileConfig?: CycleProfileConfigCreateNestedOneWithoutUserInput
    symptomLogs?: SymptomLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    externalSyncs?: ExternalSyncCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutJournalEntriesInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    birthDate?: Date | string | null
    isMenopausal?: boolean
    objective?: string | null
    sportFrequency?: $Enums.SportFrequency | null
    profileType?: $Enums.ProfileType
    contextType?: $Enums.ContextType
    createdAt?: Date | string
    updatedAt?: Date | string
    cycles?: CycleUncheckedCreateNestedManyWithoutUserInput
    programs?: ProgramUncheckedCreateNestedManyWithoutUserInput
    moodTracks?: MoodTrackUncheckedCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    reminderSettings?: ReminderSettingsUncheckedCreateNestedManyWithoutUserInput
    userFeatureFlags?: UserFeatureFlagUncheckedCreateNestedManyWithoutUserInput
    userObjectives?: UserObjectiveUncheckedCreateNestedManyWithoutUserInput
    profileChangeLogs?: ProfileChangeLogUncheckedCreateNestedManyWithoutUserInput
    cycleProfileConfig?: CycleProfileConfigUncheckedCreateNestedOneWithoutUserInput
    symptomLogs?: SymptomLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    externalSyncs?: ExternalSyncUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutJournalEntriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutJournalEntriesInput, UserUncheckedCreateWithoutJournalEntriesInput>
  }

  export type UserUpsertWithoutJournalEntriesInput = {
    update: XOR<UserUpdateWithoutJournalEntriesInput, UserUncheckedUpdateWithoutJournalEntriesInput>
    create: XOR<UserCreateWithoutJournalEntriesInput, UserUncheckedCreateWithoutJournalEntriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutJournalEntriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutJournalEntriesInput, UserUncheckedUpdateWithoutJournalEntriesInput>
  }

  export type UserUpdateWithoutJournalEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isMenopausal?: BoolFieldUpdateOperationsInput | boolean
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    sportFrequency?: NullableEnumSportFrequencyFieldUpdateOperationsInput | $Enums.SportFrequency | null
    profileType?: EnumProfileTypeFieldUpdateOperationsInput | $Enums.ProfileType
    contextType?: EnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cycles?: CycleUpdateManyWithoutUserNestedInput
    programs?: ProgramUpdateManyWithoutUserNestedInput
    moodTracks?: MoodTrackUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
    reminderSettings?: ReminderSettingsUpdateManyWithoutUserNestedInput
    userFeatureFlags?: UserFeatureFlagUpdateManyWithoutUserNestedInput
    userObjectives?: UserObjectiveUpdateManyWithoutUserNestedInput
    profileChangeLogs?: ProfileChangeLogUpdateManyWithoutUserNestedInput
    cycleProfileConfig?: CycleProfileConfigUpdateOneWithoutUserNestedInput
    symptomLogs?: SymptomLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    externalSyncs?: ExternalSyncUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutJournalEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isMenopausal?: BoolFieldUpdateOperationsInput | boolean
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    sportFrequency?: NullableEnumSportFrequencyFieldUpdateOperationsInput | $Enums.SportFrequency | null
    profileType?: EnumProfileTypeFieldUpdateOperationsInput | $Enums.ProfileType
    contextType?: EnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cycles?: CycleUncheckedUpdateManyWithoutUserNestedInput
    programs?: ProgramUncheckedUpdateManyWithoutUserNestedInput
    moodTracks?: MoodTrackUncheckedUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    reminderSettings?: ReminderSettingsUncheckedUpdateManyWithoutUserNestedInput
    userFeatureFlags?: UserFeatureFlagUncheckedUpdateManyWithoutUserNestedInput
    userObjectives?: UserObjectiveUncheckedUpdateManyWithoutUserNestedInput
    profileChangeLogs?: ProfileChangeLogUncheckedUpdateManyWithoutUserNestedInput
    cycleProfileConfig?: CycleProfileConfigUncheckedUpdateOneWithoutUserNestedInput
    symptomLogs?: SymptomLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    externalSyncs?: ExternalSyncUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    birthDate?: Date | string | null
    isMenopausal?: boolean
    objective?: string | null
    sportFrequency?: $Enums.SportFrequency | null
    profileType?: $Enums.ProfileType
    contextType?: $Enums.ContextType
    createdAt?: Date | string
    updatedAt?: Date | string
    cycles?: CycleCreateNestedManyWithoutUserInput
    programs?: ProgramCreateNestedManyWithoutUserInput
    moodTracks?: MoodTrackCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
    reminderSettings?: ReminderSettingsCreateNestedManyWithoutUserInput
    userFeatureFlags?: UserFeatureFlagCreateNestedManyWithoutUserInput
    userObjectives?: UserObjectiveCreateNestedManyWithoutUserInput
    profileChangeLogs?: ProfileChangeLogCreateNestedManyWithoutUserInput
    cycleProfileConfig?: CycleProfileConfigCreateNestedOneWithoutUserInput
    symptomLogs?: SymptomLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    externalSyncs?: ExternalSyncCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    birthDate?: Date | string | null
    isMenopausal?: boolean
    objective?: string | null
    sportFrequency?: $Enums.SportFrequency | null
    profileType?: $Enums.ProfileType
    contextType?: $Enums.ContextType
    createdAt?: Date | string
    updatedAt?: Date | string
    cycles?: CycleUncheckedCreateNestedManyWithoutUserInput
    programs?: ProgramUncheckedCreateNestedManyWithoutUserInput
    moodTracks?: MoodTrackUncheckedCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    reminderSettings?: ReminderSettingsUncheckedCreateNestedManyWithoutUserInput
    userFeatureFlags?: UserFeatureFlagUncheckedCreateNestedManyWithoutUserInput
    userObjectives?: UserObjectiveUncheckedCreateNestedManyWithoutUserInput
    profileChangeLogs?: ProfileChangeLogUncheckedCreateNestedManyWithoutUserInput
    cycleProfileConfig?: CycleProfileConfigUncheckedCreateNestedOneWithoutUserInput
    symptomLogs?: SymptomLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    externalSyncs?: ExternalSyncUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isMenopausal?: BoolFieldUpdateOperationsInput | boolean
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    sportFrequency?: NullableEnumSportFrequencyFieldUpdateOperationsInput | $Enums.SportFrequency | null
    profileType?: EnumProfileTypeFieldUpdateOperationsInput | $Enums.ProfileType
    contextType?: EnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cycles?: CycleUpdateManyWithoutUserNestedInput
    programs?: ProgramUpdateManyWithoutUserNestedInput
    moodTracks?: MoodTrackUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
    reminderSettings?: ReminderSettingsUpdateManyWithoutUserNestedInput
    userFeatureFlags?: UserFeatureFlagUpdateManyWithoutUserNestedInput
    userObjectives?: UserObjectiveUpdateManyWithoutUserNestedInput
    profileChangeLogs?: ProfileChangeLogUpdateManyWithoutUserNestedInput
    cycleProfileConfig?: CycleProfileConfigUpdateOneWithoutUserNestedInput
    symptomLogs?: SymptomLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    externalSyncs?: ExternalSyncUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isMenopausal?: BoolFieldUpdateOperationsInput | boolean
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    sportFrequency?: NullableEnumSportFrequencyFieldUpdateOperationsInput | $Enums.SportFrequency | null
    profileType?: EnumProfileTypeFieldUpdateOperationsInput | $Enums.ProfileType
    contextType?: EnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cycles?: CycleUncheckedUpdateManyWithoutUserNestedInput
    programs?: ProgramUncheckedUpdateManyWithoutUserNestedInput
    moodTracks?: MoodTrackUncheckedUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    reminderSettings?: ReminderSettingsUncheckedUpdateManyWithoutUserNestedInput
    userFeatureFlags?: UserFeatureFlagUncheckedUpdateManyWithoutUserNestedInput
    userObjectives?: UserObjectiveUncheckedUpdateManyWithoutUserNestedInput
    profileChangeLogs?: ProfileChangeLogUncheckedUpdateManyWithoutUserNestedInput
    cycleProfileConfig?: CycleProfileConfigUncheckedUpdateOneWithoutUserNestedInput
    symptomLogs?: SymptomLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    externalSyncs?: ExternalSyncUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutLogsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    birthDate?: Date | string | null
    isMenopausal?: boolean
    objective?: string | null
    sportFrequency?: $Enums.SportFrequency | null
    profileType?: $Enums.ProfileType
    contextType?: $Enums.ContextType
    createdAt?: Date | string
    updatedAt?: Date | string
    cycles?: CycleCreateNestedManyWithoutUserInput
    programs?: ProgramCreateNestedManyWithoutUserInput
    moodTracks?: MoodTrackCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
    reminderSettings?: ReminderSettingsCreateNestedManyWithoutUserInput
    userFeatureFlags?: UserFeatureFlagCreateNestedManyWithoutUserInput
    userObjectives?: UserObjectiveCreateNestedManyWithoutUserInput
    profileChangeLogs?: ProfileChangeLogCreateNestedManyWithoutUserInput
    cycleProfileConfig?: CycleProfileConfigCreateNestedOneWithoutUserInput
    symptomLogs?: SymptomLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    externalSyncs?: ExternalSyncCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLogsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    birthDate?: Date | string | null
    isMenopausal?: boolean
    objective?: string | null
    sportFrequency?: $Enums.SportFrequency | null
    profileType?: $Enums.ProfileType
    contextType?: $Enums.ContextType
    createdAt?: Date | string
    updatedAt?: Date | string
    cycles?: CycleUncheckedCreateNestedManyWithoutUserInput
    programs?: ProgramUncheckedCreateNestedManyWithoutUserInput
    moodTracks?: MoodTrackUncheckedCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    reminderSettings?: ReminderSettingsUncheckedCreateNestedManyWithoutUserInput
    userFeatureFlags?: UserFeatureFlagUncheckedCreateNestedManyWithoutUserInput
    userObjectives?: UserObjectiveUncheckedCreateNestedManyWithoutUserInput
    profileChangeLogs?: ProfileChangeLogUncheckedCreateNestedManyWithoutUserInput
    cycleProfileConfig?: CycleProfileConfigUncheckedCreateNestedOneWithoutUserInput
    symptomLogs?: SymptomLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    externalSyncs?: ExternalSyncUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
  }

  export type UserUpsertWithoutLogsInput = {
    update: XOR<UserUpdateWithoutLogsInput, UserUncheckedUpdateWithoutLogsInput>
    create: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLogsInput, UserUncheckedUpdateWithoutLogsInput>
  }

  export type UserUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isMenopausal?: BoolFieldUpdateOperationsInput | boolean
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    sportFrequency?: NullableEnumSportFrequencyFieldUpdateOperationsInput | $Enums.SportFrequency | null
    profileType?: EnumProfileTypeFieldUpdateOperationsInput | $Enums.ProfileType
    contextType?: EnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cycles?: CycleUpdateManyWithoutUserNestedInput
    programs?: ProgramUpdateManyWithoutUserNestedInput
    moodTracks?: MoodTrackUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
    reminderSettings?: ReminderSettingsUpdateManyWithoutUserNestedInput
    userFeatureFlags?: UserFeatureFlagUpdateManyWithoutUserNestedInput
    userObjectives?: UserObjectiveUpdateManyWithoutUserNestedInput
    profileChangeLogs?: ProfileChangeLogUpdateManyWithoutUserNestedInput
    cycleProfileConfig?: CycleProfileConfigUpdateOneWithoutUserNestedInput
    symptomLogs?: SymptomLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    externalSyncs?: ExternalSyncUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isMenopausal?: BoolFieldUpdateOperationsInput | boolean
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    sportFrequency?: NullableEnumSportFrequencyFieldUpdateOperationsInput | $Enums.SportFrequency | null
    profileType?: EnumProfileTypeFieldUpdateOperationsInput | $Enums.ProfileType
    contextType?: EnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cycles?: CycleUncheckedUpdateManyWithoutUserNestedInput
    programs?: ProgramUncheckedUpdateManyWithoutUserNestedInput
    moodTracks?: MoodTrackUncheckedUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    reminderSettings?: ReminderSettingsUncheckedUpdateManyWithoutUserNestedInput
    userFeatureFlags?: UserFeatureFlagUncheckedUpdateManyWithoutUserNestedInput
    userObjectives?: UserObjectiveUncheckedUpdateManyWithoutUserNestedInput
    profileChangeLogs?: ProfileChangeLogUncheckedUpdateManyWithoutUserNestedInput
    cycleProfileConfig?: CycleProfileConfigUncheckedUpdateOneWithoutUserNestedInput
    symptomLogs?: SymptomLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    externalSyncs?: ExternalSyncUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    birthDate?: Date | string | null
    isMenopausal?: boolean
    objective?: string | null
    sportFrequency?: $Enums.SportFrequency | null
    profileType?: $Enums.ProfileType
    contextType?: $Enums.ContextType
    createdAt?: Date | string
    updatedAt?: Date | string
    cycles?: CycleCreateNestedManyWithoutUserInput
    programs?: ProgramCreateNestedManyWithoutUserInput
    moodTracks?: MoodTrackCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
    reminderSettings?: ReminderSettingsCreateNestedManyWithoutUserInput
    userFeatureFlags?: UserFeatureFlagCreateNestedManyWithoutUserInput
    userObjectives?: UserObjectiveCreateNestedManyWithoutUserInput
    profileChangeLogs?: ProfileChangeLogCreateNestedManyWithoutUserInput
    cycleProfileConfig?: CycleProfileConfigCreateNestedOneWithoutUserInput
    symptomLogs?: SymptomLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    externalSyncs?: ExternalSyncCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    birthDate?: Date | string | null
    isMenopausal?: boolean
    objective?: string | null
    sportFrequency?: $Enums.SportFrequency | null
    profileType?: $Enums.ProfileType
    contextType?: $Enums.ContextType
    createdAt?: Date | string
    updatedAt?: Date | string
    cycles?: CycleUncheckedCreateNestedManyWithoutUserInput
    programs?: ProgramUncheckedCreateNestedManyWithoutUserInput
    moodTracks?: MoodTrackUncheckedCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    reminderSettings?: ReminderSettingsUncheckedCreateNestedManyWithoutUserInput
    userFeatureFlags?: UserFeatureFlagUncheckedCreateNestedManyWithoutUserInput
    userObjectives?: UserObjectiveUncheckedCreateNestedManyWithoutUserInput
    profileChangeLogs?: ProfileChangeLogUncheckedCreateNestedManyWithoutUserInput
    cycleProfileConfig?: CycleProfileConfigUncheckedCreateNestedOneWithoutUserInput
    symptomLogs?: SymptomLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    externalSyncs?: ExternalSyncUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRefreshTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
  }

  export type UserUpsertWithoutRefreshTokensInput = {
    update: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isMenopausal?: BoolFieldUpdateOperationsInput | boolean
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    sportFrequency?: NullableEnumSportFrequencyFieldUpdateOperationsInput | $Enums.SportFrequency | null
    profileType?: EnumProfileTypeFieldUpdateOperationsInput | $Enums.ProfileType
    contextType?: EnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cycles?: CycleUpdateManyWithoutUserNestedInput
    programs?: ProgramUpdateManyWithoutUserNestedInput
    moodTracks?: MoodTrackUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
    reminderSettings?: ReminderSettingsUpdateManyWithoutUserNestedInput
    userFeatureFlags?: UserFeatureFlagUpdateManyWithoutUserNestedInput
    userObjectives?: UserObjectiveUpdateManyWithoutUserNestedInput
    profileChangeLogs?: ProfileChangeLogUpdateManyWithoutUserNestedInput
    cycleProfileConfig?: CycleProfileConfigUpdateOneWithoutUserNestedInput
    symptomLogs?: SymptomLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    externalSyncs?: ExternalSyncUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isMenopausal?: BoolFieldUpdateOperationsInput | boolean
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    sportFrequency?: NullableEnumSportFrequencyFieldUpdateOperationsInput | $Enums.SportFrequency | null
    profileType?: EnumProfileTypeFieldUpdateOperationsInput | $Enums.ProfileType
    contextType?: EnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cycles?: CycleUncheckedUpdateManyWithoutUserNestedInput
    programs?: ProgramUncheckedUpdateManyWithoutUserNestedInput
    moodTracks?: MoodTrackUncheckedUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    reminderSettings?: ReminderSettingsUncheckedUpdateManyWithoutUserNestedInput
    userFeatureFlags?: UserFeatureFlagUncheckedUpdateManyWithoutUserNestedInput
    userObjectives?: UserObjectiveUncheckedUpdateManyWithoutUserNestedInput
    profileChangeLogs?: ProfileChangeLogUncheckedUpdateManyWithoutUserNestedInput
    cycleProfileConfig?: CycleProfileConfigUncheckedUpdateOneWithoutUserNestedInput
    symptomLogs?: SymptomLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    externalSyncs?: ExternalSyncUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAuthSessionsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    birthDate?: Date | string | null
    isMenopausal?: boolean
    objective?: string | null
    sportFrequency?: $Enums.SportFrequency | null
    profileType?: $Enums.ProfileType
    contextType?: $Enums.ContextType
    createdAt?: Date | string
    updatedAt?: Date | string
    cycles?: CycleCreateNestedManyWithoutUserInput
    programs?: ProgramCreateNestedManyWithoutUserInput
    moodTracks?: MoodTrackCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
    reminderSettings?: ReminderSettingsCreateNestedManyWithoutUserInput
    userFeatureFlags?: UserFeatureFlagCreateNestedManyWithoutUserInput
    userObjectives?: UserObjectiveCreateNestedManyWithoutUserInput
    profileChangeLogs?: ProfileChangeLogCreateNestedManyWithoutUserInput
    cycleProfileConfig?: CycleProfileConfigCreateNestedOneWithoutUserInput
    symptomLogs?: SymptomLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    externalSyncs?: ExternalSyncCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuthSessionsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    birthDate?: Date | string | null
    isMenopausal?: boolean
    objective?: string | null
    sportFrequency?: $Enums.SportFrequency | null
    profileType?: $Enums.ProfileType
    contextType?: $Enums.ContextType
    createdAt?: Date | string
    updatedAt?: Date | string
    cycles?: CycleUncheckedCreateNestedManyWithoutUserInput
    programs?: ProgramUncheckedCreateNestedManyWithoutUserInput
    moodTracks?: MoodTrackUncheckedCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    reminderSettings?: ReminderSettingsUncheckedCreateNestedManyWithoutUserInput
    userFeatureFlags?: UserFeatureFlagUncheckedCreateNestedManyWithoutUserInput
    userObjectives?: UserObjectiveUncheckedCreateNestedManyWithoutUserInput
    profileChangeLogs?: ProfileChangeLogUncheckedCreateNestedManyWithoutUserInput
    cycleProfileConfig?: CycleProfileConfigUncheckedCreateNestedOneWithoutUserInput
    symptomLogs?: SymptomLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    externalSyncs?: ExternalSyncUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuthSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuthSessionsInput, UserUncheckedCreateWithoutAuthSessionsInput>
  }

  export type UserUpsertWithoutAuthSessionsInput = {
    update: XOR<UserUpdateWithoutAuthSessionsInput, UserUncheckedUpdateWithoutAuthSessionsInput>
    create: XOR<UserCreateWithoutAuthSessionsInput, UserUncheckedCreateWithoutAuthSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuthSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuthSessionsInput, UserUncheckedUpdateWithoutAuthSessionsInput>
  }

  export type UserUpdateWithoutAuthSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isMenopausal?: BoolFieldUpdateOperationsInput | boolean
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    sportFrequency?: NullableEnumSportFrequencyFieldUpdateOperationsInput | $Enums.SportFrequency | null
    profileType?: EnumProfileTypeFieldUpdateOperationsInput | $Enums.ProfileType
    contextType?: EnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cycles?: CycleUpdateManyWithoutUserNestedInput
    programs?: ProgramUpdateManyWithoutUserNestedInput
    moodTracks?: MoodTrackUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
    reminderSettings?: ReminderSettingsUpdateManyWithoutUserNestedInput
    userFeatureFlags?: UserFeatureFlagUpdateManyWithoutUserNestedInput
    userObjectives?: UserObjectiveUpdateManyWithoutUserNestedInput
    profileChangeLogs?: ProfileChangeLogUpdateManyWithoutUserNestedInput
    cycleProfileConfig?: CycleProfileConfigUpdateOneWithoutUserNestedInput
    symptomLogs?: SymptomLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    externalSyncs?: ExternalSyncUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuthSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isMenopausal?: BoolFieldUpdateOperationsInput | boolean
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    sportFrequency?: NullableEnumSportFrequencyFieldUpdateOperationsInput | $Enums.SportFrequency | null
    profileType?: EnumProfileTypeFieldUpdateOperationsInput | $Enums.ProfileType
    contextType?: EnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cycles?: CycleUncheckedUpdateManyWithoutUserNestedInput
    programs?: ProgramUncheckedUpdateManyWithoutUserNestedInput
    moodTracks?: MoodTrackUncheckedUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    reminderSettings?: ReminderSettingsUncheckedUpdateManyWithoutUserNestedInput
    userFeatureFlags?: UserFeatureFlagUncheckedUpdateManyWithoutUserNestedInput
    userObjectives?: UserObjectiveUncheckedUpdateManyWithoutUserNestedInput
    profileChangeLogs?: ProfileChangeLogUncheckedUpdateManyWithoutUserNestedInput
    cycleProfileConfig?: CycleProfileConfigUncheckedUpdateOneWithoutUserNestedInput
    symptomLogs?: SymptomLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    externalSyncs?: ExternalSyncUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutMoodTracksInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    birthDate?: Date | string | null
    isMenopausal?: boolean
    objective?: string | null
    sportFrequency?: $Enums.SportFrequency | null
    profileType?: $Enums.ProfileType
    contextType?: $Enums.ContextType
    createdAt?: Date | string
    updatedAt?: Date | string
    cycles?: CycleCreateNestedManyWithoutUserInput
    programs?: ProgramCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
    reminderSettings?: ReminderSettingsCreateNestedManyWithoutUserInput
    userFeatureFlags?: UserFeatureFlagCreateNestedManyWithoutUserInput
    userObjectives?: UserObjectiveCreateNestedManyWithoutUserInput
    profileChangeLogs?: ProfileChangeLogCreateNestedManyWithoutUserInput
    cycleProfileConfig?: CycleProfileConfigCreateNestedOneWithoutUserInput
    symptomLogs?: SymptomLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    externalSyncs?: ExternalSyncCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMoodTracksInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    birthDate?: Date | string | null
    isMenopausal?: boolean
    objective?: string | null
    sportFrequency?: $Enums.SportFrequency | null
    profileType?: $Enums.ProfileType
    contextType?: $Enums.ContextType
    createdAt?: Date | string
    updatedAt?: Date | string
    cycles?: CycleUncheckedCreateNestedManyWithoutUserInput
    programs?: ProgramUncheckedCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    reminderSettings?: ReminderSettingsUncheckedCreateNestedManyWithoutUserInput
    userFeatureFlags?: UserFeatureFlagUncheckedCreateNestedManyWithoutUserInput
    userObjectives?: UserObjectiveUncheckedCreateNestedManyWithoutUserInput
    profileChangeLogs?: ProfileChangeLogUncheckedCreateNestedManyWithoutUserInput
    cycleProfileConfig?: CycleProfileConfigUncheckedCreateNestedOneWithoutUserInput
    symptomLogs?: SymptomLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    externalSyncs?: ExternalSyncUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMoodTracksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMoodTracksInput, UserUncheckedCreateWithoutMoodTracksInput>
  }

  export type UserUpsertWithoutMoodTracksInput = {
    update: XOR<UserUpdateWithoutMoodTracksInput, UserUncheckedUpdateWithoutMoodTracksInput>
    create: XOR<UserCreateWithoutMoodTracksInput, UserUncheckedCreateWithoutMoodTracksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMoodTracksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMoodTracksInput, UserUncheckedUpdateWithoutMoodTracksInput>
  }

  export type UserUpdateWithoutMoodTracksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isMenopausal?: BoolFieldUpdateOperationsInput | boolean
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    sportFrequency?: NullableEnumSportFrequencyFieldUpdateOperationsInput | $Enums.SportFrequency | null
    profileType?: EnumProfileTypeFieldUpdateOperationsInput | $Enums.ProfileType
    contextType?: EnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cycles?: CycleUpdateManyWithoutUserNestedInput
    programs?: ProgramUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
    reminderSettings?: ReminderSettingsUpdateManyWithoutUserNestedInput
    userFeatureFlags?: UserFeatureFlagUpdateManyWithoutUserNestedInput
    userObjectives?: UserObjectiveUpdateManyWithoutUserNestedInput
    profileChangeLogs?: ProfileChangeLogUpdateManyWithoutUserNestedInput
    cycleProfileConfig?: CycleProfileConfigUpdateOneWithoutUserNestedInput
    symptomLogs?: SymptomLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    externalSyncs?: ExternalSyncUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMoodTracksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isMenopausal?: BoolFieldUpdateOperationsInput | boolean
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    sportFrequency?: NullableEnumSportFrequencyFieldUpdateOperationsInput | $Enums.SportFrequency | null
    profileType?: EnumProfileTypeFieldUpdateOperationsInput | $Enums.ProfileType
    contextType?: EnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cycles?: CycleUncheckedUpdateManyWithoutUserNestedInput
    programs?: ProgramUncheckedUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    reminderSettings?: ReminderSettingsUncheckedUpdateManyWithoutUserNestedInput
    userFeatureFlags?: UserFeatureFlagUncheckedUpdateManyWithoutUserNestedInput
    userObjectives?: UserObjectiveUncheckedUpdateManyWithoutUserNestedInput
    profileChangeLogs?: ProfileChangeLogUncheckedUpdateManyWithoutUserNestedInput
    cycleProfileConfig?: CycleProfileConfigUncheckedUpdateOneWithoutUserNestedInput
    symptomLogs?: SymptomLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    externalSyncs?: ExternalSyncUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSymptomLogsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    birthDate?: Date | string | null
    isMenopausal?: boolean
    objective?: string | null
    sportFrequency?: $Enums.SportFrequency | null
    profileType?: $Enums.ProfileType
    contextType?: $Enums.ContextType
    createdAt?: Date | string
    updatedAt?: Date | string
    cycles?: CycleCreateNestedManyWithoutUserInput
    programs?: ProgramCreateNestedManyWithoutUserInput
    moodTracks?: MoodTrackCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
    reminderSettings?: ReminderSettingsCreateNestedManyWithoutUserInput
    userFeatureFlags?: UserFeatureFlagCreateNestedManyWithoutUserInput
    userObjectives?: UserObjectiveCreateNestedManyWithoutUserInput
    profileChangeLogs?: ProfileChangeLogCreateNestedManyWithoutUserInput
    cycleProfileConfig?: CycleProfileConfigCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    externalSyncs?: ExternalSyncCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSymptomLogsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    birthDate?: Date | string | null
    isMenopausal?: boolean
    objective?: string | null
    sportFrequency?: $Enums.SportFrequency | null
    profileType?: $Enums.ProfileType
    contextType?: $Enums.ContextType
    createdAt?: Date | string
    updatedAt?: Date | string
    cycles?: CycleUncheckedCreateNestedManyWithoutUserInput
    programs?: ProgramUncheckedCreateNestedManyWithoutUserInput
    moodTracks?: MoodTrackUncheckedCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    reminderSettings?: ReminderSettingsUncheckedCreateNestedManyWithoutUserInput
    userFeatureFlags?: UserFeatureFlagUncheckedCreateNestedManyWithoutUserInput
    userObjectives?: UserObjectiveUncheckedCreateNestedManyWithoutUserInput
    profileChangeLogs?: ProfileChangeLogUncheckedCreateNestedManyWithoutUserInput
    cycleProfileConfig?: CycleProfileConfigUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    externalSyncs?: ExternalSyncUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSymptomLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSymptomLogsInput, UserUncheckedCreateWithoutSymptomLogsInput>
  }

  export type UserUpsertWithoutSymptomLogsInput = {
    update: XOR<UserUpdateWithoutSymptomLogsInput, UserUncheckedUpdateWithoutSymptomLogsInput>
    create: XOR<UserCreateWithoutSymptomLogsInput, UserUncheckedCreateWithoutSymptomLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSymptomLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSymptomLogsInput, UserUncheckedUpdateWithoutSymptomLogsInput>
  }

  export type UserUpdateWithoutSymptomLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isMenopausal?: BoolFieldUpdateOperationsInput | boolean
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    sportFrequency?: NullableEnumSportFrequencyFieldUpdateOperationsInput | $Enums.SportFrequency | null
    profileType?: EnumProfileTypeFieldUpdateOperationsInput | $Enums.ProfileType
    contextType?: EnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cycles?: CycleUpdateManyWithoutUserNestedInput
    programs?: ProgramUpdateManyWithoutUserNestedInput
    moodTracks?: MoodTrackUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
    reminderSettings?: ReminderSettingsUpdateManyWithoutUserNestedInput
    userFeatureFlags?: UserFeatureFlagUpdateManyWithoutUserNestedInput
    userObjectives?: UserObjectiveUpdateManyWithoutUserNestedInput
    profileChangeLogs?: ProfileChangeLogUpdateManyWithoutUserNestedInput
    cycleProfileConfig?: CycleProfileConfigUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    externalSyncs?: ExternalSyncUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSymptomLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isMenopausal?: BoolFieldUpdateOperationsInput | boolean
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    sportFrequency?: NullableEnumSportFrequencyFieldUpdateOperationsInput | $Enums.SportFrequency | null
    profileType?: EnumProfileTypeFieldUpdateOperationsInput | $Enums.ProfileType
    contextType?: EnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cycles?: CycleUncheckedUpdateManyWithoutUserNestedInput
    programs?: ProgramUncheckedUpdateManyWithoutUserNestedInput
    moodTracks?: MoodTrackUncheckedUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    reminderSettings?: ReminderSettingsUncheckedUpdateManyWithoutUserNestedInput
    userFeatureFlags?: UserFeatureFlagUncheckedUpdateManyWithoutUserNestedInput
    userObjectives?: UserObjectiveUncheckedUpdateManyWithoutUserNestedInput
    profileChangeLogs?: ProfileChangeLogUncheckedUpdateManyWithoutUserNestedInput
    cycleProfileConfig?: CycleProfileConfigUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    externalSyncs?: ExternalSyncUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutUserSettingsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    birthDate?: Date | string | null
    isMenopausal?: boolean
    objective?: string | null
    sportFrequency?: $Enums.SportFrequency | null
    profileType?: $Enums.ProfileType
    contextType?: $Enums.ContextType
    createdAt?: Date | string
    updatedAt?: Date | string
    cycles?: CycleCreateNestedManyWithoutUserInput
    programs?: ProgramCreateNestedManyWithoutUserInput
    moodTracks?: MoodTrackCreateNestedManyWithoutUserInput
    reminderSettings?: ReminderSettingsCreateNestedManyWithoutUserInput
    userFeatureFlags?: UserFeatureFlagCreateNestedManyWithoutUserInput
    userObjectives?: UserObjectiveCreateNestedManyWithoutUserInput
    profileChangeLogs?: ProfileChangeLogCreateNestedManyWithoutUserInput
    cycleProfileConfig?: CycleProfileConfigCreateNestedOneWithoutUserInput
    symptomLogs?: SymptomLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    externalSyncs?: ExternalSyncCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserSettingsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    birthDate?: Date | string | null
    isMenopausal?: boolean
    objective?: string | null
    sportFrequency?: $Enums.SportFrequency | null
    profileType?: $Enums.ProfileType
    contextType?: $Enums.ContextType
    createdAt?: Date | string
    updatedAt?: Date | string
    cycles?: CycleUncheckedCreateNestedManyWithoutUserInput
    programs?: ProgramUncheckedCreateNestedManyWithoutUserInput
    moodTracks?: MoodTrackUncheckedCreateNestedManyWithoutUserInput
    reminderSettings?: ReminderSettingsUncheckedCreateNestedManyWithoutUserInput
    userFeatureFlags?: UserFeatureFlagUncheckedCreateNestedManyWithoutUserInput
    userObjectives?: UserObjectiveUncheckedCreateNestedManyWithoutUserInput
    profileChangeLogs?: ProfileChangeLogUncheckedCreateNestedManyWithoutUserInput
    cycleProfileConfig?: CycleProfileConfigUncheckedCreateNestedOneWithoutUserInput
    symptomLogs?: SymptomLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    externalSyncs?: ExternalSyncUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserSettingsInput, UserUncheckedCreateWithoutUserSettingsInput>
  }

  export type UserUpsertWithoutUserSettingsInput = {
    update: XOR<UserUpdateWithoutUserSettingsInput, UserUncheckedUpdateWithoutUserSettingsInput>
    create: XOR<UserCreateWithoutUserSettingsInput, UserUncheckedCreateWithoutUserSettingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserSettingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserSettingsInput, UserUncheckedUpdateWithoutUserSettingsInput>
  }

  export type UserUpdateWithoutUserSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isMenopausal?: BoolFieldUpdateOperationsInput | boolean
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    sportFrequency?: NullableEnumSportFrequencyFieldUpdateOperationsInput | $Enums.SportFrequency | null
    profileType?: EnumProfileTypeFieldUpdateOperationsInput | $Enums.ProfileType
    contextType?: EnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cycles?: CycleUpdateManyWithoutUserNestedInput
    programs?: ProgramUpdateManyWithoutUserNestedInput
    moodTracks?: MoodTrackUpdateManyWithoutUserNestedInput
    reminderSettings?: ReminderSettingsUpdateManyWithoutUserNestedInput
    userFeatureFlags?: UserFeatureFlagUpdateManyWithoutUserNestedInput
    userObjectives?: UserObjectiveUpdateManyWithoutUserNestedInput
    profileChangeLogs?: ProfileChangeLogUpdateManyWithoutUserNestedInput
    cycleProfileConfig?: CycleProfileConfigUpdateOneWithoutUserNestedInput
    symptomLogs?: SymptomLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    externalSyncs?: ExternalSyncUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isMenopausal?: BoolFieldUpdateOperationsInput | boolean
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    sportFrequency?: NullableEnumSportFrequencyFieldUpdateOperationsInput | $Enums.SportFrequency | null
    profileType?: EnumProfileTypeFieldUpdateOperationsInput | $Enums.ProfileType
    contextType?: EnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cycles?: CycleUncheckedUpdateManyWithoutUserNestedInput
    programs?: ProgramUncheckedUpdateManyWithoutUserNestedInput
    moodTracks?: MoodTrackUncheckedUpdateManyWithoutUserNestedInput
    reminderSettings?: ReminderSettingsUncheckedUpdateManyWithoutUserNestedInput
    userFeatureFlags?: UserFeatureFlagUncheckedUpdateManyWithoutUserNestedInput
    userObjectives?: UserObjectiveUncheckedUpdateManyWithoutUserNestedInput
    profileChangeLogs?: ProfileChangeLogUncheckedUpdateManyWithoutUserNestedInput
    cycleProfileConfig?: CycleProfileConfigUncheckedUpdateOneWithoutUserNestedInput
    symptomLogs?: SymptomLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    externalSyncs?: ExternalSyncUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutReminderSettingsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    birthDate?: Date | string | null
    isMenopausal?: boolean
    objective?: string | null
    sportFrequency?: $Enums.SportFrequency | null
    profileType?: $Enums.ProfileType
    contextType?: $Enums.ContextType
    createdAt?: Date | string
    updatedAt?: Date | string
    cycles?: CycleCreateNestedManyWithoutUserInput
    programs?: ProgramCreateNestedManyWithoutUserInput
    moodTracks?: MoodTrackCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
    userFeatureFlags?: UserFeatureFlagCreateNestedManyWithoutUserInput
    userObjectives?: UserObjectiveCreateNestedManyWithoutUserInput
    profileChangeLogs?: ProfileChangeLogCreateNestedManyWithoutUserInput
    cycleProfileConfig?: CycleProfileConfigCreateNestedOneWithoutUserInput
    symptomLogs?: SymptomLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    externalSyncs?: ExternalSyncCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReminderSettingsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    birthDate?: Date | string | null
    isMenopausal?: boolean
    objective?: string | null
    sportFrequency?: $Enums.SportFrequency | null
    profileType?: $Enums.ProfileType
    contextType?: $Enums.ContextType
    createdAt?: Date | string
    updatedAt?: Date | string
    cycles?: CycleUncheckedCreateNestedManyWithoutUserInput
    programs?: ProgramUncheckedCreateNestedManyWithoutUserInput
    moodTracks?: MoodTrackUncheckedCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    userFeatureFlags?: UserFeatureFlagUncheckedCreateNestedManyWithoutUserInput
    userObjectives?: UserObjectiveUncheckedCreateNestedManyWithoutUserInput
    profileChangeLogs?: ProfileChangeLogUncheckedCreateNestedManyWithoutUserInput
    cycleProfileConfig?: CycleProfileConfigUncheckedCreateNestedOneWithoutUserInput
    symptomLogs?: SymptomLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    externalSyncs?: ExternalSyncUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReminderSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReminderSettingsInput, UserUncheckedCreateWithoutReminderSettingsInput>
  }

  export type UserUpsertWithoutReminderSettingsInput = {
    update: XOR<UserUpdateWithoutReminderSettingsInput, UserUncheckedUpdateWithoutReminderSettingsInput>
    create: XOR<UserCreateWithoutReminderSettingsInput, UserUncheckedCreateWithoutReminderSettingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReminderSettingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReminderSettingsInput, UserUncheckedUpdateWithoutReminderSettingsInput>
  }

  export type UserUpdateWithoutReminderSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isMenopausal?: BoolFieldUpdateOperationsInput | boolean
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    sportFrequency?: NullableEnumSportFrequencyFieldUpdateOperationsInput | $Enums.SportFrequency | null
    profileType?: EnumProfileTypeFieldUpdateOperationsInput | $Enums.ProfileType
    contextType?: EnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cycles?: CycleUpdateManyWithoutUserNestedInput
    programs?: ProgramUpdateManyWithoutUserNestedInput
    moodTracks?: MoodTrackUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
    userFeatureFlags?: UserFeatureFlagUpdateManyWithoutUserNestedInput
    userObjectives?: UserObjectiveUpdateManyWithoutUserNestedInput
    profileChangeLogs?: ProfileChangeLogUpdateManyWithoutUserNestedInput
    cycleProfileConfig?: CycleProfileConfigUpdateOneWithoutUserNestedInput
    symptomLogs?: SymptomLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    externalSyncs?: ExternalSyncUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReminderSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isMenopausal?: BoolFieldUpdateOperationsInput | boolean
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    sportFrequency?: NullableEnumSportFrequencyFieldUpdateOperationsInput | $Enums.SportFrequency | null
    profileType?: EnumProfileTypeFieldUpdateOperationsInput | $Enums.ProfileType
    contextType?: EnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cycles?: CycleUncheckedUpdateManyWithoutUserNestedInput
    programs?: ProgramUncheckedUpdateManyWithoutUserNestedInput
    moodTracks?: MoodTrackUncheckedUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    userFeatureFlags?: UserFeatureFlagUncheckedUpdateManyWithoutUserNestedInput
    userObjectives?: UserObjectiveUncheckedUpdateManyWithoutUserNestedInput
    profileChangeLogs?: ProfileChangeLogUncheckedUpdateManyWithoutUserNestedInput
    cycleProfileConfig?: CycleProfileConfigUncheckedUpdateOneWithoutUserNestedInput
    symptomLogs?: SymptomLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    externalSyncs?: ExternalSyncUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutUserFeatureFlagsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    birthDate?: Date | string | null
    isMenopausal?: boolean
    objective?: string | null
    sportFrequency?: $Enums.SportFrequency | null
    profileType?: $Enums.ProfileType
    contextType?: $Enums.ContextType
    createdAt?: Date | string
    updatedAt?: Date | string
    cycles?: CycleCreateNestedManyWithoutUserInput
    programs?: ProgramCreateNestedManyWithoutUserInput
    moodTracks?: MoodTrackCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
    reminderSettings?: ReminderSettingsCreateNestedManyWithoutUserInput
    userObjectives?: UserObjectiveCreateNestedManyWithoutUserInput
    profileChangeLogs?: ProfileChangeLogCreateNestedManyWithoutUserInput
    cycleProfileConfig?: CycleProfileConfigCreateNestedOneWithoutUserInput
    symptomLogs?: SymptomLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    externalSyncs?: ExternalSyncCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserFeatureFlagsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    birthDate?: Date | string | null
    isMenopausal?: boolean
    objective?: string | null
    sportFrequency?: $Enums.SportFrequency | null
    profileType?: $Enums.ProfileType
    contextType?: $Enums.ContextType
    createdAt?: Date | string
    updatedAt?: Date | string
    cycles?: CycleUncheckedCreateNestedManyWithoutUserInput
    programs?: ProgramUncheckedCreateNestedManyWithoutUserInput
    moodTracks?: MoodTrackUncheckedCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    reminderSettings?: ReminderSettingsUncheckedCreateNestedManyWithoutUserInput
    userObjectives?: UserObjectiveUncheckedCreateNestedManyWithoutUserInput
    profileChangeLogs?: ProfileChangeLogUncheckedCreateNestedManyWithoutUserInput
    cycleProfileConfig?: CycleProfileConfigUncheckedCreateNestedOneWithoutUserInput
    symptomLogs?: SymptomLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    externalSyncs?: ExternalSyncUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserFeatureFlagsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserFeatureFlagsInput, UserUncheckedCreateWithoutUserFeatureFlagsInput>
  }

  export type UserUpsertWithoutUserFeatureFlagsInput = {
    update: XOR<UserUpdateWithoutUserFeatureFlagsInput, UserUncheckedUpdateWithoutUserFeatureFlagsInput>
    create: XOR<UserCreateWithoutUserFeatureFlagsInput, UserUncheckedCreateWithoutUserFeatureFlagsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserFeatureFlagsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserFeatureFlagsInput, UserUncheckedUpdateWithoutUserFeatureFlagsInput>
  }

  export type UserUpdateWithoutUserFeatureFlagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isMenopausal?: BoolFieldUpdateOperationsInput | boolean
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    sportFrequency?: NullableEnumSportFrequencyFieldUpdateOperationsInput | $Enums.SportFrequency | null
    profileType?: EnumProfileTypeFieldUpdateOperationsInput | $Enums.ProfileType
    contextType?: EnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cycles?: CycleUpdateManyWithoutUserNestedInput
    programs?: ProgramUpdateManyWithoutUserNestedInput
    moodTracks?: MoodTrackUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
    reminderSettings?: ReminderSettingsUpdateManyWithoutUserNestedInput
    userObjectives?: UserObjectiveUpdateManyWithoutUserNestedInput
    profileChangeLogs?: ProfileChangeLogUpdateManyWithoutUserNestedInput
    cycleProfileConfig?: CycleProfileConfigUpdateOneWithoutUserNestedInput
    symptomLogs?: SymptomLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    externalSyncs?: ExternalSyncUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserFeatureFlagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isMenopausal?: BoolFieldUpdateOperationsInput | boolean
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    sportFrequency?: NullableEnumSportFrequencyFieldUpdateOperationsInput | $Enums.SportFrequency | null
    profileType?: EnumProfileTypeFieldUpdateOperationsInput | $Enums.ProfileType
    contextType?: EnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cycles?: CycleUncheckedUpdateManyWithoutUserNestedInput
    programs?: ProgramUncheckedUpdateManyWithoutUserNestedInput
    moodTracks?: MoodTrackUncheckedUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    reminderSettings?: ReminderSettingsUncheckedUpdateManyWithoutUserNestedInput
    userObjectives?: UserObjectiveUncheckedUpdateManyWithoutUserNestedInput
    profileChangeLogs?: ProfileChangeLogUncheckedUpdateManyWithoutUserNestedInput
    cycleProfileConfig?: CycleProfileConfigUncheckedUpdateOneWithoutUserNestedInput
    symptomLogs?: SymptomLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    externalSyncs?: ExternalSyncUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutUserObjectivesInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    birthDate?: Date | string | null
    isMenopausal?: boolean
    objective?: string | null
    sportFrequency?: $Enums.SportFrequency | null
    profileType?: $Enums.ProfileType
    contextType?: $Enums.ContextType
    createdAt?: Date | string
    updatedAt?: Date | string
    cycles?: CycleCreateNestedManyWithoutUserInput
    programs?: ProgramCreateNestedManyWithoutUserInput
    moodTracks?: MoodTrackCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
    reminderSettings?: ReminderSettingsCreateNestedManyWithoutUserInput
    userFeatureFlags?: UserFeatureFlagCreateNestedManyWithoutUserInput
    profileChangeLogs?: ProfileChangeLogCreateNestedManyWithoutUserInput
    cycleProfileConfig?: CycleProfileConfigCreateNestedOneWithoutUserInput
    symptomLogs?: SymptomLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    externalSyncs?: ExternalSyncCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserObjectivesInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    birthDate?: Date | string | null
    isMenopausal?: boolean
    objective?: string | null
    sportFrequency?: $Enums.SportFrequency | null
    profileType?: $Enums.ProfileType
    contextType?: $Enums.ContextType
    createdAt?: Date | string
    updatedAt?: Date | string
    cycles?: CycleUncheckedCreateNestedManyWithoutUserInput
    programs?: ProgramUncheckedCreateNestedManyWithoutUserInput
    moodTracks?: MoodTrackUncheckedCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    reminderSettings?: ReminderSettingsUncheckedCreateNestedManyWithoutUserInput
    userFeatureFlags?: UserFeatureFlagUncheckedCreateNestedManyWithoutUserInput
    profileChangeLogs?: ProfileChangeLogUncheckedCreateNestedManyWithoutUserInput
    cycleProfileConfig?: CycleProfileConfigUncheckedCreateNestedOneWithoutUserInput
    symptomLogs?: SymptomLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    externalSyncs?: ExternalSyncUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserObjectivesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserObjectivesInput, UserUncheckedCreateWithoutUserObjectivesInput>
  }

  export type UserUpsertWithoutUserObjectivesInput = {
    update: XOR<UserUpdateWithoutUserObjectivesInput, UserUncheckedUpdateWithoutUserObjectivesInput>
    create: XOR<UserCreateWithoutUserObjectivesInput, UserUncheckedCreateWithoutUserObjectivesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserObjectivesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserObjectivesInput, UserUncheckedUpdateWithoutUserObjectivesInput>
  }

  export type UserUpdateWithoutUserObjectivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isMenopausal?: BoolFieldUpdateOperationsInput | boolean
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    sportFrequency?: NullableEnumSportFrequencyFieldUpdateOperationsInput | $Enums.SportFrequency | null
    profileType?: EnumProfileTypeFieldUpdateOperationsInput | $Enums.ProfileType
    contextType?: EnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cycles?: CycleUpdateManyWithoutUserNestedInput
    programs?: ProgramUpdateManyWithoutUserNestedInput
    moodTracks?: MoodTrackUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
    reminderSettings?: ReminderSettingsUpdateManyWithoutUserNestedInput
    userFeatureFlags?: UserFeatureFlagUpdateManyWithoutUserNestedInput
    profileChangeLogs?: ProfileChangeLogUpdateManyWithoutUserNestedInput
    cycleProfileConfig?: CycleProfileConfigUpdateOneWithoutUserNestedInput
    symptomLogs?: SymptomLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    externalSyncs?: ExternalSyncUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserObjectivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isMenopausal?: BoolFieldUpdateOperationsInput | boolean
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    sportFrequency?: NullableEnumSportFrequencyFieldUpdateOperationsInput | $Enums.SportFrequency | null
    profileType?: EnumProfileTypeFieldUpdateOperationsInput | $Enums.ProfileType
    contextType?: EnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cycles?: CycleUncheckedUpdateManyWithoutUserNestedInput
    programs?: ProgramUncheckedUpdateManyWithoutUserNestedInput
    moodTracks?: MoodTrackUncheckedUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    reminderSettings?: ReminderSettingsUncheckedUpdateManyWithoutUserNestedInput
    userFeatureFlags?: UserFeatureFlagUncheckedUpdateManyWithoutUserNestedInput
    profileChangeLogs?: ProfileChangeLogUncheckedUpdateManyWithoutUserNestedInput
    cycleProfileConfig?: CycleProfileConfigUncheckedUpdateOneWithoutUserNestedInput
    symptomLogs?: SymptomLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    externalSyncs?: ExternalSyncUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutProfileChangeLogsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    birthDate?: Date | string | null
    isMenopausal?: boolean
    objective?: string | null
    sportFrequency?: $Enums.SportFrequency | null
    profileType?: $Enums.ProfileType
    contextType?: $Enums.ContextType
    createdAt?: Date | string
    updatedAt?: Date | string
    cycles?: CycleCreateNestedManyWithoutUserInput
    programs?: ProgramCreateNestedManyWithoutUserInput
    moodTracks?: MoodTrackCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsCreateNestedOneWithoutUserInput
    reminderSettings?: ReminderSettingsCreateNestedManyWithoutUserInput
    userFeatureFlags?: UserFeatureFlagCreateNestedManyWithoutUserInput
    userObjectives?: UserObjectiveCreateNestedManyWithoutUserInput
    cycleProfileConfig?: CycleProfileConfigCreateNestedOneWithoutUserInput
    symptomLogs?: SymptomLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    externalSyncs?: ExternalSyncCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProfileChangeLogsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    birthDate?: Date | string | null
    isMenopausal?: boolean
    objective?: string | null
    sportFrequency?: $Enums.SportFrequency | null
    profileType?: $Enums.ProfileType
    contextType?: $Enums.ContextType
    createdAt?: Date | string
    updatedAt?: Date | string
    cycles?: CycleUncheckedCreateNestedManyWithoutUserInput
    programs?: ProgramUncheckedCreateNestedManyWithoutUserInput
    moodTracks?: MoodTrackUncheckedCreateNestedManyWithoutUserInput
    userSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    reminderSettings?: ReminderSettingsUncheckedCreateNestedManyWithoutUserInput
    userFeatureFlags?: UserFeatureFlagUncheckedCreateNestedManyWithoutUserInput
    userObjectives?: UserObjectiveUncheckedCreateNestedManyWithoutUserInput
    cycleProfileConfig?: CycleProfileConfigUncheckedCreateNestedOneWithoutUserInput
    symptomLogs?: SymptomLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    externalSyncs?: ExternalSyncUncheckedCreateNestedManyWithoutUserInput
    journalEntries?: JournalEntryUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    authSessions?: AuthSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProfileChangeLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileChangeLogsInput, UserUncheckedCreateWithoutProfileChangeLogsInput>
  }

  export type UserUpsertWithoutProfileChangeLogsInput = {
    update: XOR<UserUpdateWithoutProfileChangeLogsInput, UserUncheckedUpdateWithoutProfileChangeLogsInput>
    create: XOR<UserCreateWithoutProfileChangeLogsInput, UserUncheckedCreateWithoutProfileChangeLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfileChangeLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfileChangeLogsInput, UserUncheckedUpdateWithoutProfileChangeLogsInput>
  }

  export type UserUpdateWithoutProfileChangeLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isMenopausal?: BoolFieldUpdateOperationsInput | boolean
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    sportFrequency?: NullableEnumSportFrequencyFieldUpdateOperationsInput | $Enums.SportFrequency | null
    profileType?: EnumProfileTypeFieldUpdateOperationsInput | $Enums.ProfileType
    contextType?: EnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cycles?: CycleUpdateManyWithoutUserNestedInput
    programs?: ProgramUpdateManyWithoutUserNestedInput
    moodTracks?: MoodTrackUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUpdateOneWithoutUserNestedInput
    reminderSettings?: ReminderSettingsUpdateManyWithoutUserNestedInput
    userFeatureFlags?: UserFeatureFlagUpdateManyWithoutUserNestedInput
    userObjectives?: UserObjectiveUpdateManyWithoutUserNestedInput
    cycleProfileConfig?: CycleProfileConfigUpdateOneWithoutUserNestedInput
    symptomLogs?: SymptomLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    externalSyncs?: ExternalSyncUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileChangeLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isMenopausal?: BoolFieldUpdateOperationsInput | boolean
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    sportFrequency?: NullableEnumSportFrequencyFieldUpdateOperationsInput | $Enums.SportFrequency | null
    profileType?: EnumProfileTypeFieldUpdateOperationsInput | $Enums.ProfileType
    contextType?: EnumContextTypeFieldUpdateOperationsInput | $Enums.ContextType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cycles?: CycleUncheckedUpdateManyWithoutUserNestedInput
    programs?: ProgramUncheckedUpdateManyWithoutUserNestedInput
    moodTracks?: MoodTrackUncheckedUpdateManyWithoutUserNestedInput
    userSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    reminderSettings?: ReminderSettingsUncheckedUpdateManyWithoutUserNestedInput
    userFeatureFlags?: UserFeatureFlagUncheckedUpdateManyWithoutUserNestedInput
    userObjectives?: UserObjectiveUncheckedUpdateManyWithoutUserNestedInput
    cycleProfileConfig?: CycleProfileConfigUncheckedUpdateOneWithoutUserNestedInput
    symptomLogs?: SymptomLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    externalSyncs?: ExternalSyncUncheckedUpdateManyWithoutUserNestedInput
    journalEntries?: JournalEntryUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    authSessions?: AuthSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CycleCreateWithoutUserInput = {
    id?: string
    startDate: Date | string
    cycleLength?: number | null
    periodLength?: number | null
    isRegular?: boolean
    externalCycleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    provider?: CycleProviderCreateNestedOneWithoutCyclesInput
    phases?: PhaseCreateNestedManyWithoutCycleInput
  }

  export type CycleUncheckedCreateWithoutUserInput = {
    id?: string
    startDate: Date | string
    cycleLength?: number | null
    periodLength?: number | null
    isRegular?: boolean
    providerId?: string | null
    externalCycleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    phases?: PhaseUncheckedCreateNestedManyWithoutCycleInput
  }

  export type CycleCreateOrConnectWithoutUserInput = {
    where: CycleWhereUniqueInput
    create: XOR<CycleCreateWithoutUserInput, CycleUncheckedCreateWithoutUserInput>
  }

  export type CycleCreateManyUserInputEnvelope = {
    data: CycleCreateManyUserInput | CycleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProgramCreateWithoutUserInput = {
    id?: string
    title: string
    goal?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    programExercises?: ProgramExerciseCreateNestedManyWithoutProgramInput
    notifications?: NotificationCreateNestedManyWithoutRelatedProgramInput
  }

  export type ProgramUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    goal?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    programExercises?: ProgramExerciseUncheckedCreateNestedManyWithoutProgramInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRelatedProgramInput
  }

  export type ProgramCreateOrConnectWithoutUserInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutUserInput, ProgramUncheckedCreateWithoutUserInput>
  }

  export type ProgramCreateManyUserInputEnvelope = {
    data: ProgramCreateManyUserInput | ProgramCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MoodTrackCreateWithoutUserInput = {
    id?: string
    date: Date | string
    mood?: $Enums.MoodType | null
    energy?: $Enums.EnergyLevel | null
    pain?: $Enums.PainLevel | null
    stress?: $Enums.StressLevel | null
    sleepQuality?: $Enums.SleepQuality | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MoodTrackUncheckedCreateWithoutUserInput = {
    id?: string
    date: Date | string
    mood?: $Enums.MoodType | null
    energy?: $Enums.EnergyLevel | null
    pain?: $Enums.PainLevel | null
    stress?: $Enums.StressLevel | null
    sleepQuality?: $Enums.SleepQuality | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MoodTrackCreateOrConnectWithoutUserInput = {
    where: MoodTrackWhereUniqueInput
    create: XOR<MoodTrackCreateWithoutUserInput, MoodTrackUncheckedCreateWithoutUserInput>
  }

  export type MoodTrackCreateManyUserInputEnvelope = {
    data: MoodTrackCreateManyUserInput | MoodTrackCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserSettingsCreateWithoutUserInput = {
    id?: string
    unitPreference?: $Enums.UnitPreference
    notificationEnabled?: boolean
    notificationTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingsUncheckedCreateWithoutUserInput = {
    id?: string
    unitPreference?: $Enums.UnitPreference
    notificationEnabled?: boolean
    notificationTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingsCreateOrConnectWithoutUserInput = {
    where: UserSettingsWhereUniqueInput
    create: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
  }

  export type ReminderSettingsCreateWithoutUserInput = {
    id?: string
    type: $Enums.ReminderType
    enabled?: boolean
    time?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReminderSettingsUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.ReminderType
    enabled?: boolean
    time?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReminderSettingsCreateOrConnectWithoutUserInput = {
    where: ReminderSettingsWhereUniqueInput
    create: XOR<ReminderSettingsCreateWithoutUserInput, ReminderSettingsUncheckedCreateWithoutUserInput>
  }

  export type ReminderSettingsCreateManyUserInputEnvelope = {
    data: ReminderSettingsCreateManyUserInput | ReminderSettingsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserFeatureFlagCreateWithoutUserInput = {
    id?: string
    feature: string
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserFeatureFlagUncheckedCreateWithoutUserInput = {
    id?: string
    feature: string
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserFeatureFlagCreateOrConnectWithoutUserInput = {
    where: UserFeatureFlagWhereUniqueInput
    create: XOR<UserFeatureFlagCreateWithoutUserInput, UserFeatureFlagUncheckedCreateWithoutUserInput>
  }

  export type UserFeatureFlagCreateManyUserInputEnvelope = {
    data: UserFeatureFlagCreateManyUserInput | UserFeatureFlagCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserObjectiveCreateWithoutUserInput = {
    id?: string
    type: $Enums.ObjectiveType
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserObjectiveUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.ObjectiveType
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserObjectiveCreateOrConnectWithoutUserInput = {
    where: UserObjectiveWhereUniqueInput
    create: XOR<UserObjectiveCreateWithoutUserInput, UserObjectiveUncheckedCreateWithoutUserInput>
  }

  export type UserObjectiveCreateManyUserInputEnvelope = {
    data: UserObjectiveCreateManyUserInput | UserObjectiveCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProfileChangeLogCreateWithoutUserInput = {
    id?: string
    changeType: $Enums.ChangeType
    details?: string | null
    changedAt?: Date | string
  }

  export type ProfileChangeLogUncheckedCreateWithoutUserInput = {
    id?: string
    changeType: $Enums.ChangeType
    details?: string | null
    changedAt?: Date | string
  }

  export type ProfileChangeLogCreateOrConnectWithoutUserInput = {
    where: ProfileChangeLogWhereUniqueInput
    create: XOR<ProfileChangeLogCreateWithoutUserInput, ProfileChangeLogUncheckedCreateWithoutUserInput>
  }

  export type ProfileChangeLogCreateManyUserInputEnvelope = {
    data: ProfileChangeLogCreateManyUserInput | ProfileChangeLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CycleProfileConfigCreateWithoutUserInput = {
    id?: string
    isCycleTrackingEnabled?: boolean
    usesExternalProvider?: boolean
    useMenopauseMode?: boolean
    averageCycleLength?: number | null
    averagePeriodLength?: number | null
    prefersManualInput?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CycleProfileConfigUncheckedCreateWithoutUserInput = {
    id?: string
    isCycleTrackingEnabled?: boolean
    usesExternalProvider?: boolean
    useMenopauseMode?: boolean
    averageCycleLength?: number | null
    averagePeriodLength?: number | null
    prefersManualInput?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CycleProfileConfigCreateOrConnectWithoutUserInput = {
    where: CycleProfileConfigWhereUniqueInput
    create: XOR<CycleProfileConfigCreateWithoutUserInput, CycleProfileConfigUncheckedCreateWithoutUserInput>
  }

  export type SymptomLogCreateWithoutUserInput = {
    id?: string
    date: Date | string
    symptomType: $Enums.SymptomType
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SymptomLogUncheckedCreateWithoutUserInput = {
    id?: string
    date: Date | string
    symptomType: $Enums.SymptomType
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SymptomLogCreateOrConnectWithoutUserInput = {
    where: SymptomLogWhereUniqueInput
    create: XOR<SymptomLogCreateWithoutUserInput, SymptomLogUncheckedCreateWithoutUserInput>
  }

  export type SymptomLogCreateManyUserInputEnvelope = {
    data: SymptomLogCreateManyUserInput | SymptomLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    message: string
    date: Date | string
    relatedPhase?: string | null
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    relatedProgram?: ProgramCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    message: string
    date: Date | string
    relatedPhase?: string | null
    relatedProgramId?: string | null
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ExternalSyncCreateWithoutUserInput = {
    id?: string
    provider: $Enums.ExternalProvider
    entitySynced: string
    externalId: string
    status: $Enums.ExternalSyncStatus
    message?: string | null
    syncedAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExternalSyncUncheckedCreateWithoutUserInput = {
    id?: string
    provider: $Enums.ExternalProvider
    entitySynced: string
    externalId: string
    status: $Enums.ExternalSyncStatus
    message?: string | null
    syncedAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExternalSyncCreateOrConnectWithoutUserInput = {
    where: ExternalSyncWhereUniqueInput
    create: XOR<ExternalSyncCreateWithoutUserInput, ExternalSyncUncheckedCreateWithoutUserInput>
  }

  export type ExternalSyncCreateManyUserInputEnvelope = {
    data: ExternalSyncCreateManyUserInput | ExternalSyncCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type JournalEntryCreateWithoutUserInput = {
    id?: string
    date: Date | string
    category: $Enums.JournalCategory
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalEntryUncheckedCreateWithoutUserInput = {
    id?: string
    date: Date | string
    category: $Enums.JournalCategory
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalEntryCreateOrConnectWithoutUserInput = {
    where: JournalEntryWhereUniqueInput
    create: XOR<JournalEntryCreateWithoutUserInput, JournalEntryUncheckedCreateWithoutUserInput>
  }

  export type JournalEntryCreateManyUserInputEnvelope = {
    data: JournalEntryCreateManyUserInput | JournalEntryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    entity: string
    entityId?: string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    entity: string
    entityId?: string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LogCreateWithoutUserInput = {
    id?: string
    eventType: $Enums.EventType
    description?: string | null
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LogUncheckedCreateWithoutUserInput = {
    id?: string
    eventType: $Enums.EventType
    description?: string | null
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LogCreateOrConnectWithoutUserInput = {
    where: LogWhereUniqueInput
    create: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput>
  }

  export type LogCreateManyUserInputEnvelope = {
    data: LogCreateManyUserInput | LogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RefreshTokenCreateWithoutUserInput = {
    id?: string
    tokenHash: string
    expiresAt: Date | string
    revoked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id?: string
    tokenHash: string
    expiresAt: Date | string
    revoked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuthSessionCreateWithoutUserInput = {
    id?: string
    userAgent?: string | null
    ipAddress?: string | null
    lastSeen: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthSessionUncheckedCreateWithoutUserInput = {
    id?: string
    userAgent?: string | null
    ipAddress?: string | null
    lastSeen: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthSessionCreateOrConnectWithoutUserInput = {
    where: AuthSessionWhereUniqueInput
    create: XOR<AuthSessionCreateWithoutUserInput, AuthSessionUncheckedCreateWithoutUserInput>
  }

  export type AuthSessionCreateManyUserInputEnvelope = {
    data: AuthSessionCreateManyUserInput | AuthSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CycleUpsertWithWhereUniqueWithoutUserInput = {
    where: CycleWhereUniqueInput
    update: XOR<CycleUpdateWithoutUserInput, CycleUncheckedUpdateWithoutUserInput>
    create: XOR<CycleCreateWithoutUserInput, CycleUncheckedCreateWithoutUserInput>
  }

  export type CycleUpdateWithWhereUniqueWithoutUserInput = {
    where: CycleWhereUniqueInput
    data: XOR<CycleUpdateWithoutUserInput, CycleUncheckedUpdateWithoutUserInput>
  }

  export type CycleUpdateManyWithWhereWithoutUserInput = {
    where: CycleScalarWhereInput
    data: XOR<CycleUpdateManyMutationInput, CycleUncheckedUpdateManyWithoutUserInput>
  }

  export type ProgramUpsertWithWhereUniqueWithoutUserInput = {
    where: ProgramWhereUniqueInput
    update: XOR<ProgramUpdateWithoutUserInput, ProgramUncheckedUpdateWithoutUserInput>
    create: XOR<ProgramCreateWithoutUserInput, ProgramUncheckedCreateWithoutUserInput>
  }

  export type ProgramUpdateWithWhereUniqueWithoutUserInput = {
    where: ProgramWhereUniqueInput
    data: XOR<ProgramUpdateWithoutUserInput, ProgramUncheckedUpdateWithoutUserInput>
  }

  export type ProgramUpdateManyWithWhereWithoutUserInput = {
    where: ProgramScalarWhereInput
    data: XOR<ProgramUpdateManyMutationInput, ProgramUncheckedUpdateManyWithoutUserInput>
  }

  export type ProgramScalarWhereInput = {
    AND?: ProgramScalarWhereInput | ProgramScalarWhereInput[]
    OR?: ProgramScalarWhereInput[]
    NOT?: ProgramScalarWhereInput | ProgramScalarWhereInput[]
    id?: StringFilter<"Program"> | string
    userId?: StringFilter<"Program"> | string
    title?: StringFilter<"Program"> | string
    goal?: StringNullableFilter<"Program"> | string | null
    startDate?: DateTimeFilter<"Program"> | Date | string
    endDate?: DateTimeNullableFilter<"Program"> | Date | string | null
    createdAt?: DateTimeFilter<"Program"> | Date | string
    updatedAt?: DateTimeFilter<"Program"> | Date | string
  }

  export type MoodTrackUpsertWithWhereUniqueWithoutUserInput = {
    where: MoodTrackWhereUniqueInput
    update: XOR<MoodTrackUpdateWithoutUserInput, MoodTrackUncheckedUpdateWithoutUserInput>
    create: XOR<MoodTrackCreateWithoutUserInput, MoodTrackUncheckedCreateWithoutUserInput>
  }

  export type MoodTrackUpdateWithWhereUniqueWithoutUserInput = {
    where: MoodTrackWhereUniqueInput
    data: XOR<MoodTrackUpdateWithoutUserInput, MoodTrackUncheckedUpdateWithoutUserInput>
  }

  export type MoodTrackUpdateManyWithWhereWithoutUserInput = {
    where: MoodTrackScalarWhereInput
    data: XOR<MoodTrackUpdateManyMutationInput, MoodTrackUncheckedUpdateManyWithoutUserInput>
  }

  export type MoodTrackScalarWhereInput = {
    AND?: MoodTrackScalarWhereInput | MoodTrackScalarWhereInput[]
    OR?: MoodTrackScalarWhereInput[]
    NOT?: MoodTrackScalarWhereInput | MoodTrackScalarWhereInput[]
    id?: StringFilter<"MoodTrack"> | string
    userId?: StringFilter<"MoodTrack"> | string
    date?: DateTimeFilter<"MoodTrack"> | Date | string
    mood?: EnumMoodTypeNullableFilter<"MoodTrack"> | $Enums.MoodType | null
    energy?: EnumEnergyLevelNullableFilter<"MoodTrack"> | $Enums.EnergyLevel | null
    pain?: EnumPainLevelNullableFilter<"MoodTrack"> | $Enums.PainLevel | null
    stress?: EnumStressLevelNullableFilter<"MoodTrack"> | $Enums.StressLevel | null
    sleepQuality?: EnumSleepQualityNullableFilter<"MoodTrack"> | $Enums.SleepQuality | null
    createdAt?: DateTimeFilter<"MoodTrack"> | Date | string
    updatedAt?: DateTimeFilter<"MoodTrack"> | Date | string
  }

  export type UserSettingsUpsertWithoutUserInput = {
    update: XOR<UserSettingsUpdateWithoutUserInput, UserSettingsUncheckedUpdateWithoutUserInput>
    create: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    where?: UserSettingsWhereInput
  }

  export type UserSettingsUpdateToOneWithWhereWithoutUserInput = {
    where?: UserSettingsWhereInput
    data: XOR<UserSettingsUpdateWithoutUserInput, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type UserSettingsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitPreference?: EnumUnitPreferenceFieldUpdateOperationsInput | $Enums.UnitPreference
    notificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    unitPreference?: EnumUnitPreferenceFieldUpdateOperationsInput | $Enums.UnitPreference
    notificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReminderSettingsUpsertWithWhereUniqueWithoutUserInput = {
    where: ReminderSettingsWhereUniqueInput
    update: XOR<ReminderSettingsUpdateWithoutUserInput, ReminderSettingsUncheckedUpdateWithoutUserInput>
    create: XOR<ReminderSettingsCreateWithoutUserInput, ReminderSettingsUncheckedCreateWithoutUserInput>
  }

  export type ReminderSettingsUpdateWithWhereUniqueWithoutUserInput = {
    where: ReminderSettingsWhereUniqueInput
    data: XOR<ReminderSettingsUpdateWithoutUserInput, ReminderSettingsUncheckedUpdateWithoutUserInput>
  }

  export type ReminderSettingsUpdateManyWithWhereWithoutUserInput = {
    where: ReminderSettingsScalarWhereInput
    data: XOR<ReminderSettingsUpdateManyMutationInput, ReminderSettingsUncheckedUpdateManyWithoutUserInput>
  }

  export type ReminderSettingsScalarWhereInput = {
    AND?: ReminderSettingsScalarWhereInput | ReminderSettingsScalarWhereInput[]
    OR?: ReminderSettingsScalarWhereInput[]
    NOT?: ReminderSettingsScalarWhereInput | ReminderSettingsScalarWhereInput[]
    id?: StringFilter<"ReminderSettings"> | string
    userId?: StringFilter<"ReminderSettings"> | string
    type?: EnumReminderTypeFilter<"ReminderSettings"> | $Enums.ReminderType
    enabled?: BoolFilter<"ReminderSettings"> | boolean
    time?: DateTimeNullableFilter<"ReminderSettings"> | Date | string | null
    createdAt?: DateTimeFilter<"ReminderSettings"> | Date | string
    updatedAt?: DateTimeFilter<"ReminderSettings"> | Date | string
  }

  export type UserFeatureFlagUpsertWithWhereUniqueWithoutUserInput = {
    where: UserFeatureFlagWhereUniqueInput
    update: XOR<UserFeatureFlagUpdateWithoutUserInput, UserFeatureFlagUncheckedUpdateWithoutUserInput>
    create: XOR<UserFeatureFlagCreateWithoutUserInput, UserFeatureFlagUncheckedCreateWithoutUserInput>
  }

  export type UserFeatureFlagUpdateWithWhereUniqueWithoutUserInput = {
    where: UserFeatureFlagWhereUniqueInput
    data: XOR<UserFeatureFlagUpdateWithoutUserInput, UserFeatureFlagUncheckedUpdateWithoutUserInput>
  }

  export type UserFeatureFlagUpdateManyWithWhereWithoutUserInput = {
    where: UserFeatureFlagScalarWhereInput
    data: XOR<UserFeatureFlagUpdateManyMutationInput, UserFeatureFlagUncheckedUpdateManyWithoutUserInput>
  }

  export type UserFeatureFlagScalarWhereInput = {
    AND?: UserFeatureFlagScalarWhereInput | UserFeatureFlagScalarWhereInput[]
    OR?: UserFeatureFlagScalarWhereInput[]
    NOT?: UserFeatureFlagScalarWhereInput | UserFeatureFlagScalarWhereInput[]
    id?: StringFilter<"UserFeatureFlag"> | string
    userId?: StringFilter<"UserFeatureFlag"> | string
    feature?: StringFilter<"UserFeatureFlag"> | string
    isEnabled?: BoolFilter<"UserFeatureFlag"> | boolean
    createdAt?: DateTimeFilter<"UserFeatureFlag"> | Date | string
    updatedAt?: DateTimeFilter<"UserFeatureFlag"> | Date | string
  }

  export type UserObjectiveUpsertWithWhereUniqueWithoutUserInput = {
    where: UserObjectiveWhereUniqueInput
    update: XOR<UserObjectiveUpdateWithoutUserInput, UserObjectiveUncheckedUpdateWithoutUserInput>
    create: XOR<UserObjectiveCreateWithoutUserInput, UserObjectiveUncheckedCreateWithoutUserInput>
  }

  export type UserObjectiveUpdateWithWhereUniqueWithoutUserInput = {
    where: UserObjectiveWhereUniqueInput
    data: XOR<UserObjectiveUpdateWithoutUserInput, UserObjectiveUncheckedUpdateWithoutUserInput>
  }

  export type UserObjectiveUpdateManyWithWhereWithoutUserInput = {
    where: UserObjectiveScalarWhereInput
    data: XOR<UserObjectiveUpdateManyMutationInput, UserObjectiveUncheckedUpdateManyWithoutUserInput>
  }

  export type UserObjectiveScalarWhereInput = {
    AND?: UserObjectiveScalarWhereInput | UserObjectiveScalarWhereInput[]
    OR?: UserObjectiveScalarWhereInput[]
    NOT?: UserObjectiveScalarWhereInput | UserObjectiveScalarWhereInput[]
    id?: StringFilter<"UserObjective"> | string
    userId?: StringFilter<"UserObjective"> | string
    type?: EnumObjectiveTypeFilter<"UserObjective"> | $Enums.ObjectiveType
    note?: StringNullableFilter<"UserObjective"> | string | null
    createdAt?: DateTimeFilter<"UserObjective"> | Date | string
    updatedAt?: DateTimeFilter<"UserObjective"> | Date | string
  }

  export type ProfileChangeLogUpsertWithWhereUniqueWithoutUserInput = {
    where: ProfileChangeLogWhereUniqueInput
    update: XOR<ProfileChangeLogUpdateWithoutUserInput, ProfileChangeLogUncheckedUpdateWithoutUserInput>
    create: XOR<ProfileChangeLogCreateWithoutUserInput, ProfileChangeLogUncheckedCreateWithoutUserInput>
  }

  export type ProfileChangeLogUpdateWithWhereUniqueWithoutUserInput = {
    where: ProfileChangeLogWhereUniqueInput
    data: XOR<ProfileChangeLogUpdateWithoutUserInput, ProfileChangeLogUncheckedUpdateWithoutUserInput>
  }

  export type ProfileChangeLogUpdateManyWithWhereWithoutUserInput = {
    where: ProfileChangeLogScalarWhereInput
    data: XOR<ProfileChangeLogUpdateManyMutationInput, ProfileChangeLogUncheckedUpdateManyWithoutUserInput>
  }

  export type ProfileChangeLogScalarWhereInput = {
    AND?: ProfileChangeLogScalarWhereInput | ProfileChangeLogScalarWhereInput[]
    OR?: ProfileChangeLogScalarWhereInput[]
    NOT?: ProfileChangeLogScalarWhereInput | ProfileChangeLogScalarWhereInput[]
    id?: StringFilter<"ProfileChangeLog"> | string
    userId?: StringFilter<"ProfileChangeLog"> | string
    changeType?: EnumChangeTypeFilter<"ProfileChangeLog"> | $Enums.ChangeType
    details?: StringNullableFilter<"ProfileChangeLog"> | string | null
    changedAt?: DateTimeFilter<"ProfileChangeLog"> | Date | string
  }

  export type CycleProfileConfigUpsertWithoutUserInput = {
    update: XOR<CycleProfileConfigUpdateWithoutUserInput, CycleProfileConfigUncheckedUpdateWithoutUserInput>
    create: XOR<CycleProfileConfigCreateWithoutUserInput, CycleProfileConfigUncheckedCreateWithoutUserInput>
    where?: CycleProfileConfigWhereInput
  }

  export type CycleProfileConfigUpdateToOneWithWhereWithoutUserInput = {
    where?: CycleProfileConfigWhereInput
    data: XOR<CycleProfileConfigUpdateWithoutUserInput, CycleProfileConfigUncheckedUpdateWithoutUserInput>
  }

  export type CycleProfileConfigUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCycleTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    usesExternalProvider?: BoolFieldUpdateOperationsInput | boolean
    useMenopauseMode?: BoolFieldUpdateOperationsInput | boolean
    averageCycleLength?: NullableIntFieldUpdateOperationsInput | number | null
    averagePeriodLength?: NullableIntFieldUpdateOperationsInput | number | null
    prefersManualInput?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CycleProfileConfigUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCycleTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    usesExternalProvider?: BoolFieldUpdateOperationsInput | boolean
    useMenopauseMode?: BoolFieldUpdateOperationsInput | boolean
    averageCycleLength?: NullableIntFieldUpdateOperationsInput | number | null
    averagePeriodLength?: NullableIntFieldUpdateOperationsInput | number | null
    prefersManualInput?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SymptomLogUpsertWithWhereUniqueWithoutUserInput = {
    where: SymptomLogWhereUniqueInput
    update: XOR<SymptomLogUpdateWithoutUserInput, SymptomLogUncheckedUpdateWithoutUserInput>
    create: XOR<SymptomLogCreateWithoutUserInput, SymptomLogUncheckedCreateWithoutUserInput>
  }

  export type SymptomLogUpdateWithWhereUniqueWithoutUserInput = {
    where: SymptomLogWhereUniqueInput
    data: XOR<SymptomLogUpdateWithoutUserInput, SymptomLogUncheckedUpdateWithoutUserInput>
  }

  export type SymptomLogUpdateManyWithWhereWithoutUserInput = {
    where: SymptomLogScalarWhereInput
    data: XOR<SymptomLogUpdateManyMutationInput, SymptomLogUncheckedUpdateManyWithoutUserInput>
  }

  export type SymptomLogScalarWhereInput = {
    AND?: SymptomLogScalarWhereInput | SymptomLogScalarWhereInput[]
    OR?: SymptomLogScalarWhereInput[]
    NOT?: SymptomLogScalarWhereInput | SymptomLogScalarWhereInput[]
    id?: StringFilter<"SymptomLog"> | string
    userId?: StringFilter<"SymptomLog"> | string
    date?: DateTimeFilter<"SymptomLog"> | Date | string
    symptomType?: EnumSymptomTypeFilter<"SymptomLog"> | $Enums.SymptomType
    value?: StringFilter<"SymptomLog"> | string
    createdAt?: DateTimeFilter<"SymptomLog"> | Date | string
    updatedAt?: DateTimeFilter<"SymptomLog"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type ExternalSyncUpsertWithWhereUniqueWithoutUserInput = {
    where: ExternalSyncWhereUniqueInput
    update: XOR<ExternalSyncUpdateWithoutUserInput, ExternalSyncUncheckedUpdateWithoutUserInput>
    create: XOR<ExternalSyncCreateWithoutUserInput, ExternalSyncUncheckedCreateWithoutUserInput>
  }

  export type ExternalSyncUpdateWithWhereUniqueWithoutUserInput = {
    where: ExternalSyncWhereUniqueInput
    data: XOR<ExternalSyncUpdateWithoutUserInput, ExternalSyncUncheckedUpdateWithoutUserInput>
  }

  export type ExternalSyncUpdateManyWithWhereWithoutUserInput = {
    where: ExternalSyncScalarWhereInput
    data: XOR<ExternalSyncUpdateManyMutationInput, ExternalSyncUncheckedUpdateManyWithoutUserInput>
  }

  export type ExternalSyncScalarWhereInput = {
    AND?: ExternalSyncScalarWhereInput | ExternalSyncScalarWhereInput[]
    OR?: ExternalSyncScalarWhereInput[]
    NOT?: ExternalSyncScalarWhereInput | ExternalSyncScalarWhereInput[]
    id?: StringFilter<"ExternalSync"> | string
    userId?: StringFilter<"ExternalSync"> | string
    provider?: EnumExternalProviderFilter<"ExternalSync"> | $Enums.ExternalProvider
    entitySynced?: StringFilter<"ExternalSync"> | string
    externalId?: StringFilter<"ExternalSync"> | string
    status?: EnumExternalSyncStatusFilter<"ExternalSync"> | $Enums.ExternalSyncStatus
    message?: StringNullableFilter<"ExternalSync"> | string | null
    syncedAt?: DateTimeFilter<"ExternalSync"> | Date | string
    createdAt?: DateTimeFilter<"ExternalSync"> | Date | string
    updatedAt?: DateTimeFilter<"ExternalSync"> | Date | string
  }

  export type JournalEntryUpsertWithWhereUniqueWithoutUserInput = {
    where: JournalEntryWhereUniqueInput
    update: XOR<JournalEntryUpdateWithoutUserInput, JournalEntryUncheckedUpdateWithoutUserInput>
    create: XOR<JournalEntryCreateWithoutUserInput, JournalEntryUncheckedCreateWithoutUserInput>
  }

  export type JournalEntryUpdateWithWhereUniqueWithoutUserInput = {
    where: JournalEntryWhereUniqueInput
    data: XOR<JournalEntryUpdateWithoutUserInput, JournalEntryUncheckedUpdateWithoutUserInput>
  }

  export type JournalEntryUpdateManyWithWhereWithoutUserInput = {
    where: JournalEntryScalarWhereInput
    data: XOR<JournalEntryUpdateManyMutationInput, JournalEntryUncheckedUpdateManyWithoutUserInput>
  }

  export type JournalEntryScalarWhereInput = {
    AND?: JournalEntryScalarWhereInput | JournalEntryScalarWhereInput[]
    OR?: JournalEntryScalarWhereInput[]
    NOT?: JournalEntryScalarWhereInput | JournalEntryScalarWhereInput[]
    id?: StringFilter<"JournalEntry"> | string
    userId?: StringFilter<"JournalEntry"> | string
    date?: DateTimeFilter<"JournalEntry"> | Date | string
    category?: EnumJournalCategoryFilter<"JournalEntry"> | $Enums.JournalCategory
    content?: StringFilter<"JournalEntry"> | string
    createdAt?: DateTimeFilter<"JournalEntry"> | Date | string
    updatedAt?: DateTimeFilter<"JournalEntry"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    oldData?: JsonNullableFilter<"AuditLog">
    newData?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type LogUpsertWithWhereUniqueWithoutUserInput = {
    where: LogWhereUniqueInput
    update: XOR<LogUpdateWithoutUserInput, LogUncheckedUpdateWithoutUserInput>
    create: XOR<LogCreateWithoutUserInput, LogUncheckedCreateWithoutUserInput>
  }

  export type LogUpdateWithWhereUniqueWithoutUserInput = {
    where: LogWhereUniqueInput
    data: XOR<LogUpdateWithoutUserInput, LogUncheckedUpdateWithoutUserInput>
  }

  export type LogUpdateManyWithWhereWithoutUserInput = {
    where: LogScalarWhereInput
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyWithoutUserInput>
  }

  export type LogScalarWhereInput = {
    AND?: LogScalarWhereInput | LogScalarWhereInput[]
    OR?: LogScalarWhereInput[]
    NOT?: LogScalarWhereInput | LogScalarWhereInput[]
    id?: StringFilter<"Log"> | string
    userId?: StringNullableFilter<"Log"> | string | null
    eventType?: EnumEventTypeFilter<"Log"> | $Enums.EventType
    description?: StringNullableFilter<"Log"> | string | null
    timestamp?: DateTimeFilter<"Log"> | Date | string
    metadata?: JsonNullableFilter<"Log">
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    tokenHash?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revoked?: BoolFilter<"RefreshToken"> | boolean
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeFilter<"RefreshToken"> | Date | string
  }

  export type AuthSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: AuthSessionWhereUniqueInput
    update: XOR<AuthSessionUpdateWithoutUserInput, AuthSessionUncheckedUpdateWithoutUserInput>
    create: XOR<AuthSessionCreateWithoutUserInput, AuthSessionUncheckedCreateWithoutUserInput>
  }

  export type AuthSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: AuthSessionWhereUniqueInput
    data: XOR<AuthSessionUpdateWithoutUserInput, AuthSessionUncheckedUpdateWithoutUserInput>
  }

  export type AuthSessionUpdateManyWithWhereWithoutUserInput = {
    where: AuthSessionScalarWhereInput
    data: XOR<AuthSessionUpdateManyMutationInput, AuthSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type AuthSessionScalarWhereInput = {
    AND?: AuthSessionScalarWhereInput | AuthSessionScalarWhereInput[]
    OR?: AuthSessionScalarWhereInput[]
    NOT?: AuthSessionScalarWhereInput | AuthSessionScalarWhereInput[]
    id?: StringFilter<"AuthSession"> | string
    userId?: StringFilter<"AuthSession"> | string
    userAgent?: StringNullableFilter<"AuthSession"> | string | null
    ipAddress?: StringNullableFilter<"AuthSession"> | string | null
    lastSeen?: DateTimeFilter<"AuthSession"> | Date | string
    isActive?: BoolFilter<"AuthSession"> | boolean
    createdAt?: DateTimeFilter<"AuthSession"> | Date | string
    updatedAt?: DateTimeFilter<"AuthSession"> | Date | string
  }

  export type PhaseCreateManyCycleInput = {
    id?: string
    name: $Enums.CyclePhase
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PhaseUpdateWithoutCycleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumCyclePhaseFieldUpdateOperationsInput | $Enums.CyclePhase
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhaseUncheckedUpdateWithoutCycleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumCyclePhaseFieldUpdateOperationsInput | $Enums.CyclePhase
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhaseUncheckedUpdateManyWithoutCycleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumCyclePhaseFieldUpdateOperationsInput | $Enums.CyclePhase
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CycleCreateManyProviderInput = {
    id?: string
    userId: string
    startDate: Date | string
    cycleLength?: number | null
    periodLength?: number | null
    isRegular?: boolean
    externalCycleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CycleUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cycleLength?: NullableIntFieldUpdateOperationsInput | number | null
    periodLength?: NullableIntFieldUpdateOperationsInput | number | null
    isRegular?: BoolFieldUpdateOperationsInput | boolean
    externalCycleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCyclesNestedInput
    phases?: PhaseUpdateManyWithoutCycleNestedInput
  }

  export type CycleUncheckedUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cycleLength?: NullableIntFieldUpdateOperationsInput | number | null
    periodLength?: NullableIntFieldUpdateOperationsInput | number | null
    isRegular?: BoolFieldUpdateOperationsInput | boolean
    externalCycleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phases?: PhaseUncheckedUpdateManyWithoutCycleNestedInput
  }

  export type CycleUncheckedUpdateManyWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cycleLength?: NullableIntFieldUpdateOperationsInput | number | null
    periodLength?: NullableIntFieldUpdateOperationsInput | number | null
    isRegular?: BoolFieldUpdateOperationsInput | boolean
    externalCycleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseTagCreateManyExerciseInput = {
    id?: string
    tagId: string
    createdAt?: Date | string
  }

  export type PhaseExerciseCreateManyExerciseInput = {
    id?: string
    phaseName: $Enums.CyclePhase
    createdAt?: Date | string
  }

  export type ProgramExerciseCreateManyExerciseInput = {
    id?: string
    programId: string
    day: number
    order: number
    createdAt?: Date | string
  }

  export type ExerciseTagUpdateWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: TagUpdateOneRequiredWithoutExerciseTagsNestedInput
  }

  export type ExerciseTagUncheckedUpdateWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseTagUncheckedUpdateManyWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhaseExerciseUpdateWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    phaseName?: EnumCyclePhaseFieldUpdateOperationsInput | $Enums.CyclePhase
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhaseExerciseUncheckedUpdateWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    phaseName?: EnumCyclePhaseFieldUpdateOperationsInput | $Enums.CyclePhase
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhaseExerciseUncheckedUpdateManyWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    phaseName?: EnumCyclePhaseFieldUpdateOperationsInput | $Enums.CyclePhase
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramExerciseUpdateWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    day?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    program?: ProgramUpdateOneRequiredWithoutProgramExercisesNestedInput
  }

  export type ProgramExerciseUncheckedUpdateWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    day?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramExerciseUncheckedUpdateManyWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    programId?: StringFieldUpdateOperationsInput | string
    day?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseTagCreateManyTagInput = {
    id?: string
    exerciseId: string
    createdAt?: Date | string
  }

  export type ExerciseTagUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exercise?: ExerciseUpdateOneRequiredWithoutExerciseTagsNestedInput
  }

  export type ExerciseTagUncheckedUpdateWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseTagUncheckedUpdateManyWithoutTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramExerciseCreateManyProgramInput = {
    id?: string
    exerciseId: string
    day: number
    order: number
    createdAt?: Date | string
  }

  export type NotificationCreateManyRelatedProgramInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    message: string
    date: Date | string
    relatedPhase?: string | null
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgramExerciseUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    day?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exercise?: ExerciseUpdateOneRequiredWithoutProgramExercisesNestedInput
  }

  export type ProgramExerciseUncheckedUpdateWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    day?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramExerciseUncheckedUpdateManyWithoutProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseId?: StringFieldUpdateOperationsInput | string
    day?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutRelatedProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    message?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedPhase?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutRelatedProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    message?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedPhase?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutRelatedProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    message?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedPhase?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CycleCreateManyUserInput = {
    id?: string
    startDate: Date | string
    cycleLength?: number | null
    periodLength?: number | null
    isRegular?: boolean
    providerId?: string | null
    externalCycleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgramCreateManyUserInput = {
    id?: string
    title: string
    goal?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MoodTrackCreateManyUserInput = {
    id?: string
    date: Date | string
    mood?: $Enums.MoodType | null
    energy?: $Enums.EnergyLevel | null
    pain?: $Enums.PainLevel | null
    stress?: $Enums.StressLevel | null
    sleepQuality?: $Enums.SleepQuality | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReminderSettingsCreateManyUserInput = {
    id?: string
    type: $Enums.ReminderType
    enabled?: boolean
    time?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserFeatureFlagCreateManyUserInput = {
    id?: string
    feature: string
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserObjectiveCreateManyUserInput = {
    id?: string
    type: $Enums.ObjectiveType
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileChangeLogCreateManyUserInput = {
    id?: string
    changeType: $Enums.ChangeType
    details?: string | null
    changedAt?: Date | string
  }

  export type SymptomLogCreateManyUserInput = {
    id?: string
    date: Date | string
    symptomType: $Enums.SymptomType
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: $Enums.NotificationType
    message: string
    date: Date | string
    relatedPhase?: string | null
    relatedProgramId?: string | null
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExternalSyncCreateManyUserInput = {
    id?: string
    provider: $Enums.ExternalProvider
    entitySynced: string
    externalId: string
    status: $Enums.ExternalSyncStatus
    message?: string | null
    syncedAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JournalEntryCreateManyUserInput = {
    id?: string
    date: Date | string
    category: $Enums.JournalCategory
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    entity: string
    entityId?: string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LogCreateManyUserInput = {
    id?: string
    eventType: $Enums.EventType
    description?: string | null
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RefreshTokenCreateManyUserInput = {
    id?: string
    tokenHash: string
    expiresAt: Date | string
    revoked?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthSessionCreateManyUserInput = {
    id?: string
    userAgent?: string | null
    ipAddress?: string | null
    lastSeen: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CycleUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cycleLength?: NullableIntFieldUpdateOperationsInput | number | null
    periodLength?: NullableIntFieldUpdateOperationsInput | number | null
    isRegular?: BoolFieldUpdateOperationsInput | boolean
    externalCycleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: CycleProviderUpdateOneWithoutCyclesNestedInput
    phases?: PhaseUpdateManyWithoutCycleNestedInput
  }

  export type CycleUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cycleLength?: NullableIntFieldUpdateOperationsInput | number | null
    periodLength?: NullableIntFieldUpdateOperationsInput | number | null
    isRegular?: BoolFieldUpdateOperationsInput | boolean
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    externalCycleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phases?: PhaseUncheckedUpdateManyWithoutCycleNestedInput
  }

  export type CycleUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cycleLength?: NullableIntFieldUpdateOperationsInput | number | null
    periodLength?: NullableIntFieldUpdateOperationsInput | number | null
    isRegular?: BoolFieldUpdateOperationsInput | boolean
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    externalCycleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    goal?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programExercises?: ProgramExerciseUpdateManyWithoutProgramNestedInput
    notifications?: NotificationUpdateManyWithoutRelatedProgramNestedInput
  }

  export type ProgramUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    goal?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programExercises?: ProgramExerciseUncheckedUpdateManyWithoutProgramNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRelatedProgramNestedInput
  }

  export type ProgramUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    goal?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MoodTrackUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    mood?: NullableEnumMoodTypeFieldUpdateOperationsInput | $Enums.MoodType | null
    energy?: NullableEnumEnergyLevelFieldUpdateOperationsInput | $Enums.EnergyLevel | null
    pain?: NullableEnumPainLevelFieldUpdateOperationsInput | $Enums.PainLevel | null
    stress?: NullableEnumStressLevelFieldUpdateOperationsInput | $Enums.StressLevel | null
    sleepQuality?: NullableEnumSleepQualityFieldUpdateOperationsInput | $Enums.SleepQuality | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MoodTrackUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    mood?: NullableEnumMoodTypeFieldUpdateOperationsInput | $Enums.MoodType | null
    energy?: NullableEnumEnergyLevelFieldUpdateOperationsInput | $Enums.EnergyLevel | null
    pain?: NullableEnumPainLevelFieldUpdateOperationsInput | $Enums.PainLevel | null
    stress?: NullableEnumStressLevelFieldUpdateOperationsInput | $Enums.StressLevel | null
    sleepQuality?: NullableEnumSleepQualityFieldUpdateOperationsInput | $Enums.SleepQuality | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MoodTrackUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    mood?: NullableEnumMoodTypeFieldUpdateOperationsInput | $Enums.MoodType | null
    energy?: NullableEnumEnergyLevelFieldUpdateOperationsInput | $Enums.EnergyLevel | null
    pain?: NullableEnumPainLevelFieldUpdateOperationsInput | $Enums.PainLevel | null
    stress?: NullableEnumStressLevelFieldUpdateOperationsInput | $Enums.StressLevel | null
    sleepQuality?: NullableEnumSleepQualityFieldUpdateOperationsInput | $Enums.SleepQuality | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReminderSettingsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReminderTypeFieldUpdateOperationsInput | $Enums.ReminderType
    enabled?: BoolFieldUpdateOperationsInput | boolean
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReminderSettingsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReminderTypeFieldUpdateOperationsInput | $Enums.ReminderType
    enabled?: BoolFieldUpdateOperationsInput | boolean
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReminderSettingsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReminderTypeFieldUpdateOperationsInput | $Enums.ReminderType
    enabled?: BoolFieldUpdateOperationsInput | boolean
    time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFeatureFlagUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFeatureFlagUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFeatureFlagUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    feature?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserObjectiveUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumObjectiveTypeFieldUpdateOperationsInput | $Enums.ObjectiveType
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserObjectiveUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumObjectiveTypeFieldUpdateOperationsInput | $Enums.ObjectiveType
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserObjectiveUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumObjectiveTypeFieldUpdateOperationsInput | $Enums.ObjectiveType
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileChangeLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeType?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    details?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileChangeLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeType?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    details?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileChangeLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeType?: EnumChangeTypeFieldUpdateOperationsInput | $Enums.ChangeType
    details?: NullableStringFieldUpdateOperationsInput | string | null
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SymptomLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    symptomType?: EnumSymptomTypeFieldUpdateOperationsInput | $Enums.SymptomType
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SymptomLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    symptomType?: EnumSymptomTypeFieldUpdateOperationsInput | $Enums.SymptomType
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SymptomLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    symptomType?: EnumSymptomTypeFieldUpdateOperationsInput | $Enums.SymptomType
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    message?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedPhase?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedProgram?: ProgramUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    message?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedPhase?: NullableStringFieldUpdateOperationsInput | string | null
    relatedProgramId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    message?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedPhase?: NullableStringFieldUpdateOperationsInput | string | null
    relatedProgramId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalSyncUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumExternalProviderFieldUpdateOperationsInput | $Enums.ExternalProvider
    entitySynced?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    status?: EnumExternalSyncStatusFieldUpdateOperationsInput | $Enums.ExternalSyncStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    syncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalSyncUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumExternalProviderFieldUpdateOperationsInput | $Enums.ExternalProvider
    entitySynced?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    status?: EnumExternalSyncStatusFieldUpdateOperationsInput | $Enums.ExternalSyncStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    syncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalSyncUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumExternalProviderFieldUpdateOperationsInput | $Enums.ExternalProvider
    entitySynced?: StringFieldUpdateOperationsInput | string
    externalId?: StringFieldUpdateOperationsInput | string
    status?: EnumExternalSyncStatusFieldUpdateOperationsInput | $Enums.ExternalSyncStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    syncedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalEntryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumJournalCategoryFieldUpdateOperationsInput | $Enums.JournalCategory
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalEntryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumJournalCategoryFieldUpdateOperationsInput | $Enums.JournalCategory
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalEntryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumJournalCategoryFieldUpdateOperationsInput | $Enums.JournalCategory
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}